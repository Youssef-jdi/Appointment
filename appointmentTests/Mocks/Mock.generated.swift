// Generated using Sourcery 0.17.0 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT


// Generated with SwiftyMocky 3.5.0

import SwiftyMocky
#if !MockyCustom
import XCTest
#endif
import Moya
import p2_OAuth2
import Result
import RxSwift
@testable import appointment


// MARK: - AddDateDelegate
open class AddDateDelegateMock: AddDateDelegate, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func didAdd(date: AppointmentDate) {
        addInvocation(.m_didAdd__date_date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_didAdd__date_date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }


    fileprivate enum MethodType {
        case m_didAdd__date_date(Parameter<AppointmentDate>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didAdd__date_date(let lhsDate), .m_didAdd__date_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_didAdd__date_date(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func didAdd(date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_didAdd__date_date(`date`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func didAdd(date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_didAdd__date_date(`date`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AddDateInteractorProtocol
open class AddDateInteractorProtocolMock: AddDateInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func handleSetInvitation(_ invitation: Appointment) {
        addInvocation(.m_handleSetInvitation__invitation(Parameter<Appointment>.value(`invitation`)))
		let perform = methodPerformValue(.m_handleSetInvitation__invitation(Parameter<Appointment>.value(`invitation`))) as? (Appointment) -> Void
		perform?(`invitation`)
    }

    open func handleViewDidLoad() {
        addInvocation(.m_handleViewDidLoad)
		let perform = methodPerformValue(.m_handleViewDidLoad) as? () -> Void
		perform?()
    }

    open func handleSelectStartDate(date: Date) {
        addInvocation(.m_handleSelectStartDate__date_date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_handleSelectStartDate__date_date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
    }

    open func handleSelectEndDate(date: Date) {
        addInvocation(.m_handleSelectEndDate__date_date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_handleSelectEndDate__date_date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
    }

    open func handleSuggestDayTapped() {
        addInvocation(.m_handleSuggestDayTapped)
		let perform = methodPerformValue(.m_handleSuggestDayTapped) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_handleSetInvitation__invitation(Parameter<Appointment>)
        case m_handleViewDidLoad
        case m_handleSelectStartDate__date_date(Parameter<Date>)
        case m_handleSelectEndDate__date_date(Parameter<Date>)
        case m_handleSuggestDayTapped

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_handleSetInvitation__invitation(let lhsInvitation), .m_handleSetInvitation__invitation(let rhsInvitation)):
                guard Parameter.compare(lhs: lhsInvitation, rhs: rhsInvitation, with: matcher) else { return false } 
                return true 
            case (.m_handleViewDidLoad, .m_handleViewDidLoad):
                return true 
            case (.m_handleSelectStartDate__date_date(let lhsDate), .m_handleSelectStartDate__date_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_handleSelectEndDate__date_date(let lhsDate), .m_handleSelectEndDate__date_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_handleSuggestDayTapped, .m_handleSuggestDayTapped):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_handleSetInvitation__invitation(p0): return p0.intValue
            case .m_handleViewDidLoad: return 0
            case let .m_handleSelectStartDate__date_date(p0): return p0.intValue
            case let .m_handleSelectEndDate__date_date(p0): return p0.intValue
            case .m_handleSuggestDayTapped: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func handleSetInvitation(_ invitation: Parameter<Appointment>) -> Verify { return Verify(method: .m_handleSetInvitation__invitation(`invitation`))}
        public static func handleViewDidLoad() -> Verify { return Verify(method: .m_handleViewDidLoad)}
        public static func handleSelectStartDate(date: Parameter<Date>) -> Verify { return Verify(method: .m_handleSelectStartDate__date_date(`date`))}
        public static func handleSelectEndDate(date: Parameter<Date>) -> Verify { return Verify(method: .m_handleSelectEndDate__date_date(`date`))}
        public static func handleSuggestDayTapped() -> Verify { return Verify(method: .m_handleSuggestDayTapped)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func handleSetInvitation(_ invitation: Parameter<Appointment>, perform: @escaping (Appointment) -> Void) -> Perform {
            return Perform(method: .m_handleSetInvitation__invitation(`invitation`), performs: perform)
        }
        public static func handleViewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_handleViewDidLoad, performs: perform)
        }
        public static func handleSelectStartDate(date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_handleSelectStartDate__date_date(`date`), performs: perform)
        }
        public static func handleSelectEndDate(date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_handleSelectEndDate__date_date(`date`), performs: perform)
        }
        public static func handleSuggestDayTapped(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_handleSuggestDayTapped, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AddDatePresenterProtocol
open class AddDatePresenterProtocolMock: AddDatePresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: AddDateViewControllerProtocol) {
        addInvocation(.m_set__viewController_viewController(Parameter<AddDateViewControllerProtocol>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<AddDateViewControllerProtocol>.value(`viewController`))) as? (AddDateViewControllerProtocol) -> Void
		perform?(`viewController`)
    }

    open func presentCalendar(_ calendarViewController: DayCalendarViewController) {
        addInvocation(.m_presentCalendar__calendarViewController(Parameter<DayCalendarViewController>.value(`calendarViewController`)))
		let perform = methodPerformValue(.m_presentCalendar__calendarViewController(Parameter<DayCalendarViewController>.value(`calendarViewController`))) as? (DayCalendarViewController) -> Void
		perform?(`calendarViewController`)
    }

    open func presentCalendar(for date: Date) {
        addInvocation(.m_presentCalendar__for_date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_presentCalendar__for_date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
    }

    open func presentSelectStartDate(_ date: Date) {
        addInvocation(.m_presentSelectStartDate__date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_presentSelectStartDate__date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
    }

    open func presentSelectEndDate(_ date: Date) {
        addInvocation(.m_presentSelectEndDate__date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_presentSelectEndDate__date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
    }

    open func presentDateAdded(_ date: AppointmentDate) {
        addInvocation(.m_presentDateAdded__date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_presentDateAdded__date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<AddDateViewControllerProtocol>)
        case m_presentCalendar__calendarViewController(Parameter<DayCalendarViewController>)
        case m_presentCalendar__for_date(Parameter<Date>)
        case m_presentSelectStartDate__date(Parameter<Date>)
        case m_presentSelectEndDate__date(Parameter<Date>)
        case m_presentDateAdded__date(Parameter<AppointmentDate>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_presentCalendar__calendarViewController(let lhsCalendarviewcontroller), .m_presentCalendar__calendarViewController(let rhsCalendarviewcontroller)):
                guard Parameter.compare(lhs: lhsCalendarviewcontroller, rhs: rhsCalendarviewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_presentCalendar__for_date(let lhsDate), .m_presentCalendar__for_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_presentSelectStartDate__date(let lhsDate), .m_presentSelectStartDate__date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_presentSelectEndDate__date(let lhsDate), .m_presentSelectEndDate__date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_presentDateAdded__date(let lhsDate), .m_presentDateAdded__date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_presentCalendar__calendarViewController(p0): return p0.intValue
            case let .m_presentCalendar__for_date(p0): return p0.intValue
            case let .m_presentSelectStartDate__date(p0): return p0.intValue
            case let .m_presentSelectEndDate__date(p0): return p0.intValue
            case let .m_presentDateAdded__date(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<AddDateViewControllerProtocol>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func presentCalendar(_ calendarViewController: Parameter<DayCalendarViewController>) -> Verify { return Verify(method: .m_presentCalendar__calendarViewController(`calendarViewController`))}
        public static func presentCalendar(for date: Parameter<Date>) -> Verify { return Verify(method: .m_presentCalendar__for_date(`date`))}
        public static func presentSelectStartDate(_ date: Parameter<Date>) -> Verify { return Verify(method: .m_presentSelectStartDate__date(`date`))}
        public static func presentSelectEndDate(_ date: Parameter<Date>) -> Verify { return Verify(method: .m_presentSelectEndDate__date(`date`))}
        public static func presentDateAdded(_ date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_presentDateAdded__date(`date`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<AddDateViewControllerProtocol>, perform: @escaping (AddDateViewControllerProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func presentCalendar(_ calendarViewController: Parameter<DayCalendarViewController>, perform: @escaping (DayCalendarViewController) -> Void) -> Perform {
            return Perform(method: .m_presentCalendar__calendarViewController(`calendarViewController`), performs: perform)
        }
        public static func presentCalendar(for date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_presentCalendar__for_date(`date`), performs: perform)
        }
        public static func presentSelectStartDate(_ date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_presentSelectStartDate__date(`date`), performs: perform)
        }
        public static func presentSelectEndDate(_ date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_presentSelectEndDate__date(`date`), performs: perform)
        }
        public static func presentDateAdded(_ date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_presentDateAdded__date(`date`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AddDateRouterProtocol
open class AddDateRouterProtocolMock: AddDateRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: AddDateViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<AddDateViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<AddDateViewControllerProtocol?>.value(`viewController`))) as? (AddDateViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: AddDateRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<AddDateRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<AddDateRouter.Scene>.value(`scene`))) as? (AddDateRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<AddDateViewControllerProtocol?>)
        case m_route__to_scene(Parameter<AddDateRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<AddDateViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<AddDateRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<AddDateViewControllerProtocol?>, perform: @escaping (AddDateViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<AddDateRouter.Scene>, perform: @escaping (AddDateRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AddDateViewControllerProtocol
open class AddDateViewControllerProtocolMock: AddDateViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(invitation: Appointment) {
        addInvocation(.m_set__invitation_invitation(Parameter<Appointment>.value(`invitation`)))
		let perform = methodPerformValue(.m_set__invitation_invitation(Parameter<Appointment>.value(`invitation`))) as? (Appointment) -> Void
		perform?(`invitation`)
    }

    open func displayStartDate(_ date: String) {
        addInvocation(.m_displayStartDate__date(Parameter<String>.value(`date`)))
		let perform = methodPerformValue(.m_displayStartDate__date(Parameter<String>.value(`date`))) as? (String) -> Void
		perform?(`date`)
    }

    open func displayEndTime(_ time: String) {
        addInvocation(.m_displayEndTime__time(Parameter<String>.value(`time`)))
		let perform = methodPerformValue(.m_displayEndTime__time(Parameter<String>.value(`time`))) as? (String) -> Void
		perform?(`time`)
    }

    open func displayCalendar(_ viewController: DayCalendarViewController) {
        addInvocation(.m_displayCalendar__viewController(Parameter<DayCalendarViewController>.value(`viewController`)))
		let perform = methodPerformValue(.m_displayCalendar__viewController(Parameter<DayCalendarViewController>.value(`viewController`))) as? (DayCalendarViewController) -> Void
		perform?(`viewController`)
    }

    open func displayCalendar(for date: Date) {
        addInvocation(.m_displayCalendar__for_date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_displayCalendar__for_date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
    }

    open func displayDateAdded(_ date: AppointmentDate) {
        addInvocation(.m_displayDateAdded__date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_displayDateAdded__date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__invitation_invitation(Parameter<Appointment>)
        case m_displayStartDate__date(Parameter<String>)
        case m_displayEndTime__time(Parameter<String>)
        case m_displayCalendar__viewController(Parameter<DayCalendarViewController>)
        case m_displayCalendar__for_date(Parameter<Date>)
        case m_displayDateAdded__date(Parameter<AppointmentDate>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__invitation_invitation(let lhsInvitation), .m_set__invitation_invitation(let rhsInvitation)):
                guard Parameter.compare(lhs: lhsInvitation, rhs: rhsInvitation, with: matcher) else { return false } 
                return true 
            case (.m_displayStartDate__date(let lhsDate), .m_displayStartDate__date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_displayEndTime__time(let lhsTime), .m_displayEndTime__time(let rhsTime)):
                guard Parameter.compare(lhs: lhsTime, rhs: rhsTime, with: matcher) else { return false } 
                return true 
            case (.m_displayCalendar__viewController(let lhsViewcontroller), .m_displayCalendar__viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_displayCalendar__for_date(let lhsDate), .m_displayCalendar__for_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_displayDateAdded__date(let lhsDate), .m_displayDateAdded__date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__invitation_invitation(p0): return p0.intValue
            case let .m_displayStartDate__date(p0): return p0.intValue
            case let .m_displayEndTime__time(p0): return p0.intValue
            case let .m_displayCalendar__viewController(p0): return p0.intValue
            case let .m_displayCalendar__for_date(p0): return p0.intValue
            case let .m_displayDateAdded__date(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(invitation: Parameter<Appointment>) -> Verify { return Verify(method: .m_set__invitation_invitation(`invitation`))}
        public static func displayStartDate(_ date: Parameter<String>) -> Verify { return Verify(method: .m_displayStartDate__date(`date`))}
        public static func displayEndTime(_ time: Parameter<String>) -> Verify { return Verify(method: .m_displayEndTime__time(`time`))}
        public static func displayCalendar(_ viewController: Parameter<DayCalendarViewController>) -> Verify { return Verify(method: .m_displayCalendar__viewController(`viewController`))}
        public static func displayCalendar(for date: Parameter<Date>) -> Verify { return Verify(method: .m_displayCalendar__for_date(`date`))}
        public static func displayDateAdded(_ date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_displayDateAdded__date(`date`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(invitation: Parameter<Appointment>, perform: @escaping (Appointment) -> Void) -> Perform {
            return Perform(method: .m_set__invitation_invitation(`invitation`), performs: perform)
        }
        public static func displayStartDate(_ date: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayStartDate__date(`date`), performs: perform)
        }
        public static func displayEndTime(_ time: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayEndTime__time(`time`), performs: perform)
        }
        public static func displayCalendar(_ viewController: Parameter<DayCalendarViewController>, perform: @escaping (DayCalendarViewController) -> Void) -> Perform {
            return Perform(method: .m_displayCalendar__viewController(`viewController`), performs: perform)
        }
        public static func displayCalendar(for date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_displayCalendar__for_date(`date`), performs: perform)
        }
        public static func displayDateAdded(_ date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_displayDateAdded__date(`date`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AlertPresenterProtocol
open class AlertPresenterProtocolMock: AlertPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func presentAlert(title: String?, description: String?, actions: [UIAlertAction]) {
        addInvocation(.m_presentAlert__title_titledescription_descriptionactions_actions(Parameter<String?>.value(`title`), Parameter<String?>.value(`description`), Parameter<[UIAlertAction]>.value(`actions`)))
		let perform = methodPerformValue(.m_presentAlert__title_titledescription_descriptionactions_actions(Parameter<String?>.value(`title`), Parameter<String?>.value(`description`), Parameter<[UIAlertAction]>.value(`actions`))) as? (String?, String?, [UIAlertAction]) -> Void
		perform?(`title`, `description`, `actions`)
    }

    open func presentActionSheet(title: String?, description: String?, actions: [UIAlertAction]) {
        addInvocation(.m_presentActionSheet__title_titledescription_descriptionactions_actions(Parameter<String?>.value(`title`), Parameter<String?>.value(`description`), Parameter<[UIAlertAction]>.value(`actions`)))
		let perform = methodPerformValue(.m_presentActionSheet__title_titledescription_descriptionactions_actions(Parameter<String?>.value(`title`), Parameter<String?>.value(`description`), Parameter<[UIAlertAction]>.value(`actions`))) as? (String?, String?, [UIAlertAction]) -> Void
		perform?(`title`, `description`, `actions`)
    }

    open func presentAlertAttributed(title: NSAttributedString, description: NSAttributedString, actions: [UIAlertAction]) {
        addInvocation(.m_presentAlertAttributed__title_titledescription_descriptionactions_actions(Parameter<NSAttributedString>.value(`title`), Parameter<NSAttributedString>.value(`description`), Parameter<[UIAlertAction]>.value(`actions`)))
		let perform = methodPerformValue(.m_presentAlertAttributed__title_titledescription_descriptionactions_actions(Parameter<NSAttributedString>.value(`title`), Parameter<NSAttributedString>.value(`description`), Parameter<[UIAlertAction]>.value(`actions`))) as? (NSAttributedString, NSAttributedString, [UIAlertAction]) -> Void
		perform?(`title`, `description`, `actions`)
    }


    fileprivate enum MethodType {
        case m_presentAlert__title_titledescription_descriptionactions_actions(Parameter<String?>, Parameter<String?>, Parameter<[UIAlertAction]>)
        case m_presentActionSheet__title_titledescription_descriptionactions_actions(Parameter<String?>, Parameter<String?>, Parameter<[UIAlertAction]>)
        case m_presentAlertAttributed__title_titledescription_descriptionactions_actions(Parameter<NSAttributedString>, Parameter<NSAttributedString>, Parameter<[UIAlertAction]>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentAlert__title_titledescription_descriptionactions_actions(let lhsTitle, let lhsDescription, let lhsActions), .m_presentAlert__title_titledescription_descriptionactions_actions(let rhsTitle, let rhsDescription, let rhsActions)):
                guard Parameter.compare(lhs: lhsTitle, rhs: rhsTitle, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDescription, rhs: rhsDescription, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsActions, rhs: rhsActions, with: matcher) else { return false } 
                return true 
            case (.m_presentActionSheet__title_titledescription_descriptionactions_actions(let lhsTitle, let lhsDescription, let lhsActions), .m_presentActionSheet__title_titledescription_descriptionactions_actions(let rhsTitle, let rhsDescription, let rhsActions)):
                guard Parameter.compare(lhs: lhsTitle, rhs: rhsTitle, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDescription, rhs: rhsDescription, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsActions, rhs: rhsActions, with: matcher) else { return false } 
                return true 
            case (.m_presentAlertAttributed__title_titledescription_descriptionactions_actions(let lhsTitle, let lhsDescription, let lhsActions), .m_presentAlertAttributed__title_titledescription_descriptionactions_actions(let rhsTitle, let rhsDescription, let rhsActions)):
                guard Parameter.compare(lhs: lhsTitle, rhs: rhsTitle, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDescription, rhs: rhsDescription, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsActions, rhs: rhsActions, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_presentAlert__title_titledescription_descriptionactions_actions(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_presentActionSheet__title_titledescription_descriptionactions_actions(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_presentAlertAttributed__title_titledescription_descriptionactions_actions(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func presentAlert(title: Parameter<String?>, description: Parameter<String?>, actions: Parameter<[UIAlertAction]>) -> Verify { return Verify(method: .m_presentAlert__title_titledescription_descriptionactions_actions(`title`, `description`, `actions`))}
        public static func presentActionSheet(title: Parameter<String?>, description: Parameter<String?>, actions: Parameter<[UIAlertAction]>) -> Verify { return Verify(method: .m_presentActionSheet__title_titledescription_descriptionactions_actions(`title`, `description`, `actions`))}
        public static func presentAlertAttributed(title: Parameter<NSAttributedString>, description: Parameter<NSAttributedString>, actions: Parameter<[UIAlertAction]>) -> Verify { return Verify(method: .m_presentAlertAttributed__title_titledescription_descriptionactions_actions(`title`, `description`, `actions`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func presentAlert(title: Parameter<String?>, description: Parameter<String?>, actions: Parameter<[UIAlertAction]>, perform: @escaping (String?, String?, [UIAlertAction]) -> Void) -> Perform {
            return Perform(method: .m_presentAlert__title_titledescription_descriptionactions_actions(`title`, `description`, `actions`), performs: perform)
        }
        public static func presentActionSheet(title: Parameter<String?>, description: Parameter<String?>, actions: Parameter<[UIAlertAction]>, perform: @escaping (String?, String?, [UIAlertAction]) -> Void) -> Perform {
            return Perform(method: .m_presentActionSheet__title_titledescription_descriptionactions_actions(`title`, `description`, `actions`), performs: perform)
        }
        public static func presentAlertAttributed(title: Parameter<NSAttributedString>, description: Parameter<NSAttributedString>, actions: Parameter<[UIAlertAction]>, perform: @escaping (NSAttributedString, NSAttributedString, [UIAlertAction]) -> Void) -> Perform {
            return Perform(method: .m_presentAlertAttributed__title_titledescription_descriptionactions_actions(`title`, `description`, `actions`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AppError
open class AppErrorMock: AppError, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }

    public var title: String {
		get {	invocations.append(.p_title_get); return __p_title ?? givenGetterValue(.p_title_get, "AppErrorMock - stub value for title was not defined") }
		@available(*, deprecated, message: "Using setters on readonly variables is deprecated, and will be removed in 3.1. Use Given to define stubbed property return value.")
		set {	__p_title = newValue }
	}
	private var __p_title: (String)?

    public var localizedDescription: String {
		get {	invocations.append(.p_localizedDescription_get); return __p_localizedDescription ?? givenGetterValue(.p_localizedDescription_get, "AppErrorMock - stub value for localizedDescription was not defined") }
		@available(*, deprecated, message: "Using setters on readonly variables is deprecated, and will be removed in 3.1. Use Given to define stubbed property return value.")
		set {	__p_localizedDescription = newValue }
	}
	private var __p_localizedDescription: (String)?






    fileprivate enum MethodType {
        case p_title_get
        case p_localizedDescription_get

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_title_get,.p_title_get): return true
            case (.p_localizedDescription_get,.p_localizedDescription_get): return true
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_title_get: return 0
            case .p_localizedDescription_get: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }

        public static func title(getter defaultValue: String...) -> PropertyStub {
            return Given(method: .p_title_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }
        public static func localizedDescription(getter defaultValue: String...) -> PropertyStub {
            return Given(method: .p_localizedDescription_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }

    }

    public struct Verify {
        fileprivate var method: MethodType

        public static var title: Verify { return Verify(method: .p_title_get) }
        public static var localizedDescription: Verify { return Verify(method: .p_localizedDescription_get) }
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AppointmentAppProtocol
open class AppointmentAppProtocolMock: AppointmentAppProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func prepare() {
        addInvocation(.m_prepare)
		let perform = methodPerformValue(.m_prepare) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_prepare

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_prepare, .m_prepare):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_prepare: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func prepare() -> Verify { return Verify(method: .m_prepare)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func prepare(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_prepare, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AppointmentDataServiceProtocol
open class AppointmentDataServiceProtocolMock: AppointmentDataServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func sync(appointments: [Appointment], _ completion: @escaping ArrayLocalCompletion<[AppointmentEntity]>) {
        addInvocation(.m_sync__appointments_appointments_completion(Parameter<[Appointment]>.value(`appointments`), Parameter<ArrayLocalCompletion<[AppointmentEntity]>>.any))
		let perform = methodPerformValue(.m_sync__appointments_appointments_completion(Parameter<[Appointment]>.value(`appointments`), Parameter<ArrayLocalCompletion<[AppointmentEntity]>>.any)) as? ([Appointment], @escaping ArrayLocalCompletion<[AppointmentEntity]>) -> Void
		perform?(`appointments`, `completion`)
    }

    open func create(appointment: Appointment, _ completion: @escaping RequestLocalCompletion<AppointmentEntity>) {
        addInvocation(.m_create__appointment_appointment_completion(Parameter<Appointment>.value(`appointment`), Parameter<RequestLocalCompletion<AppointmentEntity>>.any))
		let perform = methodPerformValue(.m_create__appointment_appointment_completion(Parameter<Appointment>.value(`appointment`), Parameter<RequestLocalCompletion<AppointmentEntity>>.any)) as? (Appointment, @escaping RequestLocalCompletion<AppointmentEntity>) -> Void
		perform?(`appointment`, `completion`)
    }

    open func fetchAppointments(appointmentId: Int?, _ completion: @escaping ArrayLocalCompletion<[AppointmentEntity?]>) {
        addInvocation(.m_fetchAppointments__appointmentId_appointmentId_completion(Parameter<Int?>.value(`appointmentId`), Parameter<ArrayLocalCompletion<[AppointmentEntity?]>>.any))
		let perform = methodPerformValue(.m_fetchAppointments__appointmentId_appointmentId_completion(Parameter<Int?>.value(`appointmentId`), Parameter<ArrayLocalCompletion<[AppointmentEntity?]>>.any)) as? (Int?, @escaping ArrayLocalCompletion<[AppointmentEntity?]>) -> Void
		perform?(`appointmentId`, `completion`)
    }

    open func deleteAppointment(with id: Int?) {
        addInvocation(.m_deleteAppointment__with_id(Parameter<Int?>.value(`id`)))
		let perform = methodPerformValue(.m_deleteAppointment__with_id(Parameter<Int?>.value(`id`))) as? (Int?) -> Void
		perform?(`id`)
    }

    open func updateAppointment(appointmentId: Int, appointmentStatus: AppointmentStatus, _ completion: @escaping RequestLocalCompletion<Void>) {
        addInvocation(.m_updateAppointment__appointmentId_appointmentIdappointmentStatus_appointmentStatus_completion(Parameter<Int>.value(`appointmentId`), Parameter<AppointmentStatus>.value(`appointmentStatus`), Parameter<RequestLocalCompletion<Void>>.any))
		let perform = methodPerformValue(.m_updateAppointment__appointmentId_appointmentIdappointmentStatus_appointmentStatus_completion(Parameter<Int>.value(`appointmentId`), Parameter<AppointmentStatus>.value(`appointmentStatus`), Parameter<RequestLocalCompletion<Void>>.any)) as? (Int, AppointmentStatus, @escaping RequestLocalCompletion<Void>) -> Void
		perform?(`appointmentId`, `appointmentStatus`, `completion`)
    }


    fileprivate enum MethodType {
        case m_sync__appointments_appointments_completion(Parameter<[Appointment]>, Parameter<ArrayLocalCompletion<[AppointmentEntity]>>)
        case m_create__appointment_appointment_completion(Parameter<Appointment>, Parameter<RequestLocalCompletion<AppointmentEntity>>)
        case m_fetchAppointments__appointmentId_appointmentId_completion(Parameter<Int?>, Parameter<ArrayLocalCompletion<[AppointmentEntity?]>>)
        case m_deleteAppointment__with_id(Parameter<Int?>)
        case m_updateAppointment__appointmentId_appointmentIdappointmentStatus_appointmentStatus_completion(Parameter<Int>, Parameter<AppointmentStatus>, Parameter<RequestLocalCompletion<Void>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_sync__appointments_appointments_completion(let lhsAppointments, let lhsCompletion), .m_sync__appointments_appointments_completion(let rhsAppointments, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointments, rhs: rhsAppointments, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_create__appointment_appointment_completion(let lhsAppointment, let lhsCompletion), .m_create__appointment_appointment_completion(let rhsAppointment, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointment, rhs: rhsAppointment, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_fetchAppointments__appointmentId_appointmentId_completion(let lhsAppointmentid, let lhsCompletion), .m_fetchAppointments__appointmentId_appointmentId_completion(let rhsAppointmentid, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_deleteAppointment__with_id(let lhsId), .m_deleteAppointment__with_id(let rhsId)):
                guard Parameter.compare(lhs: lhsId, rhs: rhsId, with: matcher) else { return false } 
                return true 
            case (.m_updateAppointment__appointmentId_appointmentIdappointmentStatus_appointmentStatus_completion(let lhsAppointmentid, let lhsAppointmentstatus, let lhsCompletion), .m_updateAppointment__appointmentId_appointmentIdappointmentStatus_appointmentStatus_completion(let rhsAppointmentid, let rhsAppointmentstatus, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsAppointmentstatus, rhs: rhsAppointmentstatus, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_sync__appointments_appointments_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_create__appointment_appointment_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_fetchAppointments__appointmentId_appointmentId_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_deleteAppointment__with_id(p0): return p0.intValue
            case let .m_updateAppointment__appointmentId_appointmentIdappointmentStatus_appointmentStatus_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func sync(appointments: Parameter<[Appointment]>, _ completion: Parameter<ArrayLocalCompletion<[AppointmentEntity]>>) -> Verify { return Verify(method: .m_sync__appointments_appointments_completion(`appointments`, `completion`))}
        public static func create(appointment: Parameter<Appointment>, _ completion: Parameter<RequestLocalCompletion<AppointmentEntity>>) -> Verify { return Verify(method: .m_create__appointment_appointment_completion(`appointment`, `completion`))}
        public static func fetchAppointments(appointmentId: Parameter<Int?>, _ completion: Parameter<ArrayLocalCompletion<[AppointmentEntity?]>>) -> Verify { return Verify(method: .m_fetchAppointments__appointmentId_appointmentId_completion(`appointmentId`, `completion`))}
        public static func deleteAppointment(with id: Parameter<Int?>) -> Verify { return Verify(method: .m_deleteAppointment__with_id(`id`))}
        public static func updateAppointment(appointmentId: Parameter<Int>, appointmentStatus: Parameter<AppointmentStatus>, _ completion: Parameter<RequestLocalCompletion<Void>>) -> Verify { return Verify(method: .m_updateAppointment__appointmentId_appointmentIdappointmentStatus_appointmentStatus_completion(`appointmentId`, `appointmentStatus`, `completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func sync(appointments: Parameter<[Appointment]>, _ completion: Parameter<ArrayLocalCompletion<[AppointmentEntity]>>, perform: @escaping ([Appointment], @escaping ArrayLocalCompletion<[AppointmentEntity]>) -> Void) -> Perform {
            return Perform(method: .m_sync__appointments_appointments_completion(`appointments`, `completion`), performs: perform)
        }
        public static func create(appointment: Parameter<Appointment>, _ completion: Parameter<RequestLocalCompletion<AppointmentEntity>>, perform: @escaping (Appointment, @escaping RequestLocalCompletion<AppointmentEntity>) -> Void) -> Perform {
            return Perform(method: .m_create__appointment_appointment_completion(`appointment`, `completion`), performs: perform)
        }
        public static func fetchAppointments(appointmentId: Parameter<Int?>, _ completion: Parameter<ArrayLocalCompletion<[AppointmentEntity?]>>, perform: @escaping (Int?, @escaping ArrayLocalCompletion<[AppointmentEntity?]>) -> Void) -> Perform {
            return Perform(method: .m_fetchAppointments__appointmentId_appointmentId_completion(`appointmentId`, `completion`), performs: perform)
        }
        public static func deleteAppointment(with id: Parameter<Int?>, perform: @escaping (Int?) -> Void) -> Perform {
            return Perform(method: .m_deleteAppointment__with_id(`id`), performs: perform)
        }
        public static func updateAppointment(appointmentId: Parameter<Int>, appointmentStatus: Parameter<AppointmentStatus>, _ completion: Parameter<RequestLocalCompletion<Void>>, perform: @escaping (Int, AppointmentStatus, @escaping RequestLocalCompletion<Void>) -> Void) -> Perform {
            return Perform(method: .m_updateAppointment__appointmentId_appointmentIdappointmentStatus_appointmentStatus_completion(`appointmentId`, `appointmentStatus`, `completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AppointmentDateApiServiceProtocol
open class AppointmentDateApiServiceProtocolMock: AppointmentDateApiServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func selectFinalDay(appointmentDateId: Int, appointmentId: Int, _ completion: @escaping RequestCompletion<Appointment>) {
        addInvocation(.m_selectFinalDay__appointmentDateId_appointmentDateIdappointmentId_appointmentId_completion(Parameter<Int>.value(`appointmentDateId`), Parameter<Int>.value(`appointmentId`), Parameter<RequestCompletion<Appointment>>.any))
		let perform = methodPerformValue(.m_selectFinalDay__appointmentDateId_appointmentDateIdappointmentId_appointmentId_completion(Parameter<Int>.value(`appointmentDateId`), Parameter<Int>.value(`appointmentId`), Parameter<RequestCompletion<Appointment>>.any)) as? (Int, Int, @escaping RequestCompletion<Appointment>) -> Void
		perform?(`appointmentDateId`, `appointmentId`, `completion`)
    }

    open func addSuggestedDate(for appointmentId: Int, start: Int, end: Int, _ completion: @escaping RequestCompletion<AppointmentDateResponse>) {
        addInvocation(.m_addSuggestedDate__for_appointmentIdstart_startend_end_completion(Parameter<Int>.value(`appointmentId`), Parameter<Int>.value(`start`), Parameter<Int>.value(`end`), Parameter<RequestCompletion<AppointmentDateResponse>>.any))
		let perform = methodPerformValue(.m_addSuggestedDate__for_appointmentIdstart_startend_end_completion(Parameter<Int>.value(`appointmentId`), Parameter<Int>.value(`start`), Parameter<Int>.value(`end`), Parameter<RequestCompletion<AppointmentDateResponse>>.any)) as? (Int, Int, Int, @escaping RequestCompletion<AppointmentDateResponse>) -> Void
		perform?(`appointmentId`, `start`, `end`, `completion`)
    }

    open func getProposedDates(appointmentId: Int, _ completion: @escaping RequestCompletion<[AppointmentProposedDate]>) {
        addInvocation(.m_getProposedDates__appointmentId_appointmentId_completion(Parameter<Int>.value(`appointmentId`), Parameter<RequestCompletion<[AppointmentProposedDate]>>.any))
		let perform = methodPerformValue(.m_getProposedDates__appointmentId_appointmentId_completion(Parameter<Int>.value(`appointmentId`), Parameter<RequestCompletion<[AppointmentProposedDate]>>.any)) as? (Int, @escaping RequestCompletion<[AppointmentProposedDate]>) -> Void
		perform?(`appointmentId`, `completion`)
    }

    open func getDates(        for id: Int,        _ completion: @escaping RequestCompletion<[AppointmentDate]>    ) {
        addInvocation(.m_getDates__for_id_completion(Parameter<Int>.value(`id`), Parameter<RequestCompletion<[AppointmentDate]>>.any))
		let perform = methodPerformValue(.m_getDates__for_id_completion(Parameter<Int>.value(`id`), Parameter<RequestCompletion<[AppointmentDate]>>.any)) as? (Int, @escaping RequestCompletion<[AppointmentDate]>) -> Void
		perform?(`id`, `completion`)
    }

    open func respondToProposedDates(appointmentId: Int,                                proposeDateId: Int,                                status: Int,                                _ completion: @escaping RequestCompletion<[AppointmentProposedDate]>) {
        addInvocation(.m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(Parameter<Int>.value(`appointmentId`), Parameter<Int>.value(`proposeDateId`), Parameter<Int>.value(`status`), Parameter<RequestCompletion<[AppointmentProposedDate]>>.any))
		let perform = methodPerformValue(.m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(Parameter<Int>.value(`appointmentId`), Parameter<Int>.value(`proposeDateId`), Parameter<Int>.value(`status`), Parameter<RequestCompletion<[AppointmentProposedDate]>>.any)) as? (Int, Int, Int, @escaping RequestCompletion<[AppointmentProposedDate]>) -> Void
		perform?(`appointmentId`, `proposeDateId`, `status`, `completion`)
    }

    open func setAvailability(appointmentId: Int,                         appointmentDateId: Int,                         comment: String,                         availability: String,                         _ completion: @escaping RequestCompletion<AppointmentAvailability>    ) {
        addInvocation(.m_setAvailability__appointmentId_appointmentIdappointmentDateId_appointmentDateIdcomment_commentavailability_availability_completion(Parameter<Int>.value(`appointmentId`), Parameter<Int>.value(`appointmentDateId`), Parameter<String>.value(`comment`), Parameter<String>.value(`availability`), Parameter<RequestCompletion<AppointmentAvailability>>.any))
		let perform = methodPerformValue(.m_setAvailability__appointmentId_appointmentIdappointmentDateId_appointmentDateIdcomment_commentavailability_availability_completion(Parameter<Int>.value(`appointmentId`), Parameter<Int>.value(`appointmentDateId`), Parameter<String>.value(`comment`), Parameter<String>.value(`availability`), Parameter<RequestCompletion<AppointmentAvailability>>.any)) as? (Int, Int, String, String, @escaping RequestCompletion<AppointmentAvailability>) -> Void
		perform?(`appointmentId`, `appointmentDateId`, `comment`, `availability`, `completion`)
    }


    fileprivate enum MethodType {
        case m_selectFinalDay__appointmentDateId_appointmentDateIdappointmentId_appointmentId_completion(Parameter<Int>, Parameter<Int>, Parameter<RequestCompletion<Appointment>>)
        case m_addSuggestedDate__for_appointmentIdstart_startend_end_completion(Parameter<Int>, Parameter<Int>, Parameter<Int>, Parameter<RequestCompletion<AppointmentDateResponse>>)
        case m_getProposedDates__appointmentId_appointmentId_completion(Parameter<Int>, Parameter<RequestCompletion<[AppointmentProposedDate]>>)
        case m_getDates__for_id_completion(Parameter<Int>, Parameter<RequestCompletion<[AppointmentDate]>>)
        case m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(Parameter<Int>, Parameter<Int>, Parameter<Int>, Parameter<RequestCompletion<[AppointmentProposedDate]>>)
        case m_setAvailability__appointmentId_appointmentIdappointmentDateId_appointmentDateIdcomment_commentavailability_availability_completion(Parameter<Int>, Parameter<Int>, Parameter<String>, Parameter<String>, Parameter<RequestCompletion<AppointmentAvailability>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_selectFinalDay__appointmentDateId_appointmentDateIdappointmentId_appointmentId_completion(let lhsAppointmentdateid, let lhsAppointmentid, let lhsCompletion), .m_selectFinalDay__appointmentDateId_appointmentDateIdappointmentId_appointmentId_completion(let rhsAppointmentdateid, let rhsAppointmentid, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentdateid, rhs: rhsAppointmentdateid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_addSuggestedDate__for_appointmentIdstart_startend_end_completion(let lhsAppointmentid, let lhsStart, let lhsEnd, let lhsCompletion), .m_addSuggestedDate__for_appointmentIdstart_startend_end_completion(let rhsAppointmentid, let rhsStart, let rhsEnd, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsStart, rhs: rhsStart, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsEnd, rhs: rhsEnd, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_getProposedDates__appointmentId_appointmentId_completion(let lhsAppointmentid, let lhsCompletion), .m_getProposedDates__appointmentId_appointmentId_completion(let rhsAppointmentid, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_getDates__for_id_completion(let lhsId, let lhsCompletion), .m_getDates__for_id_completion(let rhsId, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsId, rhs: rhsId, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(let lhsAppointmentid, let lhsProposedateid, let lhsStatus, let lhsCompletion), .m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(let rhsAppointmentid, let rhsProposedateid, let rhsStatus, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsProposedateid, rhs: rhsProposedateid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsStatus, rhs: rhsStatus, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_setAvailability__appointmentId_appointmentIdappointmentDateId_appointmentDateIdcomment_commentavailability_availability_completion(let lhsAppointmentid, let lhsAppointmentdateid, let lhsComment, let lhsAvailability, let lhsCompletion), .m_setAvailability__appointmentId_appointmentIdappointmentDateId_appointmentDateIdcomment_commentavailability_availability_completion(let rhsAppointmentid, let rhsAppointmentdateid, let rhsComment, let rhsAvailability, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsAppointmentdateid, rhs: rhsAppointmentdateid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsComment, rhs: rhsComment, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsAvailability, rhs: rhsAvailability, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_selectFinalDay__appointmentDateId_appointmentDateIdappointmentId_appointmentId_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_addSuggestedDate__for_appointmentIdstart_startend_end_completion(p0, p1, p2, p3): return p0.intValue + p1.intValue + p2.intValue + p3.intValue
            case let .m_getProposedDates__appointmentId_appointmentId_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_getDates__for_id_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(p0, p1, p2, p3): return p0.intValue + p1.intValue + p2.intValue + p3.intValue
            case let .m_setAvailability__appointmentId_appointmentIdappointmentDateId_appointmentDateIdcomment_commentavailability_availability_completion(p0, p1, p2, p3, p4): return p0.intValue + p1.intValue + p2.intValue + p3.intValue + p4.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func selectFinalDay(appointmentDateId: Parameter<Int>, appointmentId: Parameter<Int>, _ completion: Parameter<RequestCompletion<Appointment>>) -> Verify { return Verify(method: .m_selectFinalDay__appointmentDateId_appointmentDateIdappointmentId_appointmentId_completion(`appointmentDateId`, `appointmentId`, `completion`))}
        public static func addSuggestedDate(for appointmentId: Parameter<Int>, start: Parameter<Int>, end: Parameter<Int>, _ completion: Parameter<RequestCompletion<AppointmentDateResponse>>) -> Verify { return Verify(method: .m_addSuggestedDate__for_appointmentIdstart_startend_end_completion(`appointmentId`, `start`, `end`, `completion`))}
        public static func getProposedDates(appointmentId: Parameter<Int>, _ completion: Parameter<RequestCompletion<[AppointmentProposedDate]>>) -> Verify { return Verify(method: .m_getProposedDates__appointmentId_appointmentId_completion(`appointmentId`, `completion`))}
        public static func getDates(for id: Parameter<Int>, _ completion: Parameter<RequestCompletion<[AppointmentDate]>>) -> Verify { return Verify(method: .m_getDates__for_id_completion(`id`, `completion`))}
        public static func respondToProposedDates(appointmentId: Parameter<Int>, proposeDateId: Parameter<Int>, status: Parameter<Int>, _ completion: Parameter<RequestCompletion<[AppointmentProposedDate]>>) -> Verify { return Verify(method: .m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(`appointmentId`, `proposeDateId`, `status`, `completion`))}
        public static func setAvailability(appointmentId: Parameter<Int>, appointmentDateId: Parameter<Int>, comment: Parameter<String>, availability: Parameter<String>, _ completion: Parameter<RequestCompletion<AppointmentAvailability>>) -> Verify { return Verify(method: .m_setAvailability__appointmentId_appointmentIdappointmentDateId_appointmentDateIdcomment_commentavailability_availability_completion(`appointmentId`, `appointmentDateId`, `comment`, `availability`, `completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func selectFinalDay(appointmentDateId: Parameter<Int>, appointmentId: Parameter<Int>, _ completion: Parameter<RequestCompletion<Appointment>>, perform: @escaping (Int, Int, @escaping RequestCompletion<Appointment>) -> Void) -> Perform {
            return Perform(method: .m_selectFinalDay__appointmentDateId_appointmentDateIdappointmentId_appointmentId_completion(`appointmentDateId`, `appointmentId`, `completion`), performs: perform)
        }
        public static func addSuggestedDate(for appointmentId: Parameter<Int>, start: Parameter<Int>, end: Parameter<Int>, _ completion: Parameter<RequestCompletion<AppointmentDateResponse>>, perform: @escaping (Int, Int, Int, @escaping RequestCompletion<AppointmentDateResponse>) -> Void) -> Perform {
            return Perform(method: .m_addSuggestedDate__for_appointmentIdstart_startend_end_completion(`appointmentId`, `start`, `end`, `completion`), performs: perform)
        }
        public static func getProposedDates(appointmentId: Parameter<Int>, _ completion: Parameter<RequestCompletion<[AppointmentProposedDate]>>, perform: @escaping (Int, @escaping RequestCompletion<[AppointmentProposedDate]>) -> Void) -> Perform {
            return Perform(method: .m_getProposedDates__appointmentId_appointmentId_completion(`appointmentId`, `completion`), performs: perform)
        }
        public static func getDates(for id: Parameter<Int>, _ completion: Parameter<RequestCompletion<[AppointmentDate]>>, perform: @escaping (Int, @escaping RequestCompletion<[AppointmentDate]>) -> Void) -> Perform {
            return Perform(method: .m_getDates__for_id_completion(`id`, `completion`), performs: perform)
        }
        public static func respondToProposedDates(appointmentId: Parameter<Int>, proposeDateId: Parameter<Int>, status: Parameter<Int>, _ completion: Parameter<RequestCompletion<[AppointmentProposedDate]>>, perform: @escaping (Int, Int, Int, @escaping RequestCompletion<[AppointmentProposedDate]>) -> Void) -> Perform {
            return Perform(method: .m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(`appointmentId`, `proposeDateId`, `status`, `completion`), performs: perform)
        }
        public static func setAvailability(appointmentId: Parameter<Int>, appointmentDateId: Parameter<Int>, comment: Parameter<String>, availability: Parameter<String>, _ completion: Parameter<RequestCompletion<AppointmentAvailability>>, perform: @escaping (Int, Int, String, String, @escaping RequestCompletion<AppointmentAvailability>) -> Void) -> Perform {
            return Perform(method: .m_setAvailability__appointmentId_appointmentIdappointmentDateId_appointmentDateIdcomment_commentavailability_availability_completion(`appointmentId`, `appointmentDateId`, `comment`, `availability`, `completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AppointmentDateDataServiceProtocol
open class AppointmentDateDataServiceProtocolMock: AppointmentDateDataServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func fetchAppointmentDates(for date: Int64?, _ completion: @escaping ArrayLocalCompletion<[AppointmentDateEntity?]>) {
        addInvocation(.m_fetchAppointmentDates__for_date_completion(Parameter<Int64?>.value(`date`), Parameter<ArrayLocalCompletion<[AppointmentDateEntity?]>>.any))
		let perform = methodPerformValue(.m_fetchAppointmentDates__for_date_completion(Parameter<Int64?>.value(`date`), Parameter<ArrayLocalCompletion<[AppointmentDateEntity?]>>.any)) as? (Int64?, @escaping ArrayLocalCompletion<[AppointmentDateEntity?]>) -> Void
		perform?(`date`, `completion`)
    }

    open func getProposedDates(appointmentId: Int16, _ completion: @escaping RequestCompletion<[ProposedDateEntity]>) {
        addInvocation(.m_getProposedDates__appointmentId_appointmentId_completion(Parameter<Int16>.value(`appointmentId`), Parameter<RequestCompletion<[ProposedDateEntity]>>.any))
		let perform = methodPerformValue(.m_getProposedDates__appointmentId_appointmentId_completion(Parameter<Int16>.value(`appointmentId`), Parameter<RequestCompletion<[ProposedDateEntity]>>.any)) as? (Int16, @escaping RequestCompletion<[ProposedDateEntity]>) -> Void
		perform?(`appointmentId`, `completion`)
    }

    open func respondToProposedDates(appointmentId: Int16,                                   proposeDateId: Int16,                                   status: Int16,                                   _ completion: @escaping RequestCompletion<[ProposedDateEntity]>) {
        addInvocation(.m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(Parameter<Int16>.value(`appointmentId`), Parameter<Int16>.value(`proposeDateId`), Parameter<Int16>.value(`status`), Parameter<RequestCompletion<[ProposedDateEntity]>>.any))
		let perform = methodPerformValue(.m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(Parameter<Int16>.value(`appointmentId`), Parameter<Int16>.value(`proposeDateId`), Parameter<Int16>.value(`status`), Parameter<RequestCompletion<[ProposedDateEntity]>>.any)) as? (Int16, Int16, Int16, @escaping RequestCompletion<[ProposedDateEntity]>) -> Void
		perform?(`appointmentId`, `proposeDateId`, `status`, `completion`)
    }


    fileprivate enum MethodType {
        case m_fetchAppointmentDates__for_date_completion(Parameter<Int64?>, Parameter<ArrayLocalCompletion<[AppointmentDateEntity?]>>)
        case m_getProposedDates__appointmentId_appointmentId_completion(Parameter<Int16>, Parameter<RequestCompletion<[ProposedDateEntity]>>)
        case m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(Parameter<Int16>, Parameter<Int16>, Parameter<Int16>, Parameter<RequestCompletion<[ProposedDateEntity]>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchAppointmentDates__for_date_completion(let lhsDate, let lhsCompletion), .m_fetchAppointmentDates__for_date_completion(let rhsDate, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_getProposedDates__appointmentId_appointmentId_completion(let lhsAppointmentid, let lhsCompletion), .m_getProposedDates__appointmentId_appointmentId_completion(let rhsAppointmentid, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(let lhsAppointmentid, let lhsProposedateid, let lhsStatus, let lhsCompletion), .m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(let rhsAppointmentid, let rhsProposedateid, let rhsStatus, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsProposedateid, rhs: rhsProposedateid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsStatus, rhs: rhsStatus, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchAppointmentDates__for_date_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_getProposedDates__appointmentId_appointmentId_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(p0, p1, p2, p3): return p0.intValue + p1.intValue + p2.intValue + p3.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func fetchAppointmentDates(for date: Parameter<Int64?>, _ completion: Parameter<ArrayLocalCompletion<[AppointmentDateEntity?]>>) -> Verify { return Verify(method: .m_fetchAppointmentDates__for_date_completion(`date`, `completion`))}
        public static func getProposedDates(appointmentId: Parameter<Int16>, _ completion: Parameter<RequestCompletion<[ProposedDateEntity]>>) -> Verify { return Verify(method: .m_getProposedDates__appointmentId_appointmentId_completion(`appointmentId`, `completion`))}
        public static func respondToProposedDates(appointmentId: Parameter<Int16>, proposeDateId: Parameter<Int16>, status: Parameter<Int16>, _ completion: Parameter<RequestCompletion<[ProposedDateEntity]>>) -> Verify { return Verify(method: .m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(`appointmentId`, `proposeDateId`, `status`, `completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func fetchAppointmentDates(for date: Parameter<Int64?>, _ completion: Parameter<ArrayLocalCompletion<[AppointmentDateEntity?]>>, perform: @escaping (Int64?, @escaping ArrayLocalCompletion<[AppointmentDateEntity?]>) -> Void) -> Perform {
            return Perform(method: .m_fetchAppointmentDates__for_date_completion(`date`, `completion`), performs: perform)
        }
        public static func getProposedDates(appointmentId: Parameter<Int16>, _ completion: Parameter<RequestCompletion<[ProposedDateEntity]>>, perform: @escaping (Int16, @escaping RequestCompletion<[ProposedDateEntity]>) -> Void) -> Perform {
            return Perform(method: .m_getProposedDates__appointmentId_appointmentId_completion(`appointmentId`, `completion`), performs: perform)
        }
        public static func respondToProposedDates(appointmentId: Parameter<Int16>, proposeDateId: Parameter<Int16>, status: Parameter<Int16>, _ completion: Parameter<RequestCompletion<[ProposedDateEntity]>>, perform: @escaping (Int16, Int16, Int16, @escaping RequestCompletion<[ProposedDateEntity]>) -> Void) -> Perform {
            return Perform(method: .m_respondToProposedDates__appointmentId_appointmentIdproposeDateId_proposeDateIdstatus_status_completion(`appointmentId`, `proposeDateId`, `status`, `completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AppointmentServiceProtocol
open class AppointmentServiceProtocolMock: AppointmentServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func getAppointments(_ completion: @escaping RequestCompletion<[Appointment]>) {
        addInvocation(.m_getAppointments__completion(Parameter<RequestCompletion<[Appointment]>>.any))
		let perform = methodPerformValue(.m_getAppointments__completion(Parameter<RequestCompletion<[Appointment]>>.any)) as? (@escaping RequestCompletion<[Appointment]>) -> Void
		perform?(`completion`)
    }

    open func setCalendar(        for appointmentId: Int,        with status: UserResponseType,        _ completion: @escaping RequestCompletion<Void>    ) {
        addInvocation(.m_setCalendar__for_appointmentIdwith_status_completion(Parameter<Int>.value(`appointmentId`), Parameter<UserResponseType>.value(`status`), Parameter<RequestCompletion<Void>>.any))
		let perform = methodPerformValue(.m_setCalendar__for_appointmentIdwith_status_completion(Parameter<Int>.value(`appointmentId`), Parameter<UserResponseType>.value(`status`), Parameter<RequestCompletion<Void>>.any)) as? (Int, UserResponseType, @escaping RequestCompletion<Void>) -> Void
		perform?(`appointmentId`, `status`, `completion`)
    }


    fileprivate enum MethodType {
        case m_getAppointments__completion(Parameter<RequestCompletion<[Appointment]>>)
        case m_setCalendar__for_appointmentIdwith_status_completion(Parameter<Int>, Parameter<UserResponseType>, Parameter<RequestCompletion<Void>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_getAppointments__completion(let lhsCompletion), .m_getAppointments__completion(let rhsCompletion)):
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_setCalendar__for_appointmentIdwith_status_completion(let lhsAppointmentid, let lhsStatus, let lhsCompletion), .m_setCalendar__for_appointmentIdwith_status_completion(let rhsAppointmentid, let rhsStatus, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsStatus, rhs: rhsStatus, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_getAppointments__completion(p0): return p0.intValue
            case let .m_setCalendar__for_appointmentIdwith_status_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func getAppointments(_ completion: Parameter<RequestCompletion<[Appointment]>>) -> Verify { return Verify(method: .m_getAppointments__completion(`completion`))}
        public static func setCalendar(for appointmentId: Parameter<Int>, with status: Parameter<UserResponseType>, _ completion: Parameter<RequestCompletion<Void>>) -> Verify { return Verify(method: .m_setCalendar__for_appointmentIdwith_status_completion(`appointmentId`, `status`, `completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func getAppointments(_ completion: Parameter<RequestCompletion<[Appointment]>>, perform: @escaping (@escaping RequestCompletion<[Appointment]>) -> Void) -> Perform {
            return Perform(method: .m_getAppointments__completion(`completion`), performs: perform)
        }
        public static func setCalendar(for appointmentId: Parameter<Int>, with status: Parameter<UserResponseType>, _ completion: Parameter<RequestCompletion<Void>>, perform: @escaping (Int, UserResponseType, @escaping RequestCompletion<Void>) -> Void) -> Perform {
            return Perform(method: .m_setCalendar__for_appointmentIdwith_status_completion(`appointmentId`, `status`, `completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AuthManagerProtocol
open class AuthManagerProtocolMock: AuthManagerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }

    public var isUserLoggedIn: Bool {
		get {	invocations.append(.p_isUserLoggedIn_get); return __p_isUserLoggedIn ?? givenGetterValue(.p_isUserLoggedIn_get, "AuthManagerProtocolMock - stub value for isUserLoggedIn was not defined") }
		@available(*, deprecated, message: "Using setters on readonly variables is deprecated, and will be removed in 3.1. Use Given to define stubbed property return value.")
		set {	__p_isUserLoggedIn = newValue }
	}
	private var __p_isUserLoggedIn: (Bool)?





    open func login(email: String, password: String, completion: @escaping ((AuthResult<LoginResponse>) -> Void)) {
        addInvocation(.m_login__email_emailpassword_passwordcompletion_completion(Parameter<String>.value(`email`), Parameter<String>.value(`password`), Parameter<(AuthResult<LoginResponse>) -> Void>.value(`completion`)))
		let perform = methodPerformValue(.m_login__email_emailpassword_passwordcompletion_completion(Parameter<String>.value(`email`), Parameter<String>.value(`password`), Parameter<(AuthResult<LoginResponse>) -> Void>.value(`completion`))) as? (String, String, @escaping ((AuthResult<LoginResponse>) -> Void)) -> Void
		perform?(`email`, `password`, `completion`)
    }

    open func sign(_ request: URLRequest, result: @escaping ((Result<URLRequest, MoyaError>) -> Void)) {
        addInvocation(.m_sign__requestresult_result(Parameter<URLRequest>.value(`request`), Parameter<(Result<URLRequest, MoyaError>) -> Void>.value(`result`)))
		let perform = methodPerformValue(.m_sign__requestresult_result(Parameter<URLRequest>.value(`request`), Parameter<(Result<URLRequest, MoyaError>) -> Void>.value(`result`))) as? (URLRequest, @escaping ((Result<URLRequest, MoyaError>) -> Void)) -> Void
		perform?(`request`, `result`)
    }

    open func logout() {
        addInvocation(.m_logout)
		let perform = methodPerformValue(.m_logout) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_login__email_emailpassword_passwordcompletion_completion(Parameter<String>, Parameter<String>, Parameter<(AuthResult<LoginResponse>) -> Void>)
        case m_sign__requestresult_result(Parameter<URLRequest>, Parameter<(Result<URLRequest, MoyaError>) -> Void>)
        case m_logout
        case p_isUserLoggedIn_get

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_login__email_emailpassword_passwordcompletion_completion(let lhsEmail, let lhsPassword, let lhsCompletion), .m_login__email_emailpassword_passwordcompletion_completion(let rhsEmail, let rhsPassword, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsEmail, rhs: rhsEmail, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsPassword, rhs: rhsPassword, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_sign__requestresult_result(let lhsRequest, let lhsResult), .m_sign__requestresult_result(let rhsRequest, let rhsResult)):
                guard Parameter.compare(lhs: lhsRequest, rhs: rhsRequest, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsResult, rhs: rhsResult, with: matcher) else { return false } 
                return true 
            case (.m_logout, .m_logout):
                return true 
            case (.p_isUserLoggedIn_get,.p_isUserLoggedIn_get): return true
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_login__email_emailpassword_passwordcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_sign__requestresult_result(p0, p1): return p0.intValue + p1.intValue
            case .m_logout: return 0
            case .p_isUserLoggedIn_get: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }

        public static func isUserLoggedIn(getter defaultValue: Bool...) -> PropertyStub {
            return Given(method: .p_isUserLoggedIn_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }

    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func login(email: Parameter<String>, password: Parameter<String>, completion: Parameter<(AuthResult<LoginResponse>) -> Void>) -> Verify { return Verify(method: .m_login__email_emailpassword_passwordcompletion_completion(`email`, `password`, `completion`))}
        public static func sign(_ request: Parameter<URLRequest>, result: Parameter<(Result<URLRequest, MoyaError>) -> Void>) -> Verify { return Verify(method: .m_sign__requestresult_result(`request`, `result`))}
        public static func logout() -> Verify { return Verify(method: .m_logout)}
        public static var isUserLoggedIn: Verify { return Verify(method: .p_isUserLoggedIn_get) }
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func login(email: Parameter<String>, password: Parameter<String>, completion: Parameter<(AuthResult<LoginResponse>) -> Void>, perform: @escaping (String, String, @escaping ((AuthResult<LoginResponse>) -> Void)) -> Void) -> Perform {
            return Perform(method: .m_login__email_emailpassword_passwordcompletion_completion(`email`, `password`, `completion`), performs: perform)
        }
        public static func sign(_ request: Parameter<URLRequest>, result: Parameter<(Result<URLRequest, MoyaError>) -> Void>, perform: @escaping (URLRequest, @escaping ((Result<URLRequest, MoyaError>) -> Void)) -> Void) -> Perform {
            return Perform(method: .m_sign__requestresult_result(`request`, `result`), performs: perform)
        }
        public static func logout(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_logout, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AvailabilityOverviewInteractorProtocol
open class AvailabilityOverviewInteractorProtocolMock: AvailabilityOverviewInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func handleSetAvailability(appointmentId: Int,                               dateId: Int,                               comment: String,                               availability: String) {
        addInvocation(.m_handleSetAvailability__appointmentId_appointmentIddateId_dateIdcomment_commentavailability_availability(Parameter<Int>.value(`appointmentId`), Parameter<Int>.value(`dateId`), Parameter<String>.value(`comment`), Parameter<String>.value(`availability`)))
		let perform = methodPerformValue(.m_handleSetAvailability__appointmentId_appointmentIddateId_dateIdcomment_commentavailability_availability(Parameter<Int>.value(`appointmentId`), Parameter<Int>.value(`dateId`), Parameter<String>.value(`comment`), Parameter<String>.value(`availability`))) as? (Int, Int, String, String) -> Void
		perform?(`appointmentId`, `dateId`, `comment`, `availability`)
    }

    open func handleGetDateTime(date: AppointmentDate) {
        addInvocation(.m_handleGetDateTime__date_date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_handleGetDateTime__date_date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }


    fileprivate enum MethodType {
        case m_handleSetAvailability__appointmentId_appointmentIddateId_dateIdcomment_commentavailability_availability(Parameter<Int>, Parameter<Int>, Parameter<String>, Parameter<String>)
        case m_handleGetDateTime__date_date(Parameter<AppointmentDate>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_handleSetAvailability__appointmentId_appointmentIddateId_dateIdcomment_commentavailability_availability(let lhsAppointmentid, let lhsDateid, let lhsComment, let lhsAvailability), .m_handleSetAvailability__appointmentId_appointmentIddateId_dateIdcomment_commentavailability_availability(let rhsAppointmentid, let rhsDateid, let rhsComment, let rhsAvailability)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDateid, rhs: rhsDateid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsComment, rhs: rhsComment, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsAvailability, rhs: rhsAvailability, with: matcher) else { return false } 
                return true 
            case (.m_handleGetDateTime__date_date(let lhsDate), .m_handleGetDateTime__date_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_handleSetAvailability__appointmentId_appointmentIddateId_dateIdcomment_commentavailability_availability(p0, p1, p2, p3): return p0.intValue + p1.intValue + p2.intValue + p3.intValue
            case let .m_handleGetDateTime__date_date(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func handleSetAvailability(appointmentId: Parameter<Int>, dateId: Parameter<Int>, comment: Parameter<String>, availability: Parameter<String>) -> Verify { return Verify(method: .m_handleSetAvailability__appointmentId_appointmentIddateId_dateIdcomment_commentavailability_availability(`appointmentId`, `dateId`, `comment`, `availability`))}
        public static func handleGetDateTime(date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_handleGetDateTime__date_date(`date`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func handleSetAvailability(appointmentId: Parameter<Int>, dateId: Parameter<Int>, comment: Parameter<String>, availability: Parameter<String>, perform: @escaping (Int, Int, String, String) -> Void) -> Perform {
            return Perform(method: .m_handleSetAvailability__appointmentId_appointmentIddateId_dateIdcomment_commentavailability_availability(`appointmentId`, `dateId`, `comment`, `availability`), performs: perform)
        }
        public static func handleGetDateTime(date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_handleGetDateTime__date_date(`date`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AvailabilityOverviewPresenterProtocol
open class AvailabilityOverviewPresenterProtocolMock: AvailabilityOverviewPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: AvailabilityOverviewViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<AvailabilityOverviewViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<AvailabilityOverviewViewControllerProtocol?>.value(`viewController`))) as? (AvailabilityOverviewViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func presentSetAvailability() {
        addInvocation(.m_presentSetAvailability)
		let perform = methodPerformValue(.m_presentSetAvailability) as? () -> Void
		perform?()
    }

    open func presentGetDateTime(date: AppointmentDate) {
        addInvocation(.m_presentGetDateTime__date_date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_presentGetDateTime__date_date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<AvailabilityOverviewViewControllerProtocol?>)
        case m_presentSetAvailability
        case m_presentGetDateTime__date_date(Parameter<AppointmentDate>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_presentSetAvailability, .m_presentSetAvailability):
                return true 
            case (.m_presentGetDateTime__date_date(let lhsDate), .m_presentGetDateTime__date_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case .m_presentSetAvailability: return 0
            case let .m_presentGetDateTime__date_date(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<AvailabilityOverviewViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func presentSetAvailability() -> Verify { return Verify(method: .m_presentSetAvailability)}
        public static func presentGetDateTime(date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_presentGetDateTime__date_date(`date`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<AvailabilityOverviewViewControllerProtocol?>, perform: @escaping (AvailabilityOverviewViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func presentSetAvailability(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentSetAvailability, performs: perform)
        }
        public static func presentGetDateTime(date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_presentGetDateTime__date_date(`date`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AvailabilityOverviewRouterProtocol
open class AvailabilityOverviewRouterProtocolMock: AvailabilityOverviewRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: AvailabilityOverviewViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<AvailabilityOverviewViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<AvailabilityOverviewViewControllerProtocol?>.value(`viewController`))) as? (AvailabilityOverviewViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: AvailabilityOverviewRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<AvailabilityOverviewRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<AvailabilityOverviewRouter.Scene>.value(`scene`))) as? (AvailabilityOverviewRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<AvailabilityOverviewViewControllerProtocol?>)
        case m_route__to_scene(Parameter<AvailabilityOverviewRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<AvailabilityOverviewViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<AvailabilityOverviewRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<AvailabilityOverviewViewControllerProtocol?>, perform: @escaping (AvailabilityOverviewViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<AvailabilityOverviewRouter.Scene>, perform: @escaping (AvailabilityOverviewRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AvailabilityOverviewViewControllerProtocol
open class AvailabilityOverviewViewControllerProtocolMock: AvailabilityOverviewViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: AvailabilityOverviewInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<AvailabilityOverviewInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<AvailabilityOverviewInteractorProtocol>.value(`interactor`))) as? (AvailabilityOverviewInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: AvailabilityOverviewRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<AvailabilityOverviewRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<AvailabilityOverviewRouterProtocol>.value(`router`))) as? (AvailabilityOverviewRouterProtocol) -> Void
		perform?(`router`)
    }

    open func set(date: AppointmentDate) {
        addInvocation(.m_set__date_date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_set__date_date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }

    open func set(pageNumber: String) {
        addInvocation(.m_set__pageNumber_pageNumber(Parameter<String>.value(`pageNumber`)))
		let perform = methodPerformValue(.m_set__pageNumber_pageNumber(Parameter<String>.value(`pageNumber`))) as? (String) -> Void
		perform?(`pageNumber`)
    }

    open func displayAvailability() {
        addInvocation(.m_displayAvailability)
		let perform = methodPerformValue(.m_displayAvailability) as? () -> Void
		perform?()
    }

    open func displayDateTime(date: String, time: String) {
        addInvocation(.m_displayDateTime__date_datetime_time(Parameter<String>.value(`date`), Parameter<String>.value(`time`)))
		let perform = methodPerformValue(.m_displayDateTime__date_datetime_time(Parameter<String>.value(`date`), Parameter<String>.value(`time`))) as? (String, String) -> Void
		perform?(`date`, `time`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<AvailabilityOverviewInteractorProtocol>)
        case m_set__router_router(Parameter<AvailabilityOverviewRouterProtocol>)
        case m_set__date_date(Parameter<AppointmentDate>)
        case m_set__pageNumber_pageNumber(Parameter<String>)
        case m_displayAvailability
        case m_displayDateTime__date_datetime_time(Parameter<String>, Parameter<String>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_set__date_date(let lhsDate), .m_set__date_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_set__pageNumber_pageNumber(let lhsPagenumber), .m_set__pageNumber_pageNumber(let rhsPagenumber)):
                guard Parameter.compare(lhs: lhsPagenumber, rhs: rhsPagenumber, with: matcher) else { return false } 
                return true 
            case (.m_displayAvailability, .m_displayAvailability):
                return true 
            case (.m_displayDateTime__date_datetime_time(let lhsDate, let lhsTime), .m_displayDateTime__date_datetime_time(let rhsDate, let rhsTime)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsTime, rhs: rhsTime, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_set__date_date(p0): return p0.intValue
            case let .m_set__pageNumber_pageNumber(p0): return p0.intValue
            case .m_displayAvailability: return 0
            case let .m_displayDateTime__date_datetime_time(p0, p1): return p0.intValue + p1.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<AvailabilityOverviewInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<AvailabilityOverviewRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func set(date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_set__date_date(`date`))}
        public static func set(pageNumber: Parameter<String>) -> Verify { return Verify(method: .m_set__pageNumber_pageNumber(`pageNumber`))}
        public static func displayAvailability() -> Verify { return Verify(method: .m_displayAvailability)}
        public static func displayDateTime(date: Parameter<String>, time: Parameter<String>) -> Verify { return Verify(method: .m_displayDateTime__date_datetime_time(`date`, `time`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<AvailabilityOverviewInteractorProtocol>, perform: @escaping (AvailabilityOverviewInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<AvailabilityOverviewRouterProtocol>, perform: @escaping (AvailabilityOverviewRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func set(date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_set__date_date(`date`), performs: perform)
        }
        public static func set(pageNumber: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_set__pageNumber_pageNumber(`pageNumber`), performs: perform)
        }
        public static func displayAvailability(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_displayAvailability, performs: perform)
        }
        public static func displayDateTime(date: Parameter<String>, time: Parameter<String>, perform: @escaping (String, String) -> Void) -> Perform {
            return Perform(method: .m_displayDateTime__date_datetime_time(`date`, `time`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - CalendarBlocksModelProviderProtocol
open class CalendarBlocksModelProviderProtocolMock: CalendarBlocksModelProviderProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func model(from items: [CalendarItem], maxDisplayableTogether: Int) -> [Int: [CalendarItem?]] {
        addInvocation(.m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(Parameter<[CalendarItem]>.value(`items`), Parameter<Int>.value(`maxDisplayableTogether`)))
		let perform = methodPerformValue(.m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(Parameter<[CalendarItem]>.value(`items`), Parameter<Int>.value(`maxDisplayableTogether`))) as? ([CalendarItem], Int) -> Void
		perform?(`items`, `maxDisplayableTogether`)
		var __value: [Int: [CalendarItem?]]
		do {
		    __value = try methodReturnValue(.m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(Parameter<[CalendarItem]>.value(`items`), Parameter<Int>.value(`maxDisplayableTogether`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for model(from items: [CalendarItem], maxDisplayableTogether: Int). Use given")
			Failure("Stub return value not specified for model(from items: [CalendarItem], maxDisplayableTogether: Int). Use given")
		}
		return __value
    }


    fileprivate enum MethodType {
        case m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(Parameter<[CalendarItem]>, Parameter<Int>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(let lhsItems, let lhsMaxdisplayabletogether), .m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(let rhsItems, let rhsMaxdisplayabletogether)):
                guard Parameter.compare(lhs: lhsItems, rhs: rhsItems, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsMaxdisplayabletogether, rhs: rhsMaxdisplayabletogether, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(p0, p1): return p0.intValue + p1.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


        public static func model(from items: Parameter<[CalendarItem]>, maxDisplayableTogether: Parameter<Int>, willReturn: [Int: [CalendarItem?]]...) -> MethodStub {
            return Given(method: .m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(`items`, `maxDisplayableTogether`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func model(from items: Parameter<[CalendarItem]>, maxDisplayableTogether: Parameter<Int>, willProduce: (Stubber<[Int: [CalendarItem?]]>) -> Void) -> MethodStub {
            let willReturn: [[Int: [CalendarItem?]]] = []
			let given: Given = { return Given(method: .m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(`items`, `maxDisplayableTogether`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: ([Int: [CalendarItem?]]).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func model(from items: Parameter<[CalendarItem]>, maxDisplayableTogether: Parameter<Int>) -> Verify { return Verify(method: .m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(`items`, `maxDisplayableTogether`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func model(from items: Parameter<[CalendarItem]>, maxDisplayableTogether: Parameter<Int>, perform: @escaping ([CalendarItem], Int) -> Void) -> Perform {
            return Perform(method: .m_model__from_itemsmaxDisplayableTogether_maxDisplayableTogether(`items`, `maxDisplayableTogether`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - CalendarProtocol
open class CalendarProtocolMock: CalendarProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func dateComponents(_ components: Set<Calendar.Component>, from date: Date) -> DateComponents {
        addInvocation(.m_dateComponents__componentsfrom_date(Parameter<Set<Calendar.Component>>.value(`components`), Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_dateComponents__componentsfrom_date(Parameter<Set<Calendar.Component>>.value(`components`), Parameter<Date>.value(`date`))) as? (Set<Calendar.Component>, Date) -> Void
		perform?(`components`, `date`)
		var __value: DateComponents
		do {
		    __value = try methodReturnValue(.m_dateComponents__componentsfrom_date(Parameter<Set<Calendar.Component>>.value(`components`), Parameter<Date>.value(`date`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for dateComponents(_ components: Set<Calendar.Component>, from date: Date). Use given")
			Failure("Stub return value not specified for dateComponents(_ components: Set<Calendar.Component>, from date: Date). Use given")
		}
		return __value
    }

    open func component(_ component: Calendar.Component, from date: Date) -> Int {
        addInvocation(.m_component__componentfrom_date(Parameter<Calendar.Component>.value(`component`), Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_component__componentfrom_date(Parameter<Calendar.Component>.value(`component`), Parameter<Date>.value(`date`))) as? (Calendar.Component, Date) -> Void
		perform?(`component`, `date`)
		var __value: Int
		do {
		    __value = try methodReturnValue(.m_component__componentfrom_date(Parameter<Calendar.Component>.value(`component`), Parameter<Date>.value(`date`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for component(_ component: Calendar.Component, from date: Date). Use given")
			Failure("Stub return value not specified for component(_ component: Calendar.Component, from date: Date). Use given")
		}
		return __value
    }

    open func compare(_ date1: Date, to date2: Date, toGranularity component: Calendar.Component) -> ComparisonResult {
        addInvocation(.m_compare__date1to_date2toGranularity_component(Parameter<Date>.value(`date1`), Parameter<Date>.value(`date2`), Parameter<Calendar.Component>.value(`component`)))
		let perform = methodPerformValue(.m_compare__date1to_date2toGranularity_component(Parameter<Date>.value(`date1`), Parameter<Date>.value(`date2`), Parameter<Calendar.Component>.value(`component`))) as? (Date, Date, Calendar.Component) -> Void
		perform?(`date1`, `date2`, `component`)
		var __value: ComparisonResult
		do {
		    __value = try methodReturnValue(.m_compare__date1to_date2toGranularity_component(Parameter<Date>.value(`date1`), Parameter<Date>.value(`date2`), Parameter<Calendar.Component>.value(`component`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for compare(_ date1: Date, to date2: Date, toGranularity component: Calendar.Component). Use given")
			Failure("Stub return value not specified for compare(_ date1: Date, to date2: Date, toGranularity component: Calendar.Component). Use given")
		}
		return __value
    }

    open func startOfDay(for date: Date) -> Date {
        addInvocation(.m_startOfDay__for_date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_startOfDay__for_date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
		var __value: Date
		do {
		    __value = try methodReturnValue(.m_startOfDay__for_date(Parameter<Date>.value(`date`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for startOfDay(for date: Date). Use given")
			Failure("Stub return value not specified for startOfDay(for date: Date). Use given")
		}
		return __value
    }

    open func isDateInToday(_ date: Date) -> Bool {
        addInvocation(.m_isDateInToday__date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_isDateInToday__date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
		var __value: Bool
		do {
		    __value = try methodReturnValue(.m_isDateInToday__date(Parameter<Date>.value(`date`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for isDateInToday(_ date: Date). Use given")
			Failure("Stub return value not specified for isDateInToday(_ date: Date). Use given")
		}
		return __value
    }

    open func date(bySettingHour hour: Int, minute: Int, second: Int, of date: Date, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy, direction: Calendar.SearchDirection) -> Date? {
        addInvocation(.m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(Parameter<Int>.value(`hour`), Parameter<Int>.value(`minute`), Parameter<Int>.value(`second`), Parameter<Date>.value(`date`), Parameter<Calendar.MatchingPolicy>.value(`matchingPolicy`), Parameter<Calendar.RepeatedTimePolicy>.value(`repeatedTimePolicy`), Parameter<Calendar.SearchDirection>.value(`direction`)))
		let perform = methodPerformValue(.m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(Parameter<Int>.value(`hour`), Parameter<Int>.value(`minute`), Parameter<Int>.value(`second`), Parameter<Date>.value(`date`), Parameter<Calendar.MatchingPolicy>.value(`matchingPolicy`), Parameter<Calendar.RepeatedTimePolicy>.value(`repeatedTimePolicy`), Parameter<Calendar.SearchDirection>.value(`direction`))) as? (Int, Int, Int, Date, Calendar.MatchingPolicy, Calendar.RepeatedTimePolicy, Calendar.SearchDirection) -> Void
		perform?(`hour`, `minute`, `second`, `date`, `matchingPolicy`, `repeatedTimePolicy`, `direction`)
		var __value: Date? = nil
		do {
		    __value = try methodReturnValue(.m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(Parameter<Int>.value(`hour`), Parameter<Int>.value(`minute`), Parameter<Int>.value(`second`), Parameter<Date>.value(`date`), Parameter<Calendar.MatchingPolicy>.value(`matchingPolicy`), Parameter<Calendar.RepeatedTimePolicy>.value(`repeatedTimePolicy`), Parameter<Calendar.SearchDirection>.value(`direction`))).casted()
		} catch {
			// do nothing
		}
		return __value
    }


    fileprivate enum MethodType {
        case m_dateComponents__componentsfrom_date(Parameter<Set<Calendar.Component>>, Parameter<Date>)
        case m_component__componentfrom_date(Parameter<Calendar.Component>, Parameter<Date>)
        case m_compare__date1to_date2toGranularity_component(Parameter<Date>, Parameter<Date>, Parameter<Calendar.Component>)
        case m_startOfDay__for_date(Parameter<Date>)
        case m_isDateInToday__date(Parameter<Date>)
        case m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(Parameter<Int>, Parameter<Int>, Parameter<Int>, Parameter<Date>, Parameter<Calendar.MatchingPolicy>, Parameter<Calendar.RepeatedTimePolicy>, Parameter<Calendar.SearchDirection>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_dateComponents__componentsfrom_date(let lhsComponents, let lhsDate), .m_dateComponents__componentsfrom_date(let rhsComponents, let rhsDate)):
                guard Parameter.compare(lhs: lhsComponents, rhs: rhsComponents, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_component__componentfrom_date(let lhsComponent, let lhsDate), .m_component__componentfrom_date(let rhsComponent, let rhsDate)):
                guard Parameter.compare(lhs: lhsComponent, rhs: rhsComponent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_compare__date1to_date2toGranularity_component(let lhsDate1, let lhsDate2, let lhsComponent), .m_compare__date1to_date2toGranularity_component(let rhsDate1, let rhsDate2, let rhsComponent)):
                guard Parameter.compare(lhs: lhsDate1, rhs: rhsDate1, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDate2, rhs: rhsDate2, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsComponent, rhs: rhsComponent, with: matcher) else { return false } 
                return true 
            case (.m_startOfDay__for_date(let lhsDate), .m_startOfDay__for_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_isDateInToday__date(let lhsDate), .m_isDateInToday__date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(let lhsHour, let lhsMinute, let lhsSecond, let lhsDate, let lhsMatchingpolicy, let lhsRepeatedtimepolicy, let lhsDirection), .m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(let rhsHour, let rhsMinute, let rhsSecond, let rhsDate, let rhsMatchingpolicy, let rhsRepeatedtimepolicy, let rhsDirection)):
                guard Parameter.compare(lhs: lhsHour, rhs: rhsHour, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsMinute, rhs: rhsMinute, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSecond, rhs: rhsSecond, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsMatchingpolicy, rhs: rhsMatchingpolicy, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsRepeatedtimepolicy, rhs: rhsRepeatedtimepolicy, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDirection, rhs: rhsDirection, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_dateComponents__componentsfrom_date(p0, p1): return p0.intValue + p1.intValue
            case let .m_component__componentfrom_date(p0, p1): return p0.intValue + p1.intValue
            case let .m_compare__date1to_date2toGranularity_component(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_startOfDay__for_date(p0): return p0.intValue
            case let .m_isDateInToday__date(p0): return p0.intValue
            case let .m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(p0, p1, p2, p3, p4, p5, p6): return p0.intValue + p1.intValue + p2.intValue + p3.intValue + p4.intValue + p5.intValue + p6.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


        public static func dateComponents(_ components: Parameter<Set<Calendar.Component>>, from date: Parameter<Date>, willReturn: DateComponents...) -> MethodStub {
            return Given(method: .m_dateComponents__componentsfrom_date(`components`, `date`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func component(_ component: Parameter<Calendar.Component>, from date: Parameter<Date>, willReturn: Int...) -> MethodStub {
            return Given(method: .m_component__componentfrom_date(`component`, `date`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func compare(_ date1: Parameter<Date>, to date2: Parameter<Date>, toGranularity component: Parameter<Calendar.Component>, willReturn: ComparisonResult...) -> MethodStub {
            return Given(method: .m_compare__date1to_date2toGranularity_component(`date1`, `date2`, `component`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func startOfDay(for date: Parameter<Date>, willReturn: Date...) -> MethodStub {
            return Given(method: .m_startOfDay__for_date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func isDateInToday(_ date: Parameter<Date>, willReturn: Bool...) -> MethodStub {
            return Given(method: .m_isDateInToday__date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func date(bySettingHour hour: Parameter<Int>, minute: Parameter<Int>, second: Parameter<Int>, of date: Parameter<Date>, matchingPolicy: Parameter<Calendar.MatchingPolicy>, repeatedTimePolicy: Parameter<Calendar.RepeatedTimePolicy>, direction: Parameter<Calendar.SearchDirection>, willReturn: Date?...) -> MethodStub {
            return Given(method: .m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(`hour`, `minute`, `second`, `date`, `matchingPolicy`, `repeatedTimePolicy`, `direction`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func dateComponents(_ components: Parameter<Set<Calendar.Component>>, from date: Parameter<Date>, willProduce: (Stubber<DateComponents>) -> Void) -> MethodStub {
            let willReturn: [DateComponents] = []
			let given: Given = { return Given(method: .m_dateComponents__componentsfrom_date(`components`, `date`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (DateComponents).self)
			willProduce(stubber)
			return given
        }
        public static func component(_ component: Parameter<Calendar.Component>, from date: Parameter<Date>, willProduce: (Stubber<Int>) -> Void) -> MethodStub {
            let willReturn: [Int] = []
			let given: Given = { return Given(method: .m_component__componentfrom_date(`component`, `date`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Int).self)
			willProduce(stubber)
			return given
        }
        public static func compare(_ date1: Parameter<Date>, to date2: Parameter<Date>, toGranularity component: Parameter<Calendar.Component>, willProduce: (Stubber<ComparisonResult>) -> Void) -> MethodStub {
            let willReturn: [ComparisonResult] = []
			let given: Given = { return Given(method: .m_compare__date1to_date2toGranularity_component(`date1`, `date2`, `component`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (ComparisonResult).self)
			willProduce(stubber)
			return given
        }
        public static func startOfDay(for date: Parameter<Date>, willProduce: (Stubber<Date>) -> Void) -> MethodStub {
            let willReturn: [Date] = []
			let given: Given = { return Given(method: .m_startOfDay__for_date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Date).self)
			willProduce(stubber)
			return given
        }
        public static func isDateInToday(_ date: Parameter<Date>, willProduce: (Stubber<Bool>) -> Void) -> MethodStub {
            let willReturn: [Bool] = []
			let given: Given = { return Given(method: .m_isDateInToday__date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Bool).self)
			willProduce(stubber)
			return given
        }
        public static func date(bySettingHour hour: Parameter<Int>, minute: Parameter<Int>, second: Parameter<Int>, of date: Parameter<Date>, matchingPolicy: Parameter<Calendar.MatchingPolicy>, repeatedTimePolicy: Parameter<Calendar.RepeatedTimePolicy>, direction: Parameter<Calendar.SearchDirection>, willProduce: (Stubber<Date?>) -> Void) -> MethodStub {
            let willReturn: [Date?] = []
			let given: Given = { return Given(method: .m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(`hour`, `minute`, `second`, `date`, `matchingPolicy`, `repeatedTimePolicy`, `direction`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Date?).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func dateComponents(_ components: Parameter<Set<Calendar.Component>>, from date: Parameter<Date>) -> Verify { return Verify(method: .m_dateComponents__componentsfrom_date(`components`, `date`))}
        public static func component(_ component: Parameter<Calendar.Component>, from date: Parameter<Date>) -> Verify { return Verify(method: .m_component__componentfrom_date(`component`, `date`))}
        public static func compare(_ date1: Parameter<Date>, to date2: Parameter<Date>, toGranularity component: Parameter<Calendar.Component>) -> Verify { return Verify(method: .m_compare__date1to_date2toGranularity_component(`date1`, `date2`, `component`))}
        public static func startOfDay(for date: Parameter<Date>) -> Verify { return Verify(method: .m_startOfDay__for_date(`date`))}
        public static func isDateInToday(_ date: Parameter<Date>) -> Verify { return Verify(method: .m_isDateInToday__date(`date`))}
        public static func date(bySettingHour hour: Parameter<Int>, minute: Parameter<Int>, second: Parameter<Int>, of date: Parameter<Date>, matchingPolicy: Parameter<Calendar.MatchingPolicy>, repeatedTimePolicy: Parameter<Calendar.RepeatedTimePolicy>, direction: Parameter<Calendar.SearchDirection>) -> Verify { return Verify(method: .m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(`hour`, `minute`, `second`, `date`, `matchingPolicy`, `repeatedTimePolicy`, `direction`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func dateComponents(_ components: Parameter<Set<Calendar.Component>>, from date: Parameter<Date>, perform: @escaping (Set<Calendar.Component>, Date) -> Void) -> Perform {
            return Perform(method: .m_dateComponents__componentsfrom_date(`components`, `date`), performs: perform)
        }
        public static func component(_ component: Parameter<Calendar.Component>, from date: Parameter<Date>, perform: @escaping (Calendar.Component, Date) -> Void) -> Perform {
            return Perform(method: .m_component__componentfrom_date(`component`, `date`), performs: perform)
        }
        public static func compare(_ date1: Parameter<Date>, to date2: Parameter<Date>, toGranularity component: Parameter<Calendar.Component>, perform: @escaping (Date, Date, Calendar.Component) -> Void) -> Perform {
            return Perform(method: .m_compare__date1to_date2toGranularity_component(`date1`, `date2`, `component`), performs: perform)
        }
        public static func startOfDay(for date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_startOfDay__for_date(`date`), performs: perform)
        }
        public static func isDateInToday(_ date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_isDateInToday__date(`date`), performs: perform)
        }
        public static func date(bySettingHour hour: Parameter<Int>, minute: Parameter<Int>, second: Parameter<Int>, of date: Parameter<Date>, matchingPolicy: Parameter<Calendar.MatchingPolicy>, repeatedTimePolicy: Parameter<Calendar.RepeatedTimePolicy>, direction: Parameter<Calendar.SearchDirection>, perform: @escaping (Int, Int, Int, Date, Calendar.MatchingPolicy, Calendar.RepeatedTimePolicy, Calendar.SearchDirection) -> Void) -> Perform {
            return Perform(method: .m_date__bySettingHour_hourminute_minutesecond_secondof_datematchingPolicy_matchingPolicyrepeatedTimePolicy_repeatedTimePolicydirection_direction(`hour`, `minute`, `second`, `date`, `matchingPolicy`, `repeatedTimePolicy`, `direction`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ChatRouterProtocol
open class ChatRouterProtocolMock: ChatRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: ChatViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<ChatViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<ChatViewControllerProtocol?>.value(`viewController`))) as? (ChatViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: ChatRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<ChatRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<ChatRouter.Scene>.value(`scene`))) as? (ChatRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<ChatViewControllerProtocol?>)
        case m_route__to_scene(Parameter<ChatRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<ChatViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<ChatRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<ChatViewControllerProtocol?>, perform: @escaping (ChatViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<ChatRouter.Scene>, perform: @escaping (ChatRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - CurrentUserDataServiceProtocol
open class CurrentUserDataServiceProtocolMock: CurrentUserDataServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func fetchCurrentUser(_ completion: @escaping RequestLocalCompletion<CurrentUserEntity>) {
        addInvocation(.m_fetchCurrentUser__completion(Parameter<RequestLocalCompletion<CurrentUserEntity>>.any))
		let perform = methodPerformValue(.m_fetchCurrentUser__completion(Parameter<RequestLocalCompletion<CurrentUserEntity>>.any)) as? (@escaping RequestLocalCompletion<CurrentUserEntity>) -> Void
		perform?(`completion`)
    }

    open func save(currentUser: UserProfile, _ completion: @escaping RequestLocalCompletion<CurrentUserEntity>) {
        addInvocation(.m_save__currentUser_currentUser_completion(Parameter<UserProfile>.value(`currentUser`), Parameter<RequestLocalCompletion<CurrentUserEntity>>.any))
		let perform = methodPerformValue(.m_save__currentUser_currentUser_completion(Parameter<UserProfile>.value(`currentUser`), Parameter<RequestLocalCompletion<CurrentUserEntity>>.any)) as? (UserProfile, @escaping RequestLocalCompletion<CurrentUserEntity>) -> Void
		perform?(`currentUser`, `completion`)
    }

    open func deleteUser() {
        addInvocation(.m_deleteUser)
		let perform = methodPerformValue(.m_deleteUser) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_fetchCurrentUser__completion(Parameter<RequestLocalCompletion<CurrentUserEntity>>)
        case m_save__currentUser_currentUser_completion(Parameter<UserProfile>, Parameter<RequestLocalCompletion<CurrentUserEntity>>)
        case m_deleteUser

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchCurrentUser__completion(let lhsCompletion), .m_fetchCurrentUser__completion(let rhsCompletion)):
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_save__currentUser_currentUser_completion(let lhsCurrentuser, let lhsCompletion), .m_save__currentUser_currentUser_completion(let rhsCurrentuser, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsCurrentuser, rhs: rhsCurrentuser, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_deleteUser, .m_deleteUser):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchCurrentUser__completion(p0): return p0.intValue
            case let .m_save__currentUser_currentUser_completion(p0, p1): return p0.intValue + p1.intValue
            case .m_deleteUser: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func fetchCurrentUser(_ completion: Parameter<RequestLocalCompletion<CurrentUserEntity>>) -> Verify { return Verify(method: .m_fetchCurrentUser__completion(`completion`))}
        public static func save(currentUser: Parameter<UserProfile>, _ completion: Parameter<RequestLocalCompletion<CurrentUserEntity>>) -> Verify { return Verify(method: .m_save__currentUser_currentUser_completion(`currentUser`, `completion`))}
        public static func deleteUser() -> Verify { return Verify(method: .m_deleteUser)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func fetchCurrentUser(_ completion: Parameter<RequestLocalCompletion<CurrentUserEntity>>, perform: @escaping (@escaping RequestLocalCompletion<CurrentUserEntity>) -> Void) -> Perform {
            return Perform(method: .m_fetchCurrentUser__completion(`completion`), performs: perform)
        }
        public static func save(currentUser: Parameter<UserProfile>, _ completion: Parameter<RequestLocalCompletion<CurrentUserEntity>>, perform: @escaping (UserProfile, @escaping RequestLocalCompletion<CurrentUserEntity>) -> Void) -> Perform {
            return Perform(method: .m_save__currentUser_currentUser_completion(`currentUser`, `completion`), performs: perform)
        }
        public static func deleteUser(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_deleteUser, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DataValidatorProtocol
open class DataValidatorProtocolMock: DataValidatorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func validateEmail(_ value: String?) throws {
        addInvocation(.m_validateEmail__value(Parameter<String?>.value(`value`)))
		let perform = methodPerformValue(.m_validateEmail__value(Parameter<String?>.value(`value`))) as? (String?) -> Void
		perform?(`value`)
		do {
		    _ = try methodReturnValue(.m_validateEmail__value(Parameter<String?>.value(`value`))).casted() as Void
		} catch MockError.notStubed {
			// do nothing
		} catch {
		    throw error
		}
    }

    open func validatePassword(_ value: String?) throws {
        addInvocation(.m_validatePassword__value(Parameter<String?>.value(`value`)))
		let perform = methodPerformValue(.m_validatePassword__value(Parameter<String?>.value(`value`))) as? (String?) -> Void
		perform?(`value`)
		do {
		    _ = try methodReturnValue(.m_validatePassword__value(Parameter<String?>.value(`value`))).casted() as Void
		} catch MockError.notStubed {
			// do nothing
		} catch {
		    throw error
		}
    }

    open func validatePasswordsMatch(_ password: String?, _ confirmPassword: String?) throws {
        addInvocation(.m_validatePasswordsMatch__password_confirmPassword(Parameter<String?>.value(`password`), Parameter<String?>.value(`confirmPassword`)))
		let perform = methodPerformValue(.m_validatePasswordsMatch__password_confirmPassword(Parameter<String?>.value(`password`), Parameter<String?>.value(`confirmPassword`))) as? (String?, String?) -> Void
		perform?(`password`, `confirmPassword`)
		do {
		    _ = try methodReturnValue(.m_validatePasswordsMatch__password_confirmPassword(Parameter<String?>.value(`password`), Parameter<String?>.value(`confirmPassword`))).casted() as Void
		} catch MockError.notStubed {
			// do nothing
		} catch {
		    throw error
		}
    }


    fileprivate enum MethodType {
        case m_validateEmail__value(Parameter<String?>)
        case m_validatePassword__value(Parameter<String?>)
        case m_validatePasswordsMatch__password_confirmPassword(Parameter<String?>, Parameter<String?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_validateEmail__value(let lhsValue), .m_validateEmail__value(let rhsValue)):
                guard Parameter.compare(lhs: lhsValue, rhs: rhsValue, with: matcher) else { return false } 
                return true 
            case (.m_validatePassword__value(let lhsValue), .m_validatePassword__value(let rhsValue)):
                guard Parameter.compare(lhs: lhsValue, rhs: rhsValue, with: matcher) else { return false } 
                return true 
            case (.m_validatePasswordsMatch__password_confirmPassword(let lhsPassword, let lhsConfirmpassword), .m_validatePasswordsMatch__password_confirmPassword(let rhsPassword, let rhsConfirmpassword)):
                guard Parameter.compare(lhs: lhsPassword, rhs: rhsPassword, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsConfirmpassword, rhs: rhsConfirmpassword, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_validateEmail__value(p0): return p0.intValue
            case let .m_validatePassword__value(p0): return p0.intValue
            case let .m_validatePasswordsMatch__password_confirmPassword(p0, p1): return p0.intValue + p1.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


        public static func validateEmail(_ value: Parameter<String?>, willThrow: Error...) -> MethodStub {
            return Given(method: .m_validateEmail__value(`value`), products: willThrow.map({ StubProduct.throw($0) }))
        }
        public static func validateEmail(_ value: Parameter<String?>, willProduce: (StubberThrows<Void>) -> Void) -> MethodStub {
            let willThrow: [Error] = []
			let given: Given = { return Given(method: .m_validateEmail__value(`value`), products: willThrow.map({ StubProduct.throw($0) })) }()
			let stubber = given.stubThrows(for: (Void).self)
			willProduce(stubber)
			return given
        }
        public static func validatePassword(_ value: Parameter<String?>, willThrow: Error...) -> MethodStub {
            return Given(method: .m_validatePassword__value(`value`), products: willThrow.map({ StubProduct.throw($0) }))
        }
        public static func validatePassword(_ value: Parameter<String?>, willProduce: (StubberThrows<Void>) -> Void) -> MethodStub {
            let willThrow: [Error] = []
			let given: Given = { return Given(method: .m_validatePassword__value(`value`), products: willThrow.map({ StubProduct.throw($0) })) }()
			let stubber = given.stubThrows(for: (Void).self)
			willProduce(stubber)
			return given
        }
        public static func validatePasswordsMatch(_ password: Parameter<String?>, _ confirmPassword: Parameter<String?>, willThrow: Error...) -> MethodStub {
            return Given(method: .m_validatePasswordsMatch__password_confirmPassword(`password`, `confirmPassword`), products: willThrow.map({ StubProduct.throw($0) }))
        }
        public static func validatePasswordsMatch(_ password: Parameter<String?>, _ confirmPassword: Parameter<String?>, willProduce: (StubberThrows<Void>) -> Void) -> MethodStub {
            let willThrow: [Error] = []
			let given: Given = { return Given(method: .m_validatePasswordsMatch__password_confirmPassword(`password`, `confirmPassword`), products: willThrow.map({ StubProduct.throw($0) })) }()
			let stubber = given.stubThrows(for: (Void).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func validateEmail(_ value: Parameter<String?>) -> Verify { return Verify(method: .m_validateEmail__value(`value`))}
        public static func validatePassword(_ value: Parameter<String?>) -> Verify { return Verify(method: .m_validatePassword__value(`value`))}
        public static func validatePasswordsMatch(_ password: Parameter<String?>, _ confirmPassword: Parameter<String?>) -> Verify { return Verify(method: .m_validatePasswordsMatch__password_confirmPassword(`password`, `confirmPassword`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func validateEmail(_ value: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_validateEmail__value(`value`), performs: perform)
        }
        public static func validatePassword(_ value: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_validatePassword__value(`value`), performs: perform)
        }
        public static func validatePasswordsMatch(_ password: Parameter<String?>, _ confirmPassword: Parameter<String?>, perform: @escaping (String?, String?) -> Void) -> Perform {
            return Perform(method: .m_validatePasswordsMatch__password_confirmPassword(`password`, `confirmPassword`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DatabaseSyncManagerProtocol
open class DatabaseSyncManagerProtocolMock: DatabaseSyncManagerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func syncDatabase() -> Single<Void> {
        addInvocation(.m_syncDatabase)
		let perform = methodPerformValue(.m_syncDatabase) as? () -> Void
		perform?()
		var __value: Single<Void>
		do {
		    __value = try methodReturnValue(.m_syncDatabase).casted()
		} catch {
			onFatalFailure("Stub return value not specified for syncDatabase(). Use given")
			Failure("Stub return value not specified for syncDatabase(). Use given")
		}
		return __value
    }

    open func syncUserProfile() -> Single<UserProfile> {
        addInvocation(.m_syncUserProfile)
		let perform = methodPerformValue(.m_syncUserProfile) as? () -> Void
		perform?()
		var __value: Single<UserProfile>
		do {
		    __value = try methodReturnValue(.m_syncUserProfile).casted()
		} catch {
			onFatalFailure("Stub return value not specified for syncUserProfile(). Use given")
			Failure("Stub return value not specified for syncUserProfile(). Use given")
		}
		return __value
    }


    fileprivate enum MethodType {
        case m_syncDatabase
        case m_syncUserProfile

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_syncDatabase, .m_syncDatabase):
                return true 
            case (.m_syncUserProfile, .m_syncUserProfile):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_syncDatabase: return 0
            case .m_syncUserProfile: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


        public static func syncDatabase(willReturn: Single<Void>...) -> MethodStub {
            return Given(method: .m_syncDatabase, products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func syncUserProfile(willReturn: Single<UserProfile>...) -> MethodStub {
            return Given(method: .m_syncUserProfile, products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func syncDatabase(willProduce: (Stubber<Single<Void>>) -> Void) -> MethodStub {
            let willReturn: [Single<Void>] = []
			let given: Given = { return Given(method: .m_syncDatabase, products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Single<Void>).self)
			willProduce(stubber)
			return given
        }
        public static func syncUserProfile(willProduce: (Stubber<Single<UserProfile>>) -> Void) -> MethodStub {
            let willReturn: [Single<UserProfile>] = []
			let given: Given = { return Given(method: .m_syncUserProfile, products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Single<UserProfile>).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func syncDatabase() -> Verify { return Verify(method: .m_syncDatabase)}
        public static func syncUserProfile() -> Verify { return Verify(method: .m_syncUserProfile)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func syncDatabase(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_syncDatabase, performs: perform)
        }
        public static func syncUserProfile(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_syncUserProfile, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DateFormatterProtocol
open class DateFormatterProtocolMock: DateFormatterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }

    public var dateFormat: String! {
		get {	invocations.append(.p_dateFormat_get); return __p_dateFormat ?? optionalGivenGetterValue(.p_dateFormat_get, "DateFormatterProtocolMock - stub value for dateFormat was not defined") }
		set {	invocations.append(.p_dateFormat_set(.value(newValue))); __p_dateFormat = newValue }
	}
	private var __p_dateFormat: (String)?

    public var timeStyle: DateFormatter.Style {
		get {	invocations.append(.p_timeStyle_get); return __p_timeStyle ?? givenGetterValue(.p_timeStyle_get, "DateFormatterProtocolMock - stub value for timeStyle was not defined") }
		set {	invocations.append(.p_timeStyle_set(.value(newValue))); __p_timeStyle = newValue }
	}
	private var __p_timeStyle: (DateFormatter.Style)?

    public var dateStyle: DateFormatter.Style {
		get {	invocations.append(.p_dateStyle_get); return __p_dateStyle ?? givenGetterValue(.p_dateStyle_get, "DateFormatterProtocolMock - stub value for dateStyle was not defined") }
		set {	invocations.append(.p_dateStyle_set(.value(newValue))); __p_dateStyle = newValue }
	}
	private var __p_dateStyle: (DateFormatter.Style)?

    public var locale: Locale! {
		get {	invocations.append(.p_locale_get); return __p_locale ?? optionalGivenGetterValue(.p_locale_get, "DateFormatterProtocolMock - stub value for locale was not defined") }
		set {	invocations.append(.p_locale_set(.value(newValue))); __p_locale = newValue }
	}
	private var __p_locale: (Locale)?

    public var doesRelativeDateFormatting: Bool {
		get {	invocations.append(.p_doesRelativeDateFormatting_get); return __p_doesRelativeDateFormatting ?? givenGetterValue(.p_doesRelativeDateFormatting_get, "DateFormatterProtocolMock - stub value for doesRelativeDateFormatting was not defined") }
		set {	invocations.append(.p_doesRelativeDateFormatting_set(.value(newValue))); __p_doesRelativeDateFormatting = newValue }
	}
	private var __p_doesRelativeDateFormatting: (Bool)?

    public var timeZone: TimeZone! {
		get {	invocations.append(.p_timeZone_get); return __p_timeZone ?? optionalGivenGetterValue(.p_timeZone_get, "DateFormatterProtocolMock - stub value for timeZone was not defined") }
		set {	invocations.append(.p_timeZone_set(.value(newValue))); __p_timeZone = newValue }
	}
	private var __p_timeZone: (TimeZone)?





    open func string(from date: Date) -> String {
        addInvocation(.m_string__from_date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_string__from_date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
		var __value: String
		do {
		    __value = try methodReturnValue(.m_string__from_date(Parameter<Date>.value(`date`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for string(from date: Date). Use given")
			Failure("Stub return value not specified for string(from date: Date). Use given")
		}
		return __value
    }

    open func date(from string: String) -> Date? {
        addInvocation(.m_date__from_string(Parameter<String>.value(`string`)))
		let perform = methodPerformValue(.m_date__from_string(Parameter<String>.value(`string`))) as? (String) -> Void
		perform?(`string`)
		var __value: Date? = nil
		do {
		    __value = try methodReturnValue(.m_date__from_string(Parameter<String>.value(`string`))).casted()
		} catch {
			// do nothing
		}
		return __value
    }

    open func createDate(date: Date, dateFormat: String) -> Date? {
        addInvocation(.m_createDate__date_datedateFormat_dateFormat(Parameter<Date>.value(`date`), Parameter<String>.value(`dateFormat`)))
		let perform = methodPerformValue(.m_createDate__date_datedateFormat_dateFormat(Parameter<Date>.value(`date`), Parameter<String>.value(`dateFormat`))) as? (Date, String) -> Void
		perform?(`date`, `dateFormat`)
		var __value: Date? = nil
		do {
		    __value = try methodReturnValue(.m_createDate__date_datedateFormat_dateFormat(Parameter<Date>.value(`date`), Parameter<String>.value(`dateFormat`))).casted()
		} catch {
			// do nothing
		}
		return __value
    }

    open func formatDate(date: Date, format: String ) -> String {
        addInvocation(.m_formatDate__date_dateformat_format(Parameter<Date>.value(`date`), Parameter<String>.value(`format`)))
		let perform = methodPerformValue(.m_formatDate__date_dateformat_format(Parameter<Date>.value(`date`), Parameter<String>.value(`format`))) as? (Date, String) -> Void
		perform?(`date`, `format`)
		var __value: String
		do {
		    __value = try methodReturnValue(.m_formatDate__date_dateformat_format(Parameter<Date>.value(`date`), Parameter<String>.value(`format`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for formatDate(date: Date, format: String ). Use given")
			Failure("Stub return value not specified for formatDate(date: Date, format: String ). Use given")
		}
		return __value
    }

    open func int64(from date: Date) -> Int64 {
        addInvocation(.m_int64__from_date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_int64__from_date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
		var __value: Int64
		do {
		    __value = try methodReturnValue(.m_int64__from_date(Parameter<Date>.value(`date`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for int64(from date: Date). Use given")
			Failure("Stub return value not specified for int64(from date: Date). Use given")
		}
		return __value
    }


    fileprivate enum MethodType {
        case m_string__from_date(Parameter<Date>)
        case m_date__from_string(Parameter<String>)
        case m_createDate__date_datedateFormat_dateFormat(Parameter<Date>, Parameter<String>)
        case m_formatDate__date_dateformat_format(Parameter<Date>, Parameter<String>)
        case m_int64__from_date(Parameter<Date>)
        case p_dateFormat_get
		case p_dateFormat_set(Parameter<String?>)
        case p_timeStyle_get
		case p_timeStyle_set(Parameter<DateFormatter.Style>)
        case p_dateStyle_get
		case p_dateStyle_set(Parameter<DateFormatter.Style>)
        case p_locale_get
		case p_locale_set(Parameter<Locale?>)
        case p_doesRelativeDateFormatting_get
		case p_doesRelativeDateFormatting_set(Parameter<Bool>)
        case p_timeZone_get
		case p_timeZone_set(Parameter<TimeZone?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_string__from_date(let lhsDate), .m_string__from_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_date__from_string(let lhsString), .m_date__from_string(let rhsString)):
                guard Parameter.compare(lhs: lhsString, rhs: rhsString, with: matcher) else { return false } 
                return true 
            case (.m_createDate__date_datedateFormat_dateFormat(let lhsDate, let lhsDateformat), .m_createDate__date_datedateFormat_dateFormat(let rhsDate, let rhsDateformat)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDateformat, rhs: rhsDateformat, with: matcher) else { return false } 
                return true 
            case (.m_formatDate__date_dateformat_format(let lhsDate, let lhsFormat), .m_formatDate__date_dateformat_format(let rhsDate, let rhsFormat)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFormat, rhs: rhsFormat, with: matcher) else { return false } 
                return true 
            case (.m_int64__from_date(let lhsDate), .m_int64__from_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.p_dateFormat_get,.p_dateFormat_get): return true
			case (.p_dateFormat_set(let left),.p_dateFormat_set(let right)): return Parameter<String?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_timeStyle_get,.p_timeStyle_get): return true
			case (.p_timeStyle_set(let left),.p_timeStyle_set(let right)): return Parameter<DateFormatter.Style>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_dateStyle_get,.p_dateStyle_get): return true
			case (.p_dateStyle_set(let left),.p_dateStyle_set(let right)): return Parameter<DateFormatter.Style>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_locale_get,.p_locale_get): return true
			case (.p_locale_set(let left),.p_locale_set(let right)): return Parameter<Locale?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_doesRelativeDateFormatting_get,.p_doesRelativeDateFormatting_get): return true
			case (.p_doesRelativeDateFormatting_set(let left),.p_doesRelativeDateFormatting_set(let right)): return Parameter<Bool>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_timeZone_get,.p_timeZone_get): return true
			case (.p_timeZone_set(let left),.p_timeZone_set(let right)): return Parameter<TimeZone?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_string__from_date(p0): return p0.intValue
            case let .m_date__from_string(p0): return p0.intValue
            case let .m_createDate__date_datedateFormat_dateFormat(p0, p1): return p0.intValue + p1.intValue
            case let .m_formatDate__date_dateformat_format(p0, p1): return p0.intValue + p1.intValue
            case let .m_int64__from_date(p0): return p0.intValue
            case .p_dateFormat_get: return 0
			case .p_dateFormat_set(let newValue): return newValue.intValue
            case .p_timeStyle_get: return 0
			case .p_timeStyle_set(let newValue): return newValue.intValue
            case .p_dateStyle_get: return 0
			case .p_dateStyle_set(let newValue): return newValue.intValue
            case .p_locale_get: return 0
			case .p_locale_set(let newValue): return newValue.intValue
            case .p_doesRelativeDateFormatting_get: return 0
			case .p_doesRelativeDateFormatting_set(let newValue): return newValue.intValue
            case .p_timeZone_get: return 0
			case .p_timeZone_set(let newValue): return newValue.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }

        public static func dateFormat(getter defaultValue: String?...) -> PropertyStub {
            return Given(method: .p_dateFormat_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }
        public static func timeStyle(getter defaultValue: DateFormatter.Style...) -> PropertyStub {
            return Given(method: .p_timeStyle_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }
        public static func dateStyle(getter defaultValue: DateFormatter.Style...) -> PropertyStub {
            return Given(method: .p_dateStyle_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }
        public static func locale(getter defaultValue: Locale?...) -> PropertyStub {
            return Given(method: .p_locale_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }
        public static func doesRelativeDateFormatting(getter defaultValue: Bool...) -> PropertyStub {
            return Given(method: .p_doesRelativeDateFormatting_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }
        public static func timeZone(getter defaultValue: TimeZone?...) -> PropertyStub {
            return Given(method: .p_timeZone_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }

        public static func string(from date: Parameter<Date>, willReturn: String...) -> MethodStub {
            return Given(method: .m_string__from_date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func date(from string: Parameter<String>, willReturn: Date?...) -> MethodStub {
            return Given(method: .m_date__from_string(`string`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func createDate(date: Parameter<Date>, dateFormat: Parameter<String>, willReturn: Date?...) -> MethodStub {
            return Given(method: .m_createDate__date_datedateFormat_dateFormat(`date`, `dateFormat`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func formatDate(date: Parameter<Date>, format: Parameter<String>, willReturn: String...) -> MethodStub {
            return Given(method: .m_formatDate__date_dateformat_format(`date`, `format`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func int64(from date: Parameter<Date>, willReturn: Int64...) -> MethodStub {
            return Given(method: .m_int64__from_date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func string(from date: Parameter<Date>, willProduce: (Stubber<String>) -> Void) -> MethodStub {
            let willReturn: [String] = []
			let given: Given = { return Given(method: .m_string__from_date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (String).self)
			willProduce(stubber)
			return given
        }
        public static func date(from string: Parameter<String>, willProduce: (Stubber<Date?>) -> Void) -> MethodStub {
            let willReturn: [Date?] = []
			let given: Given = { return Given(method: .m_date__from_string(`string`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Date?).self)
			willProduce(stubber)
			return given
        }
        public static func createDate(date: Parameter<Date>, dateFormat: Parameter<String>, willProduce: (Stubber<Date?>) -> Void) -> MethodStub {
            let willReturn: [Date?] = []
			let given: Given = { return Given(method: .m_createDate__date_datedateFormat_dateFormat(`date`, `dateFormat`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Date?).self)
			willProduce(stubber)
			return given
        }
        public static func formatDate(date: Parameter<Date>, format: Parameter<String>, willProduce: (Stubber<String>) -> Void) -> MethodStub {
            let willReturn: [String] = []
			let given: Given = { return Given(method: .m_formatDate__date_dateformat_format(`date`, `format`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (String).self)
			willProduce(stubber)
			return given
        }
        public static func int64(from date: Parameter<Date>, willProduce: (Stubber<Int64>) -> Void) -> MethodStub {
            let willReturn: [Int64] = []
			let given: Given = { return Given(method: .m_int64__from_date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Int64).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func string(from date: Parameter<Date>) -> Verify { return Verify(method: .m_string__from_date(`date`))}
        public static func date(from string: Parameter<String>) -> Verify { return Verify(method: .m_date__from_string(`string`))}
        public static func createDate(date: Parameter<Date>, dateFormat: Parameter<String>) -> Verify { return Verify(method: .m_createDate__date_datedateFormat_dateFormat(`date`, `dateFormat`))}
        public static func formatDate(date: Parameter<Date>, format: Parameter<String>) -> Verify { return Verify(method: .m_formatDate__date_dateformat_format(`date`, `format`))}
        public static func int64(from date: Parameter<Date>) -> Verify { return Verify(method: .m_int64__from_date(`date`))}
        public static var dateFormat: Verify { return Verify(method: .p_dateFormat_get) }
		public static func dateFormat(set newValue: Parameter<String?>) -> Verify { return Verify(method: .p_dateFormat_set(newValue)) }
        public static var timeStyle: Verify { return Verify(method: .p_timeStyle_get) }
		public static func timeStyle(set newValue: Parameter<DateFormatter.Style>) -> Verify { return Verify(method: .p_timeStyle_set(newValue)) }
        public static var dateStyle: Verify { return Verify(method: .p_dateStyle_get) }
		public static func dateStyle(set newValue: Parameter<DateFormatter.Style>) -> Verify { return Verify(method: .p_dateStyle_set(newValue)) }
        public static var locale: Verify { return Verify(method: .p_locale_get) }
		public static func locale(set newValue: Parameter<Locale?>) -> Verify { return Verify(method: .p_locale_set(newValue)) }
        public static var doesRelativeDateFormatting: Verify { return Verify(method: .p_doesRelativeDateFormatting_get) }
		public static func doesRelativeDateFormatting(set newValue: Parameter<Bool>) -> Verify { return Verify(method: .p_doesRelativeDateFormatting_set(newValue)) }
        public static var timeZone: Verify { return Verify(method: .p_timeZone_get) }
		public static func timeZone(set newValue: Parameter<TimeZone?>) -> Verify { return Verify(method: .p_timeZone_set(newValue)) }
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func string(from date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_string__from_date(`date`), performs: perform)
        }
        public static func date(from string: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_date__from_string(`string`), performs: perform)
        }
        public static func createDate(date: Parameter<Date>, dateFormat: Parameter<String>, perform: @escaping (Date, String) -> Void) -> Perform {
            return Perform(method: .m_createDate__date_datedateFormat_dateFormat(`date`, `dateFormat`), performs: perform)
        }
        public static func formatDate(date: Parameter<Date>, format: Parameter<String>, perform: @escaping (Date, String) -> Void) -> Perform {
            return Perform(method: .m_formatDate__date_dateformat_format(`date`, `format`), performs: perform)
        }
        public static func int64(from date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_int64__from_date(`date`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DateProviderProtocol
open class DateProviderProtocolMock: DateProviderProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func today() -> Date {
        addInvocation(.m_today)
		let perform = methodPerformValue(.m_today) as? () -> Void
		perform?()
		var __value: Date
		do {
		    __value = try methodReturnValue(.m_today).casted()
		} catch {
			onFatalFailure("Stub return value not specified for today(). Use given")
			Failure("Stub return value not specified for today(). Use given")
		}
		return __value
    }

    open func startOfDay(for date: Date) -> Date {
        addInvocation(.m_startOfDay__for_date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_startOfDay__for_date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
		var __value: Date
		do {
		    __value = try methodReturnValue(.m_startOfDay__for_date(Parameter<Date>.value(`date`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for startOfDay(for date: Date). Use given")
			Failure("Stub return value not specified for startOfDay(for date: Date). Use given")
		}
		return __value
    }

    open func startOfDay(from milliseconds: Int64) -> Date {
        addInvocation(.m_startOfDay__from_milliseconds(Parameter<Int64>.value(`milliseconds`)))
		let perform = methodPerformValue(.m_startOfDay__from_milliseconds(Parameter<Int64>.value(`milliseconds`))) as? (Int64) -> Void
		perform?(`milliseconds`)
		var __value: Date
		do {
		    __value = try methodReturnValue(.m_startOfDay__from_milliseconds(Parameter<Int64>.value(`milliseconds`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for startOfDay(from milliseconds: Int64). Use given")
			Failure("Stub return value not specified for startOfDay(from milliseconds: Int64). Use given")
		}
		return __value
    }

    open func isDateInToday(_ date: Date) -> Bool {
        addInvocation(.m_isDateInToday__date(Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_isDateInToday__date(Parameter<Date>.value(`date`))) as? (Date) -> Void
		perform?(`date`)
		var __value: Bool
		do {
		    __value = try methodReturnValue(.m_isDateInToday__date(Parameter<Date>.value(`date`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for isDateInToday(_ date: Date). Use given")
			Failure("Stub return value not specified for isDateInToday(_ date: Date). Use given")
		}
		return __value
    }

    open func date(from milliseconds: Int64) -> Date {
        addInvocation(.m_date__from_milliseconds(Parameter<Int64>.value(`milliseconds`)))
		let perform = methodPerformValue(.m_date__from_milliseconds(Parameter<Int64>.value(`milliseconds`))) as? (Int64) -> Void
		perform?(`milliseconds`)
		var __value: Date
		do {
		    __value = try methodReturnValue(.m_date__from_milliseconds(Parameter<Int64>.value(`milliseconds`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for date(from milliseconds: Int64). Use given")
			Failure("Stub return value not specified for date(from milliseconds: Int64). Use given")
		}
		return __value
    }

    open func date(bySettingHour hour: Int, minute: Int, of date: Date) -> Date {
        addInvocation(.m_date__bySettingHour_hourminute_minuteof_date(Parameter<Int>.value(`hour`), Parameter<Int>.value(`minute`), Parameter<Date>.value(`date`)))
		let perform = methodPerformValue(.m_date__bySettingHour_hourminute_minuteof_date(Parameter<Int>.value(`hour`), Parameter<Int>.value(`minute`), Parameter<Date>.value(`date`))) as? (Int, Int, Date) -> Void
		perform?(`hour`, `minute`, `date`)
		var __value: Date
		do {
		    __value = try methodReturnValue(.m_date__bySettingHour_hourminute_minuteof_date(Parameter<Int>.value(`hour`), Parameter<Int>.value(`minute`), Parameter<Date>.value(`date`))).casted()
		} catch {
			onFatalFailure("Stub return value not specified for date(bySettingHour hour: Int, minute: Int, of date: Date). Use given")
			Failure("Stub return value not specified for date(bySettingHour hour: Int, minute: Int, of date: Date). Use given")
		}
		return __value
    }


    fileprivate enum MethodType {
        case m_today
        case m_startOfDay__for_date(Parameter<Date>)
        case m_startOfDay__from_milliseconds(Parameter<Int64>)
        case m_isDateInToday__date(Parameter<Date>)
        case m_date__from_milliseconds(Parameter<Int64>)
        case m_date__bySettingHour_hourminute_minuteof_date(Parameter<Int>, Parameter<Int>, Parameter<Date>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_today, .m_today):
                return true 
            case (.m_startOfDay__for_date(let lhsDate), .m_startOfDay__for_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_startOfDay__from_milliseconds(let lhsMilliseconds), .m_startOfDay__from_milliseconds(let rhsMilliseconds)):
                guard Parameter.compare(lhs: lhsMilliseconds, rhs: rhsMilliseconds, with: matcher) else { return false } 
                return true 
            case (.m_isDateInToday__date(let lhsDate), .m_isDateInToday__date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_date__from_milliseconds(let lhsMilliseconds), .m_date__from_milliseconds(let rhsMilliseconds)):
                guard Parameter.compare(lhs: lhsMilliseconds, rhs: rhsMilliseconds, with: matcher) else { return false } 
                return true 
            case (.m_date__bySettingHour_hourminute_minuteof_date(let lhsHour, let lhsMinute, let lhsDate), .m_date__bySettingHour_hourminute_minuteof_date(let rhsHour, let rhsMinute, let rhsDate)):
                guard Parameter.compare(lhs: lhsHour, rhs: rhsHour, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsMinute, rhs: rhsMinute, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_today: return 0
            case let .m_startOfDay__for_date(p0): return p0.intValue
            case let .m_startOfDay__from_milliseconds(p0): return p0.intValue
            case let .m_isDateInToday__date(p0): return p0.intValue
            case let .m_date__from_milliseconds(p0): return p0.intValue
            case let .m_date__bySettingHour_hourminute_minuteof_date(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


        public static func today(willReturn: Date...) -> MethodStub {
            return Given(method: .m_today, products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func startOfDay(for date: Parameter<Date>, willReturn: Date...) -> MethodStub {
            return Given(method: .m_startOfDay__for_date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func startOfDay(from milliseconds: Parameter<Int64>, willReturn: Date...) -> MethodStub {
            return Given(method: .m_startOfDay__from_milliseconds(`milliseconds`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func isDateInToday(_ date: Parameter<Date>, willReturn: Bool...) -> MethodStub {
            return Given(method: .m_isDateInToday__date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func date(from milliseconds: Parameter<Int64>, willReturn: Date...) -> MethodStub {
            return Given(method: .m_date__from_milliseconds(`milliseconds`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func date(bySettingHour hour: Parameter<Int>, minute: Parameter<Int>, of date: Parameter<Date>, willReturn: Date...) -> MethodStub {
            return Given(method: .m_date__bySettingHour_hourminute_minuteof_date(`hour`, `minute`, `date`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func today(willProduce: (Stubber<Date>) -> Void) -> MethodStub {
            let willReturn: [Date] = []
			let given: Given = { return Given(method: .m_today, products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Date).self)
			willProduce(stubber)
			return given
        }
        public static func startOfDay(for date: Parameter<Date>, willProduce: (Stubber<Date>) -> Void) -> MethodStub {
            let willReturn: [Date] = []
			let given: Given = { return Given(method: .m_startOfDay__for_date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Date).self)
			willProduce(stubber)
			return given
        }
        public static func startOfDay(from milliseconds: Parameter<Int64>, willProduce: (Stubber<Date>) -> Void) -> MethodStub {
            let willReturn: [Date] = []
			let given: Given = { return Given(method: .m_startOfDay__from_milliseconds(`milliseconds`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Date).self)
			willProduce(stubber)
			return given
        }
        public static func isDateInToday(_ date: Parameter<Date>, willProduce: (Stubber<Bool>) -> Void) -> MethodStub {
            let willReturn: [Bool] = []
			let given: Given = { return Given(method: .m_isDateInToday__date(`date`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Bool).self)
			willProduce(stubber)
			return given
        }
        public static func date(from milliseconds: Parameter<Int64>, willProduce: (Stubber<Date>) -> Void) -> MethodStub {
            let willReturn: [Date] = []
			let given: Given = { return Given(method: .m_date__from_milliseconds(`milliseconds`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Date).self)
			willProduce(stubber)
			return given
        }
        public static func date(bySettingHour hour: Parameter<Int>, minute: Parameter<Int>, of date: Parameter<Date>, willProduce: (Stubber<Date>) -> Void) -> MethodStub {
            let willReturn: [Date] = []
			let given: Given = { return Given(method: .m_date__bySettingHour_hourminute_minuteof_date(`hour`, `minute`, `date`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (Date).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func today() -> Verify { return Verify(method: .m_today)}
        public static func startOfDay(for date: Parameter<Date>) -> Verify { return Verify(method: .m_startOfDay__for_date(`date`))}
        public static func startOfDay(from milliseconds: Parameter<Int64>) -> Verify { return Verify(method: .m_startOfDay__from_milliseconds(`milliseconds`))}
        public static func isDateInToday(_ date: Parameter<Date>) -> Verify { return Verify(method: .m_isDateInToday__date(`date`))}
        public static func date(from milliseconds: Parameter<Int64>) -> Verify { return Verify(method: .m_date__from_milliseconds(`milliseconds`))}
        public static func date(bySettingHour hour: Parameter<Int>, minute: Parameter<Int>, of date: Parameter<Date>) -> Verify { return Verify(method: .m_date__bySettingHour_hourminute_minuteof_date(`hour`, `minute`, `date`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func today(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_today, performs: perform)
        }
        public static func startOfDay(for date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_startOfDay__for_date(`date`), performs: perform)
        }
        public static func startOfDay(from milliseconds: Parameter<Int64>, perform: @escaping (Int64) -> Void) -> Perform {
            return Perform(method: .m_startOfDay__from_milliseconds(`milliseconds`), performs: perform)
        }
        public static func isDateInToday(_ date: Parameter<Date>, perform: @escaping (Date) -> Void) -> Perform {
            return Perform(method: .m_isDateInToday__date(`date`), performs: perform)
        }
        public static func date(from milliseconds: Parameter<Int64>, perform: @escaping (Int64) -> Void) -> Perform {
            return Perform(method: .m_date__from_milliseconds(`milliseconds`), performs: perform)
        }
        public static func date(bySettingHour hour: Parameter<Int>, minute: Parameter<Int>, of date: Parameter<Date>, perform: @escaping (Int, Int, Date) -> Void) -> Perform {
            return Perform(method: .m_date__bySettingHour_hourminute_minuteof_date(`hour`, `minute`, `date`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ErrorHandlerProtocol
open class ErrorHandlerProtocolMock: ErrorHandlerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func handle(_ error: Error) {
        addInvocation(.m_handle__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_handle__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_handle__error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_handle__error(let lhsError), .m_handle__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_handle__error(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func handle(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_handle__error(`error`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func handle(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_handle__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - EventsDataServiceProtocol
open class EventsDataServiceProtocolMock: EventsDataServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func sync(events: [AppEvent], _ completion: @escaping ArrayLocalCompletion<[EventEntity]>) {
        addInvocation(.m_sync__events_events_completion(Parameter<[AppEvent]>.value(`events`), Parameter<ArrayLocalCompletion<[EventEntity]>>.any))
		let perform = methodPerformValue(.m_sync__events_events_completion(Parameter<[AppEvent]>.value(`events`), Parameter<ArrayLocalCompletion<[EventEntity]>>.any)) as? ([AppEvent], @escaping ArrayLocalCompletion<[EventEntity]>) -> Void
		perform?(`events`, `completion`)
    }

    open func fetchEvents(appointmentId: Int?, _ completion: @escaping ArrayLocalCompletion<[EventEntity]>) {
        addInvocation(.m_fetchEvents__appointmentId_appointmentId_completion(Parameter<Int?>.value(`appointmentId`), Parameter<ArrayLocalCompletion<[EventEntity]>>.any))
		let perform = methodPerformValue(.m_fetchEvents__appointmentId_appointmentId_completion(Parameter<Int?>.value(`appointmentId`), Parameter<ArrayLocalCompletion<[EventEntity]>>.any)) as? (Int?, @escaping ArrayLocalCompletion<[EventEntity]>) -> Void
		perform?(`appointmentId`, `completion`)
    }

    open func resetEvents() {
        addInvocation(.m_resetEvents)
		let perform = methodPerformValue(.m_resetEvents) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_sync__events_events_completion(Parameter<[AppEvent]>, Parameter<ArrayLocalCompletion<[EventEntity]>>)
        case m_fetchEvents__appointmentId_appointmentId_completion(Parameter<Int?>, Parameter<ArrayLocalCompletion<[EventEntity]>>)
        case m_resetEvents

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_sync__events_events_completion(let lhsEvents, let lhsCompletion), .m_sync__events_events_completion(let rhsEvents, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsEvents, rhs: rhsEvents, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_fetchEvents__appointmentId_appointmentId_completion(let lhsAppointmentid, let lhsCompletion), .m_fetchEvents__appointmentId_appointmentId_completion(let rhsAppointmentid, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsAppointmentid, rhs: rhsAppointmentid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_resetEvents, .m_resetEvents):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_sync__events_events_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_fetchEvents__appointmentId_appointmentId_completion(p0, p1): return p0.intValue + p1.intValue
            case .m_resetEvents: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func sync(events: Parameter<[AppEvent]>, _ completion: Parameter<ArrayLocalCompletion<[EventEntity]>>) -> Verify { return Verify(method: .m_sync__events_events_completion(`events`, `completion`))}
        public static func fetchEvents(appointmentId: Parameter<Int?>, _ completion: Parameter<ArrayLocalCompletion<[EventEntity]>>) -> Verify { return Verify(method: .m_fetchEvents__appointmentId_appointmentId_completion(`appointmentId`, `completion`))}
        public static func resetEvents() -> Verify { return Verify(method: .m_resetEvents)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func sync(events: Parameter<[AppEvent]>, _ completion: Parameter<ArrayLocalCompletion<[EventEntity]>>, perform: @escaping ([AppEvent], @escaping ArrayLocalCompletion<[EventEntity]>) -> Void) -> Perform {
            return Perform(method: .m_sync__events_events_completion(`events`, `completion`), performs: perform)
        }
        public static func fetchEvents(appointmentId: Parameter<Int?>, _ completion: Parameter<ArrayLocalCompletion<[EventEntity]>>, perform: @escaping (Int?, @escaping ArrayLocalCompletion<[EventEntity]>) -> Void) -> Perform {
            return Perform(method: .m_fetchEvents__appointmentId_appointmentId_completion(`appointmentId`, `completion`), performs: perform)
        }
        public static func resetEvents(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_resetEvents, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - EventsServiceProtocol
open class EventsServiceProtocolMock: EventsServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func getEvents(_ completion: @escaping RequestCompletion<[AppEvent]>) {
        addInvocation(.m_getEvents__completion(Parameter<RequestCompletion<[AppEvent]>>.any))
		let perform = methodPerformValue(.m_getEvents__completion(Parameter<RequestCompletion<[AppEvent]>>.any)) as? (@escaping RequestCompletion<[AppEvent]>) -> Void
		perform?(`completion`)
    }


    fileprivate enum MethodType {
        case m_getEvents__completion(Parameter<RequestCompletion<[AppEvent]>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_getEvents__completion(let lhsCompletion), .m_getEvents__completion(let rhsCompletion)):
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_getEvents__completion(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func getEvents(_ completion: Parameter<RequestCompletion<[AppEvent]>>) -> Verify { return Verify(method: .m_getEvents__completion(`completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func getEvents(_ completion: Parameter<RequestCompletion<[AppEvent]>>, perform: @escaping (@escaping RequestCompletion<[AppEvent]>) -> Void) -> Perform {
            return Perform(method: .m_getEvents__completion(`completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ForgotPasswordInteractorProtocol
open class ForgotPasswordInteractorProtocolMock: ForgotPasswordInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func handleTextFieldChange(email: String?) {
        addInvocation(.m_handleTextFieldChange__email_email(Parameter<String?>.value(`email`)))
		let perform = methodPerformValue(.m_handleTextFieldChange__email_email(Parameter<String?>.value(`email`))) as? (String?) -> Void
		perform?(`email`)
    }

    open func sendEmail(email: String?) {
        addInvocation(.m_sendEmail__email_email(Parameter<String?>.value(`email`)))
		let perform = methodPerformValue(.m_sendEmail__email_email(Parameter<String?>.value(`email`))) as? (String?) -> Void
		perform?(`email`)
    }


    fileprivate enum MethodType {
        case m_handleTextFieldChange__email_email(Parameter<String?>)
        case m_sendEmail__email_email(Parameter<String?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_handleTextFieldChange__email_email(let lhsEmail), .m_handleTextFieldChange__email_email(let rhsEmail)):
                guard Parameter.compare(lhs: lhsEmail, rhs: rhsEmail, with: matcher) else { return false } 
                return true 
            case (.m_sendEmail__email_email(let lhsEmail), .m_sendEmail__email_email(let rhsEmail)):
                guard Parameter.compare(lhs: lhsEmail, rhs: rhsEmail, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_handleTextFieldChange__email_email(p0): return p0.intValue
            case let .m_sendEmail__email_email(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func handleTextFieldChange(email: Parameter<String?>) -> Verify { return Verify(method: .m_handleTextFieldChange__email_email(`email`))}
        public static func sendEmail(email: Parameter<String?>) -> Verify { return Verify(method: .m_sendEmail__email_email(`email`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func handleTextFieldChange(email: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_handleTextFieldChange__email_email(`email`), performs: perform)
        }
        public static func sendEmail(email: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_sendEmail__email_email(`email`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ForgotPasswordPresenterProtocol
open class ForgotPasswordPresenterProtocolMock: ForgotPasswordPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: ForgotPasswordViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<ForgotPasswordViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<ForgotPasswordViewControllerProtocol?>.value(`viewController`))) as? (ForgotPasswordViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func presentValidationError(_ error: DataValidationError) {
        addInvocation(.m_presentValidationError__error(Parameter<DataValidationError>.value(`error`)))
		let perform = methodPerformValue(.m_presentValidationError__error(Parameter<DataValidationError>.value(`error`))) as? (DataValidationError) -> Void
		perform?(`error`)
    }

    open func presentValidationSuccess() {
        addInvocation(.m_presentValidationSuccess)
		let perform = methodPerformValue(.m_presentValidationSuccess) as? () -> Void
		perform?()
    }

    open func presentEmailSentSuccess() {
        addInvocation(.m_presentEmailSentSuccess)
		let perform = methodPerformValue(.m_presentEmailSentSuccess) as? () -> Void
		perform?()
    }

    open func presentEmailSentError(_ error: ForgotPasswordError) {
        addInvocation(.m_presentEmailSentError__error(Parameter<ForgotPasswordError>.value(`error`)))
		let perform = methodPerformValue(.m_presentEmailSentError__error(Parameter<ForgotPasswordError>.value(`error`))) as? (ForgotPasswordError) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<ForgotPasswordViewControllerProtocol?>)
        case m_presentValidationError__error(Parameter<DataValidationError>)
        case m_presentValidationSuccess
        case m_presentEmailSentSuccess
        case m_presentEmailSentError__error(Parameter<ForgotPasswordError>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_presentValidationError__error(let lhsError), .m_presentValidationError__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_presentValidationSuccess, .m_presentValidationSuccess):
                return true 
            case (.m_presentEmailSentSuccess, .m_presentEmailSentSuccess):
                return true 
            case (.m_presentEmailSentError__error(let lhsError), .m_presentEmailSentError__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_presentValidationError__error(p0): return p0.intValue
            case .m_presentValidationSuccess: return 0
            case .m_presentEmailSentSuccess: return 0
            case let .m_presentEmailSentError__error(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<ForgotPasswordViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func presentValidationError(_ error: Parameter<DataValidationError>) -> Verify { return Verify(method: .m_presentValidationError__error(`error`))}
        public static func presentValidationSuccess() -> Verify { return Verify(method: .m_presentValidationSuccess)}
        public static func presentEmailSentSuccess() -> Verify { return Verify(method: .m_presentEmailSentSuccess)}
        public static func presentEmailSentError(_ error: Parameter<ForgotPasswordError>) -> Verify { return Verify(method: .m_presentEmailSentError__error(`error`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<ForgotPasswordViewControllerProtocol?>, perform: @escaping (ForgotPasswordViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func presentValidationError(_ error: Parameter<DataValidationError>, perform: @escaping (DataValidationError) -> Void) -> Perform {
            return Perform(method: .m_presentValidationError__error(`error`), performs: perform)
        }
        public static func presentValidationSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentValidationSuccess, performs: perform)
        }
        public static func presentEmailSentSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentEmailSentSuccess, performs: perform)
        }
        public static func presentEmailSentError(_ error: Parameter<ForgotPasswordError>, perform: @escaping (ForgotPasswordError) -> Void) -> Perform {
            return Perform(method: .m_presentEmailSentError__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ForgotPasswordRouterProtocol
open class ForgotPasswordRouterProtocolMock: ForgotPasswordRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: ForgotPasswordViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<ForgotPasswordViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<ForgotPasswordViewControllerProtocol?>.value(`viewController`))) as? (ForgotPasswordViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: ForgotPasswordRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<ForgotPasswordRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<ForgotPasswordRouter.Scene>.value(`scene`))) as? (ForgotPasswordRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<ForgotPasswordViewControllerProtocol?>)
        case m_route__to_scene(Parameter<ForgotPasswordRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<ForgotPasswordViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<ForgotPasswordRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<ForgotPasswordViewControllerProtocol?>, perform: @escaping (ForgotPasswordViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<ForgotPasswordRouter.Scene>, perform: @escaping (ForgotPasswordRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ForgotPasswordServiceProtocol
open class ForgotPasswordServiceProtocolMock: ForgotPasswordServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func forgetPassword(email: String, _ completion: @escaping RequestCompletion<ForgotPasswordResponse>) {
        addInvocation(.m_forgetPassword__email_email_completion(Parameter<String>.value(`email`), Parameter<RequestCompletion<ForgotPasswordResponse>>.any))
		let perform = methodPerformValue(.m_forgetPassword__email_email_completion(Parameter<String>.value(`email`), Parameter<RequestCompletion<ForgotPasswordResponse>>.any)) as? (String, @escaping RequestCompletion<ForgotPasswordResponse>) -> Void
		perform?(`email`, `completion`)
    }


    fileprivate enum MethodType {
        case m_forgetPassword__email_email_completion(Parameter<String>, Parameter<RequestCompletion<ForgotPasswordResponse>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_forgetPassword__email_email_completion(let lhsEmail, let lhsCompletion), .m_forgetPassword__email_email_completion(let rhsEmail, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsEmail, rhs: rhsEmail, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_forgetPassword__email_email_completion(p0, p1): return p0.intValue + p1.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func forgetPassword(email: Parameter<String>, _ completion: Parameter<RequestCompletion<ForgotPasswordResponse>>) -> Verify { return Verify(method: .m_forgetPassword__email_email_completion(`email`, `completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func forgetPassword(email: Parameter<String>, _ completion: Parameter<RequestCompletion<ForgotPasswordResponse>>, perform: @escaping (String, @escaping RequestCompletion<ForgotPasswordResponse>) -> Void) -> Perform {
            return Perform(method: .m_forgetPassword__email_email_completion(`email`, `completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ForgotPasswordViewControllerProtocol
open class ForgotPasswordViewControllerProtocolMock: ForgotPasswordViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: ForgotPasswordInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<ForgotPasswordInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<ForgotPasswordInteractorProtocol>.value(`interactor`))) as? (ForgotPasswordInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: ForgotPasswordRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<ForgotPasswordRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<ForgotPasswordRouterProtocol>.value(`router`))) as? (ForgotPasswordRouterProtocol) -> Void
		perform?(`router`)
    }

    open func set(alertPresenter: AlertPresenterProtocol) {
        addInvocation(.m_set__alertPresenter_alertPresenter(Parameter<AlertPresenterProtocol>.value(`alertPresenter`)))
		let perform = methodPerformValue(.m_set__alertPresenter_alertPresenter(Parameter<AlertPresenterProtocol>.value(`alertPresenter`))) as? (AlertPresenterProtocol) -> Void
		perform?(`alertPresenter`)
    }

    open func displayValidationError(_ error: String) {
        addInvocation(.m_displayValidationError__error(Parameter<String>.value(`error`)))
		let perform = methodPerformValue(.m_displayValidationError__error(Parameter<String>.value(`error`))) as? (String) -> Void
		perform?(`error`)
    }

    open func displayValidationSuccess() {
        addInvocation(.m_displayValidationSuccess)
		let perform = methodPerformValue(.m_displayValidationSuccess) as? () -> Void
		perform?()
    }

    open func displayEmailSentSuccess() {
        addInvocation(.m_displayEmailSentSuccess)
		let perform = methodPerformValue(.m_displayEmailSentSuccess) as? () -> Void
		perform?()
    }

    open func displayEmailSentError(_ error: ForgotPasswordError) {
        addInvocation(.m_displayEmailSentError__error(Parameter<ForgotPasswordError>.value(`error`)))
		let perform = methodPerformValue(.m_displayEmailSentError__error(Parameter<ForgotPasswordError>.value(`error`))) as? (ForgotPasswordError) -> Void
		perform?(`error`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<ForgotPasswordInteractorProtocol>)
        case m_set__router_router(Parameter<ForgotPasswordRouterProtocol>)
        case m_set__alertPresenter_alertPresenter(Parameter<AlertPresenterProtocol>)
        case m_displayValidationError__error(Parameter<String>)
        case m_displayValidationSuccess
        case m_displayEmailSentSuccess
        case m_displayEmailSentError__error(Parameter<ForgotPasswordError>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_set__alertPresenter_alertPresenter(let lhsAlertpresenter), .m_set__alertPresenter_alertPresenter(let rhsAlertpresenter)):
                guard Parameter.compare(lhs: lhsAlertpresenter, rhs: rhsAlertpresenter, with: matcher) else { return false } 
                return true 
            case (.m_displayValidationError__error(let lhsError), .m_displayValidationError__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayValidationSuccess, .m_displayValidationSuccess):
                return true 
            case (.m_displayEmailSentSuccess, .m_displayEmailSentSuccess):
                return true 
            case (.m_displayEmailSentError__error(let lhsError), .m_displayEmailSentError__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_set__alertPresenter_alertPresenter(p0): return p0.intValue
            case let .m_displayValidationError__error(p0): return p0.intValue
            case .m_displayValidationSuccess: return 0
            case .m_displayEmailSentSuccess: return 0
            case let .m_displayEmailSentError__error(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<ForgotPasswordInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<ForgotPasswordRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func set(alertPresenter: Parameter<AlertPresenterProtocol>) -> Verify { return Verify(method: .m_set__alertPresenter_alertPresenter(`alertPresenter`))}
        public static func displayValidationError(_ error: Parameter<String>) -> Verify { return Verify(method: .m_displayValidationError__error(`error`))}
        public static func displayValidationSuccess() -> Verify { return Verify(method: .m_displayValidationSuccess)}
        public static func displayEmailSentSuccess() -> Verify { return Verify(method: .m_displayEmailSentSuccess)}
        public static func displayEmailSentError(_ error: Parameter<ForgotPasswordError>) -> Verify { return Verify(method: .m_displayEmailSentError__error(`error`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<ForgotPasswordInteractorProtocol>, perform: @escaping (ForgotPasswordInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<ForgotPasswordRouterProtocol>, perform: @escaping (ForgotPasswordRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func set(alertPresenter: Parameter<AlertPresenterProtocol>, perform: @escaping (AlertPresenterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__alertPresenter_alertPresenter(`alertPresenter`), performs: perform)
        }
        public static func displayValidationError(_ error: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayValidationError__error(`error`), performs: perform)
        }
        public static func displayValidationSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_displayValidationSuccess, performs: perform)
        }
        public static func displayEmailSentSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_displayEmailSentSuccess, performs: perform)
        }
        public static func displayEmailSentError(_ error: Parameter<ForgotPasswordError>, perform: @escaping (ForgotPasswordError) -> Void) -> Perform {
            return Perform(method: .m_displayEmailSentError__error(`error`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InComingInteractorProtocol
open class InComingInteractorProtocolMock: InComingInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func getInvitations() {
        addInvocation(.m_getInvitations)
		let perform = methodPerformValue(.m_getInvitations) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_getInvitations

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_getInvitations, .m_getInvitations):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_getInvitations: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func getInvitations() -> Verify { return Verify(method: .m_getInvitations)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func getInvitations(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_getInvitations, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InComingPresenterProtocol
open class InComingPresenterProtocolMock: InComingPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: InComingViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<InComingViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<InComingViewControllerProtocol?>.value(`viewController`))) as? (InComingViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func present(incomingDataSource: [Appointment]) {
        addInvocation(.m_present__incomingDataSource_incomingDataSource(Parameter<[Appointment]>.value(`incomingDataSource`)))
		let perform = methodPerformValue(.m_present__incomingDataSource_incomingDataSource(Parameter<[Appointment]>.value(`incomingDataSource`))) as? ([Appointment]) -> Void
		perform?(`incomingDataSource`)
    }

    open func presentLoadingView(display: Bool) {
        addInvocation(.m_presentLoadingView__display_display(Parameter<Bool>.value(`display`)))
		let perform = methodPerformValue(.m_presentLoadingView__display_display(Parameter<Bool>.value(`display`))) as? (Bool) -> Void
		perform?(`display`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<InComingViewControllerProtocol?>)
        case m_present__incomingDataSource_incomingDataSource(Parameter<[Appointment]>)
        case m_presentLoadingView__display_display(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_present__incomingDataSource_incomingDataSource(let lhsIncomingdatasource), .m_present__incomingDataSource_incomingDataSource(let rhsIncomingdatasource)):
                guard Parameter.compare(lhs: lhsIncomingdatasource, rhs: rhsIncomingdatasource, with: matcher) else { return false } 
                return true 
            case (.m_presentLoadingView__display_display(let lhsDisplay), .m_presentLoadingView__display_display(let rhsDisplay)):
                guard Parameter.compare(lhs: lhsDisplay, rhs: rhsDisplay, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_present__incomingDataSource_incomingDataSource(p0): return p0.intValue
            case let .m_presentLoadingView__display_display(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<InComingViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func present(incomingDataSource: Parameter<[Appointment]>) -> Verify { return Verify(method: .m_present__incomingDataSource_incomingDataSource(`incomingDataSource`))}
        public static func presentLoadingView(display: Parameter<Bool>) -> Verify { return Verify(method: .m_presentLoadingView__display_display(`display`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<InComingViewControllerProtocol?>, perform: @escaping (InComingViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func present(incomingDataSource: Parameter<[Appointment]>, perform: @escaping ([Appointment]) -> Void) -> Perform {
            return Perform(method: .m_present__incomingDataSource_incomingDataSource(`incomingDataSource`), performs: perform)
        }
        public static func presentLoadingView(display: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_presentLoadingView__display_display(`display`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InComingRouterProtocol
open class InComingRouterProtocolMock: InComingRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: InComingViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<InComingViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<InComingViewControllerProtocol?>.value(`viewController`))) as? (InComingViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: InComingRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<InComingRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<InComingRouter.Scene>.value(`scene`))) as? (InComingRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<InComingViewControllerProtocol?>)
        case m_route__to_scene(Parameter<InComingRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<InComingViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<InComingRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<InComingViewControllerProtocol?>, perform: @escaping (InComingViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<InComingRouter.Scene>, perform: @escaping (InComingRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InComingViewControllerProtocol
open class InComingViewControllerProtocolMock: InComingViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: InComingInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<InComingInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<InComingInteractorProtocol>.value(`interactor`))) as? (InComingInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: InComingRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<InComingRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<InComingRouterProtocol>.value(`router`))) as? (InComingRouterProtocol) -> Void
		perform?(`router`)
    }

    open func set(incomingDataSource: [Appointment]) {
        addInvocation(.m_set__incomingDataSource_incomingDataSource(Parameter<[Appointment]>.value(`incomingDataSource`)))
		let perform = methodPerformValue(.m_set__incomingDataSource_incomingDataSource(Parameter<[Appointment]>.value(`incomingDataSource`))) as? ([Appointment]) -> Void
		perform?(`incomingDataSource`)
    }

    open func displayLoadingView(display: Bool) {
        addInvocation(.m_displayLoadingView__display_display(Parameter<Bool>.value(`display`)))
		let perform = methodPerformValue(.m_displayLoadingView__display_display(Parameter<Bool>.value(`display`))) as? (Bool) -> Void
		perform?(`display`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<InComingInteractorProtocol>)
        case m_set__router_router(Parameter<InComingRouterProtocol>)
        case m_set__incomingDataSource_incomingDataSource(Parameter<[Appointment]>)
        case m_displayLoadingView__display_display(Parameter<Bool>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_set__incomingDataSource_incomingDataSource(let lhsIncomingdatasource), .m_set__incomingDataSource_incomingDataSource(let rhsIncomingdatasource)):
                guard Parameter.compare(lhs: lhsIncomingdatasource, rhs: rhsIncomingdatasource, with: matcher) else { return false } 
                return true 
            case (.m_displayLoadingView__display_display(let lhsDisplay), .m_displayLoadingView__display_display(let rhsDisplay)):
                guard Parameter.compare(lhs: lhsDisplay, rhs: rhsDisplay, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_set__incomingDataSource_incomingDataSource(p0): return p0.intValue
            case let .m_displayLoadingView__display_display(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<InComingInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<InComingRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func set(incomingDataSource: Parameter<[Appointment]>) -> Verify { return Verify(method: .m_set__incomingDataSource_incomingDataSource(`incomingDataSource`))}
        public static func displayLoadingView(display: Parameter<Bool>) -> Verify { return Verify(method: .m_displayLoadingView__display_display(`display`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<InComingInteractorProtocol>, perform: @escaping (InComingInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<InComingRouterProtocol>, perform: @escaping (InComingRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func set(incomingDataSource: Parameter<[Appointment]>, perform: @escaping ([Appointment]) -> Void) -> Perform {
            return Perform(method: .m_set__incomingDataSource_incomingDataSource(`incomingDataSource`), performs: perform)
        }
        public static func displayLoadingView(display: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_displayLoadingView__display_display(`display`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationContainerInteractorProtocol
open class InvitationContainerInteractorProtocolMock: InvitationContainerInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func handleChangeState(state: InvitationTabView.State) {
        addInvocation(.m_handleChangeState__state_state(Parameter<InvitationTabView.State>.value(`state`)))
		let perform = methodPerformValue(.m_handleChangeState__state_state(Parameter<InvitationTabView.State>.value(`state`))) as? (InvitationTabView.State) -> Void
		perform?(`state`)
    }

    open func handleViewDidLoad() {
        addInvocation(.m_handleViewDidLoad)
		let perform = methodPerformValue(.m_handleViewDidLoad) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_handleChangeState__state_state(Parameter<InvitationTabView.State>)
        case m_handleViewDidLoad

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_handleChangeState__state_state(let lhsState), .m_handleChangeState__state_state(let rhsState)):
                guard Parameter.compare(lhs: lhsState, rhs: rhsState, with: matcher) else { return false } 
                return true 
            case (.m_handleViewDidLoad, .m_handleViewDidLoad):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_handleChangeState__state_state(p0): return p0.intValue
            case .m_handleViewDidLoad: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func handleChangeState(state: Parameter<InvitationTabView.State>) -> Verify { return Verify(method: .m_handleChangeState__state_state(`state`))}
        public static func handleViewDidLoad() -> Verify { return Verify(method: .m_handleViewDidLoad)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func handleChangeState(state: Parameter<InvitationTabView.State>, perform: @escaping (InvitationTabView.State) -> Void) -> Perform {
            return Perform(method: .m_handleChangeState__state_state(`state`), performs: perform)
        }
        public static func handleViewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_handleViewDidLoad, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationContainerPresenterProtocol
open class InvitationContainerPresenterProtocolMock: InvitationContainerPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func presentInitialView(with state: InvitationTabView.State) {
        addInvocation(.m_presentInitialView__with_state(Parameter<InvitationTabView.State>.value(`state`)))
		let perform = methodPerformValue(.m_presentInitialView__with_state(Parameter<InvitationTabView.State>.value(`state`))) as? (InvitationTabView.State) -> Void
		perform?(`state`)
    }

    open func presentContainerTabView(_ state: InvitationTabView.State) {
        addInvocation(.m_presentContainerTabView__state(Parameter<InvitationTabView.State>.value(`state`)))
		let perform = methodPerformValue(.m_presentContainerTabView__state(Parameter<InvitationTabView.State>.value(`state`))) as? (InvitationTabView.State) -> Void
		perform?(`state`)
    }

    open func set(viewController: InvitationContainerViewControllerProtocol) {
        addInvocation(.m_set__viewController_viewController(Parameter<InvitationContainerViewControllerProtocol>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<InvitationContainerViewControllerProtocol>.value(`viewController`))) as? (InvitationContainerViewControllerProtocol) -> Void
		perform?(`viewController`)
    }


    fileprivate enum MethodType {
        case m_presentInitialView__with_state(Parameter<InvitationTabView.State>)
        case m_presentContainerTabView__state(Parameter<InvitationTabView.State>)
        case m_set__viewController_viewController(Parameter<InvitationContainerViewControllerProtocol>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentInitialView__with_state(let lhsState), .m_presentInitialView__with_state(let rhsState)):
                guard Parameter.compare(lhs: lhsState, rhs: rhsState, with: matcher) else { return false } 
                return true 
            case (.m_presentContainerTabView__state(let lhsState), .m_presentContainerTabView__state(let rhsState)):
                guard Parameter.compare(lhs: lhsState, rhs: rhsState, with: matcher) else { return false } 
                return true 
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_presentInitialView__with_state(p0): return p0.intValue
            case let .m_presentContainerTabView__state(p0): return p0.intValue
            case let .m_set__viewController_viewController(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func presentInitialView(with state: Parameter<InvitationTabView.State>) -> Verify { return Verify(method: .m_presentInitialView__with_state(`state`))}
        public static func presentContainerTabView(_ state: Parameter<InvitationTabView.State>) -> Verify { return Verify(method: .m_presentContainerTabView__state(`state`))}
        public static func set(viewController: Parameter<InvitationContainerViewControllerProtocol>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func presentInitialView(with state: Parameter<InvitationTabView.State>, perform: @escaping (InvitationTabView.State) -> Void) -> Perform {
            return Perform(method: .m_presentInitialView__with_state(`state`), performs: perform)
        }
        public static func presentContainerTabView(_ state: Parameter<InvitationTabView.State>, perform: @escaping (InvitationTabView.State) -> Void) -> Perform {
            return Perform(method: .m_presentContainerTabView__state(`state`), performs: perform)
        }
        public static func set(viewController: Parameter<InvitationContainerViewControllerProtocol>, perform: @escaping (InvitationContainerViewControllerProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationContainerRouterProtocol
open class InvitationContainerRouterProtocolMock: InvitationContainerRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: InvitationContainerViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<InvitationContainerViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<InvitationContainerViewControllerProtocol?>.value(`viewController`))) as? (InvitationContainerViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: InvitationContainerRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<InvitationContainerRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<InvitationContainerRouter.Scene>.value(`scene`))) as? (InvitationContainerRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<InvitationContainerViewControllerProtocol?>)
        case m_route__to_scene(Parameter<InvitationContainerRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<InvitationContainerViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<InvitationContainerRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<InvitationContainerViewControllerProtocol?>, perform: @escaping (InvitationContainerViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<InvitationContainerRouter.Scene>, perform: @escaping (InvitationContainerRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationContainerViewControllerProtocol
open class InvitationContainerViewControllerProtocolMock: InvitationContainerViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func displayChild(_ viewController: UIViewController) {
        addInvocation(.m_displayChild__viewController(Parameter<UIViewController>.value(`viewController`)))
		let perform = methodPerformValue(.m_displayChild__viewController(Parameter<UIViewController>.value(`viewController`))) as? (UIViewController) -> Void
		perform?(`viewController`)
    }

    open func displayContainerTabView(_ state: InvitationTabView.State, animated: Bool) {
        addInvocation(.m_displayContainerTabView__stateanimated_animated(Parameter<InvitationTabView.State>.value(`state`), Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_displayContainerTabView__stateanimated_animated(Parameter<InvitationTabView.State>.value(`state`), Parameter<Bool>.value(`animated`))) as? (InvitationTabView.State, Bool) -> Void
		perform?(`state`, `animated`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_displayChild__viewController(Parameter<UIViewController>)
        case m_displayContainerTabView__stateanimated_animated(Parameter<InvitationTabView.State>, Parameter<Bool>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_displayChild__viewController(let lhsViewcontroller), .m_displayChild__viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_displayContainerTabView__stateanimated_animated(let lhsState, let lhsAnimated), .m_displayContainerTabView__stateanimated_animated(let rhsState, let rhsAnimated)):
                guard Parameter.compare(lhs: lhsState, rhs: rhsState, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_displayChild__viewController(p0): return p0.intValue
            case let .m_displayContainerTabView__stateanimated_animated(p0, p1): return p0.intValue + p1.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func displayChild(_ viewController: Parameter<UIViewController>) -> Verify { return Verify(method: .m_displayChild__viewController(`viewController`))}
        public static func displayContainerTabView(_ state: Parameter<InvitationTabView.State>, animated: Parameter<Bool>) -> Verify { return Verify(method: .m_displayContainerTabView__stateanimated_animated(`state`, `animated`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func displayChild(_ viewController: Parameter<UIViewController>, perform: @escaping (UIViewController) -> Void) -> Perform {
            return Perform(method: .m_displayChild__viewController(`viewController`), performs: perform)
        }
        public static func displayContainerTabView(_ state: Parameter<InvitationTabView.State>, animated: Parameter<Bool>, perform: @escaping (InvitationTabView.State, Bool) -> Void) -> Perform {
            return Perform(method: .m_displayContainerTabView__stateanimated_animated(`state`, `animated`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationDetailInteractorProtocol
open class InvitationDetailInteractorProtocolMock: InvitationDetailInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func cancelAsCreator(invitation: Appointment) {
        addInvocation(.m_cancelAsCreator__invitation_invitation(Parameter<Appointment>.value(`invitation`)))
		let perform = methodPerformValue(.m_cancelAsCreator__invitation_invitation(Parameter<Appointment>.value(`invitation`))) as? (Appointment) -> Void
		perform?(`invitation`)
    }

    open func cancelAsInvitee(invitation: Appointment) {
        addInvocation(.m_cancelAsInvitee__invitation_invitation(Parameter<Appointment>.value(`invitation`)))
		let perform = methodPerformValue(.m_cancelAsInvitee__invitation_invitation(Parameter<Appointment>.value(`invitation`))) as? (Appointment) -> Void
		perform?(`invitation`)
    }

    open func handleSetProposedDates(invitation: Appointment) {
        addInvocation(.m_handleSetProposedDates__invitation_invitation(Parameter<Appointment>.value(`invitation`)))
		let perform = methodPerformValue(.m_handleSetProposedDates__invitation_invitation(Parameter<Appointment>.value(`invitation`))) as? (Appointment) -> Void
		perform?(`invitation`)
    }

    open func handleAcceptProposedDate(invitation: Appointment) {
        addInvocation(.m_handleAcceptProposedDate__invitation_invitation(Parameter<Appointment>.value(`invitation`)))
		let perform = methodPerformValue(.m_handleAcceptProposedDate__invitation_invitation(Parameter<Appointment>.value(`invitation`))) as? (Appointment) -> Void
		perform?(`invitation`)
    }

    open func handleRejectProposedDate(invitation: Appointment) {
        addInvocation(.m_handleRejectProposedDate__invitation_invitation(Parameter<Appointment>.value(`invitation`)))
		let perform = methodPerformValue(.m_handleRejectProposedDate__invitation_invitation(Parameter<Appointment>.value(`invitation`))) as? (Appointment) -> Void
		perform?(`invitation`)
    }


    fileprivate enum MethodType {
        case m_cancelAsCreator__invitation_invitation(Parameter<Appointment>)
        case m_cancelAsInvitee__invitation_invitation(Parameter<Appointment>)
        case m_handleSetProposedDates__invitation_invitation(Parameter<Appointment>)
        case m_handleAcceptProposedDate__invitation_invitation(Parameter<Appointment>)
        case m_handleRejectProposedDate__invitation_invitation(Parameter<Appointment>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_cancelAsCreator__invitation_invitation(let lhsInvitation), .m_cancelAsCreator__invitation_invitation(let rhsInvitation)):
                guard Parameter.compare(lhs: lhsInvitation, rhs: rhsInvitation, with: matcher) else { return false } 
                return true 
            case (.m_cancelAsInvitee__invitation_invitation(let lhsInvitation), .m_cancelAsInvitee__invitation_invitation(let rhsInvitation)):
                guard Parameter.compare(lhs: lhsInvitation, rhs: rhsInvitation, with: matcher) else { return false } 
                return true 
            case (.m_handleSetProposedDates__invitation_invitation(let lhsInvitation), .m_handleSetProposedDates__invitation_invitation(let rhsInvitation)):
                guard Parameter.compare(lhs: lhsInvitation, rhs: rhsInvitation, with: matcher) else { return false } 
                return true 
            case (.m_handleAcceptProposedDate__invitation_invitation(let lhsInvitation), .m_handleAcceptProposedDate__invitation_invitation(let rhsInvitation)):
                guard Parameter.compare(lhs: lhsInvitation, rhs: rhsInvitation, with: matcher) else { return false } 
                return true 
            case (.m_handleRejectProposedDate__invitation_invitation(let lhsInvitation), .m_handleRejectProposedDate__invitation_invitation(let rhsInvitation)):
                guard Parameter.compare(lhs: lhsInvitation, rhs: rhsInvitation, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_cancelAsCreator__invitation_invitation(p0): return p0.intValue
            case let .m_cancelAsInvitee__invitation_invitation(p0): return p0.intValue
            case let .m_handleSetProposedDates__invitation_invitation(p0): return p0.intValue
            case let .m_handleAcceptProposedDate__invitation_invitation(p0): return p0.intValue
            case let .m_handleRejectProposedDate__invitation_invitation(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func cancelAsCreator(invitation: Parameter<Appointment>) -> Verify { return Verify(method: .m_cancelAsCreator__invitation_invitation(`invitation`))}
        public static func cancelAsInvitee(invitation: Parameter<Appointment>) -> Verify { return Verify(method: .m_cancelAsInvitee__invitation_invitation(`invitation`))}
        public static func handleSetProposedDates(invitation: Parameter<Appointment>) -> Verify { return Verify(method: .m_handleSetProposedDates__invitation_invitation(`invitation`))}
        public static func handleAcceptProposedDate(invitation: Parameter<Appointment>) -> Verify { return Verify(method: .m_handleAcceptProposedDate__invitation_invitation(`invitation`))}
        public static func handleRejectProposedDate(invitation: Parameter<Appointment>) -> Verify { return Verify(method: .m_handleRejectProposedDate__invitation_invitation(`invitation`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func cancelAsCreator(invitation: Parameter<Appointment>, perform: @escaping (Appointment) -> Void) -> Perform {
            return Perform(method: .m_cancelAsCreator__invitation_invitation(`invitation`), performs: perform)
        }
        public static func cancelAsInvitee(invitation: Parameter<Appointment>, perform: @escaping (Appointment) -> Void) -> Perform {
            return Perform(method: .m_cancelAsInvitee__invitation_invitation(`invitation`), performs: perform)
        }
        public static func handleSetProposedDates(invitation: Parameter<Appointment>, perform: @escaping (Appointment) -> Void) -> Perform {
            return Perform(method: .m_handleSetProposedDates__invitation_invitation(`invitation`), performs: perform)
        }
        public static func handleAcceptProposedDate(invitation: Parameter<Appointment>, perform: @escaping (Appointment) -> Void) -> Perform {
            return Perform(method: .m_handleAcceptProposedDate__invitation_invitation(`invitation`), performs: perform)
        }
        public static func handleRejectProposedDate(invitation: Parameter<Appointment>, perform: @escaping (Appointment) -> Void) -> Perform {
            return Perform(method: .m_handleRejectProposedDate__invitation_invitation(`invitation`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationDetailPresenterProtocol
open class InvitationDetailPresenterProtocolMock: InvitationDetailPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: InvitationDetailViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<InvitationDetailViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<InvitationDetailViewControllerProtocol?>.value(`viewController`))) as? (InvitationDetailViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func handle(error: Error) {
        addInvocation(.m_handle__error_error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_handle__error_error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }

    open func presentCancelInvitationSuccess() {
        addInvocation(.m_presentCancelInvitationSuccess)
		let perform = methodPerformValue(.m_presentCancelInvitationSuccess) as? () -> Void
		perform?()
    }

    open func presentCancelInvitationFailure(error: MoyaError) {
        addInvocation(.m_presentCancelInvitationFailure__error_error(Parameter<MoyaError>.value(`error`)))
		let perform = methodPerformValue(.m_presentCancelInvitationFailure__error_error(Parameter<MoyaError>.value(`error`))) as? (MoyaError) -> Void
		perform?(`error`)
    }

    open func presentProposedDate(startDate: Date, endDate: Date) {
        addInvocation(.m_presentProposedDate__startDate_startDateendDate_endDate(Parameter<Date>.value(`startDate`), Parameter<Date>.value(`endDate`)))
		let perform = methodPerformValue(.m_presentProposedDate__startDate_startDateendDate_endDate(Parameter<Date>.value(`startDate`), Parameter<Date>.value(`endDate`))) as? (Date, Date) -> Void
		perform?(`startDate`, `endDate`)
    }

    open func presentProposedDatesIsEmpty() {
        addInvocation(.m_presentProposedDatesIsEmpty)
		let perform = methodPerformValue(.m_presentProposedDatesIsEmpty) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<InvitationDetailViewControllerProtocol?>)
        case m_handle__error_error(Parameter<Error>)
        case m_presentCancelInvitationSuccess
        case m_presentCancelInvitationFailure__error_error(Parameter<MoyaError>)
        case m_presentProposedDate__startDate_startDateendDate_endDate(Parameter<Date>, Parameter<Date>)
        case m_presentProposedDatesIsEmpty

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_handle__error_error(let lhsError), .m_handle__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_presentCancelInvitationSuccess, .m_presentCancelInvitationSuccess):
                return true 
            case (.m_presentCancelInvitationFailure__error_error(let lhsError), .m_presentCancelInvitationFailure__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_presentProposedDate__startDate_startDateendDate_endDate(let lhsStartdate, let lhsEnddate), .m_presentProposedDate__startDate_startDateendDate_endDate(let rhsStartdate, let rhsEnddate)):
                guard Parameter.compare(lhs: lhsStartdate, rhs: rhsStartdate, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsEnddate, rhs: rhsEnddate, with: matcher) else { return false } 
                return true 
            case (.m_presentProposedDatesIsEmpty, .m_presentProposedDatesIsEmpty):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_handle__error_error(p0): return p0.intValue
            case .m_presentCancelInvitationSuccess: return 0
            case let .m_presentCancelInvitationFailure__error_error(p0): return p0.intValue
            case let .m_presentProposedDate__startDate_startDateendDate_endDate(p0, p1): return p0.intValue + p1.intValue
            case .m_presentProposedDatesIsEmpty: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<InvitationDetailViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func handle(error: Parameter<Error>) -> Verify { return Verify(method: .m_handle__error_error(`error`))}
        public static func presentCancelInvitationSuccess() -> Verify { return Verify(method: .m_presentCancelInvitationSuccess)}
        public static func presentCancelInvitationFailure(error: Parameter<MoyaError>) -> Verify { return Verify(method: .m_presentCancelInvitationFailure__error_error(`error`))}
        public static func presentProposedDate(startDate: Parameter<Date>, endDate: Parameter<Date>) -> Verify { return Verify(method: .m_presentProposedDate__startDate_startDateendDate_endDate(`startDate`, `endDate`))}
        public static func presentProposedDatesIsEmpty() -> Verify { return Verify(method: .m_presentProposedDatesIsEmpty)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<InvitationDetailViewControllerProtocol?>, perform: @escaping (InvitationDetailViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func handle(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_handle__error_error(`error`), performs: perform)
        }
        public static func presentCancelInvitationSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentCancelInvitationSuccess, performs: perform)
        }
        public static func presentCancelInvitationFailure(error: Parameter<MoyaError>, perform: @escaping (MoyaError) -> Void) -> Perform {
            return Perform(method: .m_presentCancelInvitationFailure__error_error(`error`), performs: perform)
        }
        public static func presentProposedDate(startDate: Parameter<Date>, endDate: Parameter<Date>, perform: @escaping (Date, Date) -> Void) -> Perform {
            return Perform(method: .m_presentProposedDate__startDate_startDateendDate_endDate(`startDate`, `endDate`), performs: perform)
        }
        public static func presentProposedDatesIsEmpty(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentProposedDatesIsEmpty, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationDetailRouterProtocol
open class InvitationDetailRouterProtocolMock: InvitationDetailRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: InvitationDetailViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<InvitationDetailViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<InvitationDetailViewControllerProtocol?>.value(`viewController`))) as? (InvitationDetailViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: InvitationDetailRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<InvitationDetailRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<InvitationDetailRouter.Scene>.value(`scene`))) as? (InvitationDetailRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<InvitationDetailViewControllerProtocol?>)
        case m_route__to_scene(Parameter<InvitationDetailRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<InvitationDetailViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<InvitationDetailRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<InvitationDetailViewControllerProtocol?>, perform: @escaping (InvitationDetailViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<InvitationDetailRouter.Scene>, perform: @escaping (InvitationDetailRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationDetailViewControllerProtocol
open class InvitationDetailViewControllerProtocolMock: InvitationDetailViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: InvitationDetailInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<InvitationDetailInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<InvitationDetailInteractorProtocol>.value(`interactor`))) as? (InvitationDetailInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: InvitationDetailRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<InvitationDetailRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<InvitationDetailRouterProtocol>.value(`router`))) as? (InvitationDetailRouterProtocol) -> Void
		perform?(`router`)
    }

    open func set(dataSource: InvitationDetailDataSourceProtocol) {
        addInvocation(.m_set__dataSource_dataSource(Parameter<InvitationDetailDataSourceProtocol>.value(`dataSource`)))
		let perform = methodPerformValue(.m_set__dataSource_dataSource(Parameter<InvitationDetailDataSourceProtocol>.value(`dataSource`))) as? (InvitationDetailDataSourceProtocol) -> Void
		perform?(`dataSource`)
    }

    open func set(invitation: Appointment?, isOutgoing: Bool) {
        addInvocation(.m_set__invitation_invitationisOutgoing_isOutgoing(Parameter<Appointment?>.value(`invitation`), Parameter<Bool>.value(`isOutgoing`)))
		let perform = methodPerformValue(.m_set__invitation_invitationisOutgoing_isOutgoing(Parameter<Appointment?>.value(`invitation`), Parameter<Bool>.value(`isOutgoing`))) as? (Appointment?, Bool) -> Void
		perform?(`invitation`, `isOutgoing`)
    }

    open func display(error: Error) {
        addInvocation(.m_display__error_error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_display__error_error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }

    open func displayCancelInvitationSuccess() {
        addInvocation(.m_displayCancelInvitationSuccess)
		let perform = methodPerformValue(.m_displayCancelInvitationSuccess) as? () -> Void
		perform?()
    }

    open func displayCancelInvitationFailure(error: String) {
        addInvocation(.m_displayCancelInvitationFailure__error_error(Parameter<String>.value(`error`)))
		let perform = methodPerformValue(.m_displayCancelInvitationFailure__error_error(Parameter<String>.value(`error`))) as? (String) -> Void
		perform?(`error`)
    }

    open func displayProposedDate(dateString: String) {
        addInvocation(.m_displayProposedDate__dateString_dateString(Parameter<String>.value(`dateString`)))
		let perform = methodPerformValue(.m_displayProposedDate__dateString_dateString(Parameter<String>.value(`dateString`))) as? (String) -> Void
		perform?(`dateString`)
    }

    open func displayProposedDatesIsEmpty() {
        addInvocation(.m_displayProposedDatesIsEmpty)
		let perform = methodPerformValue(.m_displayProposedDatesIsEmpty) as? () -> Void
		perform?()
    }

    open func didAdd(date: AppointmentDate) {
        addInvocation(.m_didAdd__date_date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_didAdd__date_date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<InvitationDetailInteractorProtocol>)
        case m_set__router_router(Parameter<InvitationDetailRouterProtocol>)
        case m_set__dataSource_dataSource(Parameter<InvitationDetailDataSourceProtocol>)
        case m_set__invitation_invitationisOutgoing_isOutgoing(Parameter<Appointment?>, Parameter<Bool>)
        case m_display__error_error(Parameter<Error>)
        case m_displayCancelInvitationSuccess
        case m_displayCancelInvitationFailure__error_error(Parameter<String>)
        case m_displayProposedDate__dateString_dateString(Parameter<String>)
        case m_displayProposedDatesIsEmpty
        case m_didAdd__date_date(Parameter<AppointmentDate>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_set__dataSource_dataSource(let lhsDatasource), .m_set__dataSource_dataSource(let rhsDatasource)):
                guard Parameter.compare(lhs: lhsDatasource, rhs: rhsDatasource, with: matcher) else { return false } 
                return true 
            case (.m_set__invitation_invitationisOutgoing_isOutgoing(let lhsInvitation, let lhsIsoutgoing), .m_set__invitation_invitationisOutgoing_isOutgoing(let rhsInvitation, let rhsIsoutgoing)):
                guard Parameter.compare(lhs: lhsInvitation, rhs: rhsInvitation, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsIsoutgoing, rhs: rhsIsoutgoing, with: matcher) else { return false } 
                return true 
            case (.m_display__error_error(let lhsError), .m_display__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayCancelInvitationSuccess, .m_displayCancelInvitationSuccess):
                return true 
            case (.m_displayCancelInvitationFailure__error_error(let lhsError), .m_displayCancelInvitationFailure__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayProposedDate__dateString_dateString(let lhsDatestring), .m_displayProposedDate__dateString_dateString(let rhsDatestring)):
                guard Parameter.compare(lhs: lhsDatestring, rhs: rhsDatestring, with: matcher) else { return false } 
                return true 
            case (.m_displayProposedDatesIsEmpty, .m_displayProposedDatesIsEmpty):
                return true 
            case (.m_didAdd__date_date(let lhsDate), .m_didAdd__date_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_set__dataSource_dataSource(p0): return p0.intValue
            case let .m_set__invitation_invitationisOutgoing_isOutgoing(p0, p1): return p0.intValue + p1.intValue
            case let .m_display__error_error(p0): return p0.intValue
            case .m_displayCancelInvitationSuccess: return 0
            case let .m_displayCancelInvitationFailure__error_error(p0): return p0.intValue
            case let .m_displayProposedDate__dateString_dateString(p0): return p0.intValue
            case .m_displayProposedDatesIsEmpty: return 0
            case let .m_didAdd__date_date(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<InvitationDetailInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<InvitationDetailRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func set(dataSource: Parameter<InvitationDetailDataSourceProtocol>) -> Verify { return Verify(method: .m_set__dataSource_dataSource(`dataSource`))}
        public static func set(invitation: Parameter<Appointment?>, isOutgoing: Parameter<Bool>) -> Verify { return Verify(method: .m_set__invitation_invitationisOutgoing_isOutgoing(`invitation`, `isOutgoing`))}
        public static func display(error: Parameter<Error>) -> Verify { return Verify(method: .m_display__error_error(`error`))}
        public static func displayCancelInvitationSuccess() -> Verify { return Verify(method: .m_displayCancelInvitationSuccess)}
        public static func displayCancelInvitationFailure(error: Parameter<String>) -> Verify { return Verify(method: .m_displayCancelInvitationFailure__error_error(`error`))}
        public static func displayProposedDate(dateString: Parameter<String>) -> Verify { return Verify(method: .m_displayProposedDate__dateString_dateString(`dateString`))}
        public static func displayProposedDatesIsEmpty() -> Verify { return Verify(method: .m_displayProposedDatesIsEmpty)}
        public static func didAdd(date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_didAdd__date_date(`date`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<InvitationDetailInteractorProtocol>, perform: @escaping (InvitationDetailInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<InvitationDetailRouterProtocol>, perform: @escaping (InvitationDetailRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func set(dataSource: Parameter<InvitationDetailDataSourceProtocol>, perform: @escaping (InvitationDetailDataSourceProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__dataSource_dataSource(`dataSource`), performs: perform)
        }
        public static func set(invitation: Parameter<Appointment?>, isOutgoing: Parameter<Bool>, perform: @escaping (Appointment?, Bool) -> Void) -> Perform {
            return Perform(method: .m_set__invitation_invitationisOutgoing_isOutgoing(`invitation`, `isOutgoing`), performs: perform)
        }
        public static func display(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_display__error_error(`error`), performs: perform)
        }
        public static func displayCancelInvitationSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_displayCancelInvitationSuccess, performs: perform)
        }
        public static func displayCancelInvitationFailure(error: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayCancelInvitationFailure__error_error(`error`), performs: perform)
        }
        public static func displayProposedDate(dateString: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayProposedDate__dateString_dateString(`dateString`), performs: perform)
        }
        public static func displayProposedDatesIsEmpty(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_displayProposedDatesIsEmpty, performs: perform)
        }
        public static func didAdd(date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_didAdd__date_date(`date`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationSelectDateInteractorProtocol
open class InvitationSelectDateInteractorProtocolMock: InvitationSelectDateInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func setFinalDate(date: AppointmentDate) {
        addInvocation(.m_setFinalDate__date_date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_setFinalDate__date_date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }


    fileprivate enum MethodType {
        case m_setFinalDate__date_date(Parameter<AppointmentDate>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_setFinalDate__date_date(let lhsDate), .m_setFinalDate__date_date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_setFinalDate__date_date(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func setFinalDate(date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_setFinalDate__date_date(`date`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func setFinalDate(date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_setFinalDate__date_date(`date`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationSelectDatePresenterProtocol
open class InvitationSelectDatePresenterProtocolMock: InvitationSelectDatePresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: InvitationSelectDateViewControllerProtocol) {
        addInvocation(.m_set__viewController_viewController(Parameter<InvitationSelectDateViewControllerProtocol>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<InvitationSelectDateViewControllerProtocol>.value(`viewController`))) as? (InvitationSelectDateViewControllerProtocol) -> Void
		perform?(`viewController`)
    }

    open func presentSetFinalDateSuccess(_ date: AppointmentDate) {
        addInvocation(.m_presentSetFinalDateSuccess__date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_presentSetFinalDateSuccess__date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<InvitationSelectDateViewControllerProtocol>)
        case m_presentSetFinalDateSuccess__date(Parameter<AppointmentDate>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_presentSetFinalDateSuccess__date(let lhsDate), .m_presentSetFinalDateSuccess__date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_presentSetFinalDateSuccess__date(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<InvitationSelectDateViewControllerProtocol>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func presentSetFinalDateSuccess(_ date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_presentSetFinalDateSuccess__date(`date`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<InvitationSelectDateViewControllerProtocol>, perform: @escaping (InvitationSelectDateViewControllerProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func presentSetFinalDateSuccess(_ date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_presentSetFinalDateSuccess__date(`date`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationSelectDateRouterProtocol
open class InvitationSelectDateRouterProtocolMock: InvitationSelectDateRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: InvitationSelectDateViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<InvitationSelectDateViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<InvitationSelectDateViewControllerProtocol?>.value(`viewController`))) as? (InvitationSelectDateViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: InvitationSelectDateRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<InvitationSelectDateRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<InvitationSelectDateRouter.Scene>.value(`scene`))) as? (InvitationSelectDateRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<InvitationSelectDateViewControllerProtocol?>)
        case m_route__to_scene(Parameter<InvitationSelectDateRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<InvitationSelectDateViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<InvitationSelectDateRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<InvitationSelectDateViewControllerProtocol?>, perform: @escaping (InvitationSelectDateViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<InvitationSelectDateRouter.Scene>, perform: @escaping (InvitationSelectDateRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationSelectDateViewControllerProtocol
open class InvitationSelectDateViewControllerProtocolMock: InvitationSelectDateViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: InvitationSelectDateInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<InvitationSelectDateInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<InvitationSelectDateInteractorProtocol>.value(`interactor`))) as? (InvitationSelectDateInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: InvitationSelectDateRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<InvitationSelectDateRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<InvitationSelectDateRouterProtocol>.value(`router`))) as? (InvitationSelectDateRouterProtocol) -> Void
		perform?(`router`)
    }

    open func set(dataSource: InvitationSelectDataSourceProtocol) {
        addInvocation(.m_set__dataSource_dataSource(Parameter<InvitationSelectDataSourceProtocol>.value(`dataSource`)))
		let perform = methodPerformValue(.m_set__dataSource_dataSource(Parameter<InvitationSelectDataSourceProtocol>.value(`dataSource`))) as? (InvitationSelectDataSourceProtocol) -> Void
		perform?(`dataSource`)
    }

    open func set(appointment: Appointment) {
        addInvocation(.m_set__appointment_appointment(Parameter<Appointment>.value(`appointment`)))
		let perform = methodPerformValue(.m_set__appointment_appointment(Parameter<Appointment>.value(`appointment`))) as? (Appointment) -> Void
		perform?(`appointment`)
    }

    open func set(appointmentDateViewModelProvider: AppointmentViewModelProviderProtocol) {
        addInvocation(.m_set__appointmentDateViewModelProvider_appointmentDateViewModelProvider(Parameter<AppointmentViewModelProviderProtocol>.value(`appointmentDateViewModelProvider`)))
		let perform = methodPerformValue(.m_set__appointmentDateViewModelProvider_appointmentDateViewModelProvider(Parameter<AppointmentViewModelProviderProtocol>.value(`appointmentDateViewModelProvider`))) as? (AppointmentViewModelProviderProtocol) -> Void
		perform?(`appointmentDateViewModelProvider`)
    }

    open func set(delegate: FinalDateDelegateProtocol?) {
        addInvocation(.m_set__delegate_delegate(Parameter<FinalDateDelegateProtocol?>.value(`delegate`)))
		let perform = methodPerformValue(.m_set__delegate_delegate(Parameter<FinalDateDelegateProtocol?>.value(`delegate`))) as? (FinalDateDelegateProtocol?) -> Void
		perform?(`delegate`)
    }

    open func displaySelectFinalDate(_ date: AppointmentDate) {
        addInvocation(.m_displaySelectFinalDate__date(Parameter<AppointmentDate>.value(`date`)))
		let perform = methodPerformValue(.m_displaySelectFinalDate__date(Parameter<AppointmentDate>.value(`date`))) as? (AppointmentDate) -> Void
		perform?(`date`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<InvitationSelectDateInteractorProtocol>)
        case m_set__router_router(Parameter<InvitationSelectDateRouterProtocol>)
        case m_set__dataSource_dataSource(Parameter<InvitationSelectDataSourceProtocol>)
        case m_set__appointment_appointment(Parameter<Appointment>)
        case m_set__appointmentDateViewModelProvider_appointmentDateViewModelProvider(Parameter<AppointmentViewModelProviderProtocol>)
        case m_set__delegate_delegate(Parameter<FinalDateDelegateProtocol?>)
        case m_displaySelectFinalDate__date(Parameter<AppointmentDate>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_set__dataSource_dataSource(let lhsDatasource), .m_set__dataSource_dataSource(let rhsDatasource)):
                guard Parameter.compare(lhs: lhsDatasource, rhs: rhsDatasource, with: matcher) else { return false } 
                return true 
            case (.m_set__appointment_appointment(let lhsAppointment), .m_set__appointment_appointment(let rhsAppointment)):
                guard Parameter.compare(lhs: lhsAppointment, rhs: rhsAppointment, with: matcher) else { return false } 
                return true 
            case (.m_set__appointmentDateViewModelProvider_appointmentDateViewModelProvider(let lhsAppointmentdateviewmodelprovider), .m_set__appointmentDateViewModelProvider_appointmentDateViewModelProvider(let rhsAppointmentdateviewmodelprovider)):
                guard Parameter.compare(lhs: lhsAppointmentdateviewmodelprovider, rhs: rhsAppointmentdateviewmodelprovider, with: matcher) else { return false } 
                return true 
            case (.m_set__delegate_delegate(let lhsDelegate), .m_set__delegate_delegate(let rhsDelegate)):
                guard Parameter.compare(lhs: lhsDelegate, rhs: rhsDelegate, with: matcher) else { return false } 
                return true 
            case (.m_displaySelectFinalDate__date(let lhsDate), .m_displaySelectFinalDate__date(let rhsDate)):
                guard Parameter.compare(lhs: lhsDate, rhs: rhsDate, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_set__dataSource_dataSource(p0): return p0.intValue
            case let .m_set__appointment_appointment(p0): return p0.intValue
            case let .m_set__appointmentDateViewModelProvider_appointmentDateViewModelProvider(p0): return p0.intValue
            case let .m_set__delegate_delegate(p0): return p0.intValue
            case let .m_displaySelectFinalDate__date(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<InvitationSelectDateInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<InvitationSelectDateRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func set(dataSource: Parameter<InvitationSelectDataSourceProtocol>) -> Verify { return Verify(method: .m_set__dataSource_dataSource(`dataSource`))}
        public static func set(appointment: Parameter<Appointment>) -> Verify { return Verify(method: .m_set__appointment_appointment(`appointment`))}
        public static func set(appointmentDateViewModelProvider: Parameter<AppointmentViewModelProviderProtocol>) -> Verify { return Verify(method: .m_set__appointmentDateViewModelProvider_appointmentDateViewModelProvider(`appointmentDateViewModelProvider`))}
        public static func set(delegate: Parameter<FinalDateDelegateProtocol?>) -> Verify { return Verify(method: .m_set__delegate_delegate(`delegate`))}
        public static func displaySelectFinalDate(_ date: Parameter<AppointmentDate>) -> Verify { return Verify(method: .m_displaySelectFinalDate__date(`date`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<InvitationSelectDateInteractorProtocol>, perform: @escaping (InvitationSelectDateInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<InvitationSelectDateRouterProtocol>, perform: @escaping (InvitationSelectDateRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func set(dataSource: Parameter<InvitationSelectDataSourceProtocol>, perform: @escaping (InvitationSelectDataSourceProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__dataSource_dataSource(`dataSource`), performs: perform)
        }
        public static func set(appointment: Parameter<Appointment>, perform: @escaping (Appointment) -> Void) -> Perform {
            return Perform(method: .m_set__appointment_appointment(`appointment`), performs: perform)
        }
        public static func set(appointmentDateViewModelProvider: Parameter<AppointmentViewModelProviderProtocol>, perform: @escaping (AppointmentViewModelProviderProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__appointmentDateViewModelProvider_appointmentDateViewModelProvider(`appointmentDateViewModelProvider`), performs: perform)
        }
        public static func set(delegate: Parameter<FinalDateDelegateProtocol?>, perform: @escaping (FinalDateDelegateProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__delegate_delegate(`delegate`), performs: perform)
        }
        public static func displaySelectFinalDate(_ date: Parameter<AppointmentDate>, perform: @escaping (AppointmentDate) -> Void) -> Perform {
            return Perform(method: .m_displaySelectFinalDate__date(`date`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - InvitationServiceProtocol
open class InvitationServiceProtocolMock: InvitationServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func getInvitations(_ completion: @escaping RequestCompletion<[Appointment]>) {
        addInvocation(.m_getInvitations__completion(Parameter<RequestCompletion<[Appointment]>>.any))
		let perform = methodPerformValue(.m_getInvitations__completion(Parameter<RequestCompletion<[Appointment]>>.any)) as? (@escaping RequestCompletion<[Appointment]>) -> Void
		perform?(`completion`)
    }

    open func cancelAsCreator(invitationId: Int, _ completion: @escaping RequestCompletion<Void>) {
        addInvocation(.m_cancelAsCreator__invitationId_invitationId_completion(Parameter<Int>.value(`invitationId`), Parameter<RequestCompletion<Void>>.any))
		let perform = methodPerformValue(.m_cancelAsCreator__invitationId_invitationId_completion(Parameter<Int>.value(`invitationId`), Parameter<RequestCompletion<Void>>.any)) as? (Int, @escaping RequestCompletion<Void>) -> Void
		perform?(`invitationId`, `completion`)
    }

    open func cancelAsInvitee(invitationId: Int, _ completion: @escaping RequestCompletion<Void>) {
        addInvocation(.m_cancelAsInvitee__invitationId_invitationId_completion(Parameter<Int>.value(`invitationId`), Parameter<RequestCompletion<Void>>.any))
		let perform = methodPerformValue(.m_cancelAsInvitee__invitationId_invitationId_completion(Parameter<Int>.value(`invitationId`), Parameter<RequestCompletion<Void>>.any)) as? (Int, @escaping RequestCompletion<Void>) -> Void
		perform?(`invitationId`, `completion`)
    }


    fileprivate enum MethodType {
        case m_getInvitations__completion(Parameter<RequestCompletion<[Appointment]>>)
        case m_cancelAsCreator__invitationId_invitationId_completion(Parameter<Int>, Parameter<RequestCompletion<Void>>)
        case m_cancelAsInvitee__invitationId_invitationId_completion(Parameter<Int>, Parameter<RequestCompletion<Void>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_getInvitations__completion(let lhsCompletion), .m_getInvitations__completion(let rhsCompletion)):
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_cancelAsCreator__invitationId_invitationId_completion(let lhsInvitationid, let lhsCompletion), .m_cancelAsCreator__invitationId_invitationId_completion(let rhsInvitationid, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsInvitationid, rhs: rhsInvitationid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_cancelAsInvitee__invitationId_invitationId_completion(let lhsInvitationid, let lhsCompletion), .m_cancelAsInvitee__invitationId_invitationId_completion(let rhsInvitationid, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsInvitationid, rhs: rhsInvitationid, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_getInvitations__completion(p0): return p0.intValue
            case let .m_cancelAsCreator__invitationId_invitationId_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_cancelAsInvitee__invitationId_invitationId_completion(p0, p1): return p0.intValue + p1.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func getInvitations(_ completion: Parameter<RequestCompletion<[Appointment]>>) -> Verify { return Verify(method: .m_getInvitations__completion(`completion`))}
        public static func cancelAsCreator(invitationId: Parameter<Int>, _ completion: Parameter<RequestCompletion<Void>>) -> Verify { return Verify(method: .m_cancelAsCreator__invitationId_invitationId_completion(`invitationId`, `completion`))}
        public static func cancelAsInvitee(invitationId: Parameter<Int>, _ completion: Parameter<RequestCompletion<Void>>) -> Verify { return Verify(method: .m_cancelAsInvitee__invitationId_invitationId_completion(`invitationId`, `completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func getInvitations(_ completion: Parameter<RequestCompletion<[Appointment]>>, perform: @escaping (@escaping RequestCompletion<[Appointment]>) -> Void) -> Perform {
            return Perform(method: .m_getInvitations__completion(`completion`), performs: perform)
        }
        public static func cancelAsCreator(invitationId: Parameter<Int>, _ completion: Parameter<RequestCompletion<Void>>, perform: @escaping (Int, @escaping RequestCompletion<Void>) -> Void) -> Perform {
            return Perform(method: .m_cancelAsCreator__invitationId_invitationId_completion(`invitationId`, `completion`), performs: perform)
        }
        public static func cancelAsInvitee(invitationId: Parameter<Int>, _ completion: Parameter<RequestCompletion<Void>>, perform: @escaping (Int, @escaping RequestCompletion<Void>) -> Void) -> Perform {
            return Perform(method: .m_cancelAsInvitee__invitationId_invitationId_completion(`invitationId`, `completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - LoginInteractorProtocol
open class LoginInteractorProtocolMock: LoginInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func validateFields(email: String?, password: String?) {
        addInvocation(.m_validateFields__email_emailpassword_password(Parameter<String?>.value(`email`), Parameter<String?>.value(`password`)))
		let perform = methodPerformValue(.m_validateFields__email_emailpassword_password(Parameter<String?>.value(`email`), Parameter<String?>.value(`password`))) as? (String?, String?) -> Void
		perform?(`email`, `password`)
    }


    fileprivate enum MethodType {
        case m_validateFields__email_emailpassword_password(Parameter<String?>, Parameter<String?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_validateFields__email_emailpassword_password(let lhsEmail, let lhsPassword), .m_validateFields__email_emailpassword_password(let rhsEmail, let rhsPassword)):
                guard Parameter.compare(lhs: lhsEmail, rhs: rhsEmail, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsPassword, rhs: rhsPassword, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_validateFields__email_emailpassword_password(p0, p1): return p0.intValue + p1.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func validateFields(email: Parameter<String?>, password: Parameter<String?>) -> Verify { return Verify(method: .m_validateFields__email_emailpassword_password(`email`, `password`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func validateFields(email: Parameter<String?>, password: Parameter<String?>, perform: @escaping (String?, String?) -> Void) -> Perform {
            return Perform(method: .m_validateFields__email_emailpassword_password(`email`, `password`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - LoginOverviewRouterProtocol
open class LoginOverviewRouterProtocolMock: LoginOverviewRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: LoginOverviewViewControllerProtocol) {
        addInvocation(.m_set__viewController_viewController(Parameter<LoginOverviewViewControllerProtocol>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<LoginOverviewViewControllerProtocol>.value(`viewController`))) as? (LoginOverviewViewControllerProtocol) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: LoginOverviewRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<LoginOverviewRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<LoginOverviewRouter.Scene>.value(`scene`))) as? (LoginOverviewRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<LoginOverviewViewControllerProtocol>)
        case m_route__to_scene(Parameter<LoginOverviewRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<LoginOverviewViewControllerProtocol>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<LoginOverviewRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<LoginOverviewViewControllerProtocol>, perform: @escaping (LoginOverviewViewControllerProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<LoginOverviewRouter.Scene>, perform: @escaping (LoginOverviewRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - LoginOverviewViewControllerProtocol
open class LoginOverviewViewControllerProtocolMock: LoginOverviewViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(router: LoginOverviewRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<LoginOverviewRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<LoginOverviewRouterProtocol>.value(`router`))) as? (LoginOverviewRouterProtocol) -> Void
		perform?(`router`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__router_router(Parameter<LoginOverviewRouterProtocol>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(router: Parameter<LoginOverviewRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(router: Parameter<LoginOverviewRouterProtocol>, perform: @escaping (LoginOverviewRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - LoginPresenterProtocol
open class LoginPresenterProtocolMock: LoginPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: LoginViewControllerProtocol) {
        addInvocation(.m_set__viewController_viewController(Parameter<LoginViewControllerProtocol>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<LoginViewControllerProtocol>.value(`viewController`))) as? (LoginViewControllerProtocol) -> Void
		perform?(`viewController`)
    }

    open func presentInvalidData(_ error: DataValidationError) {
        addInvocation(.m_presentInvalidData__error(Parameter<DataValidationError>.value(`error`)))
		let perform = methodPerformValue(.m_presentInvalidData__error(Parameter<DataValidationError>.value(`error`))) as? (DataValidationError) -> Void
		perform?(`error`)
    }

    open func presentLoginSuccess() {
        addInvocation(.m_presentLoginSuccess)
		let perform = methodPerformValue(.m_presentLoginSuccess) as? () -> Void
		perform?()
    }

    open func presentLoginError() {
        addInvocation(.m_presentLoginError)
		let perform = methodPerformValue(.m_presentLoginError) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<LoginViewControllerProtocol>)
        case m_presentInvalidData__error(Parameter<DataValidationError>)
        case m_presentLoginSuccess
        case m_presentLoginError

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_presentInvalidData__error(let lhsError), .m_presentInvalidData__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_presentLoginSuccess, .m_presentLoginSuccess):
                return true 
            case (.m_presentLoginError, .m_presentLoginError):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_presentInvalidData__error(p0): return p0.intValue
            case .m_presentLoginSuccess: return 0
            case .m_presentLoginError: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<LoginViewControllerProtocol>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func presentInvalidData(_ error: Parameter<DataValidationError>) -> Verify { return Verify(method: .m_presentInvalidData__error(`error`))}
        public static func presentLoginSuccess() -> Verify { return Verify(method: .m_presentLoginSuccess)}
        public static func presentLoginError() -> Verify { return Verify(method: .m_presentLoginError)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<LoginViewControllerProtocol>, perform: @escaping (LoginViewControllerProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func presentInvalidData(_ error: Parameter<DataValidationError>, perform: @escaping (DataValidationError) -> Void) -> Perform {
            return Perform(method: .m_presentInvalidData__error(`error`), performs: perform)
        }
        public static func presentLoginSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentLoginSuccess, performs: perform)
        }
        public static func presentLoginError(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentLoginError, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - LoginRouterProtocol
open class LoginRouterProtocolMock: LoginRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: LoginViewControllerProtocol) {
        addInvocation(.m_set__viewController_viewController(Parameter<LoginViewControllerProtocol>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<LoginViewControllerProtocol>.value(`viewController`))) as? (LoginViewControllerProtocol) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: LoginRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<LoginRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<LoginRouter.Scene>.value(`scene`))) as? (LoginRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<LoginViewControllerProtocol>)
        case m_route__to_scene(Parameter<LoginRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<LoginViewControllerProtocol>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<LoginRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<LoginViewControllerProtocol>, perform: @escaping (LoginViewControllerProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<LoginRouter.Scene>, perform: @escaping (LoginRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - LoginViewControllerProtocol
open class LoginViewControllerProtocolMock: LoginViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: LoginInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<LoginInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<LoginInteractorProtocol>.value(`interactor`))) as? (LoginInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: LoginRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<LoginRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<LoginRouterProtocol>.value(`router`))) as? (LoginRouterProtocol) -> Void
		perform?(`router`)
    }

    open func set(alertPresenter: AlertPresenterProtocol) {
        addInvocation(.m_set__alertPresenter_alertPresenter(Parameter<AlertPresenterProtocol>.value(`alertPresenter`)))
		let perform = methodPerformValue(.m_set__alertPresenter_alertPresenter(Parameter<AlertPresenterProtocol>.value(`alertPresenter`))) as? (AlertPresenterProtocol) -> Void
		perform?(`alertPresenter`)
    }

    open func displayGeneric(error: String) {
        addInvocation(.m_displayGeneric__error_error(Parameter<String>.value(`error`)))
		let perform = methodPerformValue(.m_displayGeneric__error_error(Parameter<String>.value(`error`))) as? (String) -> Void
		perform?(`error`)
    }

    open func displayInvalidEmail(error: String) {
        addInvocation(.m_displayInvalidEmail__error_error(Parameter<String>.value(`error`)))
		let perform = methodPerformValue(.m_displayInvalidEmail__error_error(Parameter<String>.value(`error`))) as? (String) -> Void
		perform?(`error`)
    }

    open func displayInvalidPassword(error: String) {
        addInvocation(.m_displayInvalidPassword__error_error(Parameter<String>.value(`error`)))
		let perform = methodPerformValue(.m_displayInvalidPassword__error_error(Parameter<String>.value(`error`))) as? (String) -> Void
		perform?(`error`)
    }

    open func handleLoginSuccess() {
        addInvocation(.m_handleLoginSuccess)
		let perform = methodPerformValue(.m_handleLoginSuccess) as? () -> Void
		perform?()
    }

    open func handleLoginFailure(error: String) {
        addInvocation(.m_handleLoginFailure__error_error(Parameter<String>.value(`error`)))
		let perform = methodPerformValue(.m_handleLoginFailure__error_error(Parameter<String>.value(`error`))) as? (String) -> Void
		perform?(`error`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<LoginInteractorProtocol>)
        case m_set__router_router(Parameter<LoginRouterProtocol>)
        case m_set__alertPresenter_alertPresenter(Parameter<AlertPresenterProtocol>)
        case m_displayGeneric__error_error(Parameter<String>)
        case m_displayInvalidEmail__error_error(Parameter<String>)
        case m_displayInvalidPassword__error_error(Parameter<String>)
        case m_handleLoginSuccess
        case m_handleLoginFailure__error_error(Parameter<String>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_set__alertPresenter_alertPresenter(let lhsAlertpresenter), .m_set__alertPresenter_alertPresenter(let rhsAlertpresenter)):
                guard Parameter.compare(lhs: lhsAlertpresenter, rhs: rhsAlertpresenter, with: matcher) else { return false } 
                return true 
            case (.m_displayGeneric__error_error(let lhsError), .m_displayGeneric__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayInvalidEmail__error_error(let lhsError), .m_displayInvalidEmail__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayInvalidPassword__error_error(let lhsError), .m_displayInvalidPassword__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_handleLoginSuccess, .m_handleLoginSuccess):
                return true 
            case (.m_handleLoginFailure__error_error(let lhsError), .m_handleLoginFailure__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_set__alertPresenter_alertPresenter(p0): return p0.intValue
            case let .m_displayGeneric__error_error(p0): return p0.intValue
            case let .m_displayInvalidEmail__error_error(p0): return p0.intValue
            case let .m_displayInvalidPassword__error_error(p0): return p0.intValue
            case .m_handleLoginSuccess: return 0
            case let .m_handleLoginFailure__error_error(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<LoginInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<LoginRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func set(alertPresenter: Parameter<AlertPresenterProtocol>) -> Verify { return Verify(method: .m_set__alertPresenter_alertPresenter(`alertPresenter`))}
        public static func displayGeneric(error: Parameter<String>) -> Verify { return Verify(method: .m_displayGeneric__error_error(`error`))}
        public static func displayInvalidEmail(error: Parameter<String>) -> Verify { return Verify(method: .m_displayInvalidEmail__error_error(`error`))}
        public static func displayInvalidPassword(error: Parameter<String>) -> Verify { return Verify(method: .m_displayInvalidPassword__error_error(`error`))}
        public static func handleLoginSuccess() -> Verify { return Verify(method: .m_handleLoginSuccess)}
        public static func handleLoginFailure(error: Parameter<String>) -> Verify { return Verify(method: .m_handleLoginFailure__error_error(`error`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<LoginInteractorProtocol>, perform: @escaping (LoginInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<LoginRouterProtocol>, perform: @escaping (LoginRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func set(alertPresenter: Parameter<AlertPresenterProtocol>, perform: @escaping (AlertPresenterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__alertPresenter_alertPresenter(`alertPresenter`), performs: perform)
        }
        public static func displayGeneric(error: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayGeneric__error_error(`error`), performs: perform)
        }
        public static func displayInvalidEmail(error: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayInvalidEmail__error_error(`error`), performs: perform)
        }
        public static func displayInvalidPassword(error: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayInvalidPassword__error_error(`error`), performs: perform)
        }
        public static func handleLoginSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_handleLoginSuccess, performs: perform)
        }
        public static func handleLoginFailure(error: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_handleLoginFailure__error_error(`error`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - OutGoingInteractorProtocol
open class OutGoingInteractorProtocolMock: OutGoingInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func getInvitations() {
        addInvocation(.m_getInvitations)
		let perform = methodPerformValue(.m_getInvitations) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_getInvitations

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_getInvitations, .m_getInvitations):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_getInvitations: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func getInvitations() -> Verify { return Verify(method: .m_getInvitations)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func getInvitations(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_getInvitations, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - OutGoingPresenterProtocol
open class OutGoingPresenterProtocolMock: OutGoingPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: OutGoingViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<OutGoingViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<OutGoingViewControllerProtocol?>.value(`viewController`))) as? (OutGoingViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func present(outGoingDataSource: [Appointment]) {
        addInvocation(.m_present__outGoingDataSource_outGoingDataSource(Parameter<[Appointment]>.value(`outGoingDataSource`)))
		let perform = methodPerformValue(.m_present__outGoingDataSource_outGoingDataSource(Parameter<[Appointment]>.value(`outGoingDataSource`))) as? ([Appointment]) -> Void
		perform?(`outGoingDataSource`)
    }

    open func presentLoadingView(display: Bool) {
        addInvocation(.m_presentLoadingView__display_display(Parameter<Bool>.value(`display`)))
		let perform = methodPerformValue(.m_presentLoadingView__display_display(Parameter<Bool>.value(`display`))) as? (Bool) -> Void
		perform?(`display`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<OutGoingViewControllerProtocol?>)
        case m_present__outGoingDataSource_outGoingDataSource(Parameter<[Appointment]>)
        case m_presentLoadingView__display_display(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_present__outGoingDataSource_outGoingDataSource(let lhsOutgoingdatasource), .m_present__outGoingDataSource_outGoingDataSource(let rhsOutgoingdatasource)):
                guard Parameter.compare(lhs: lhsOutgoingdatasource, rhs: rhsOutgoingdatasource, with: matcher) else { return false } 
                return true 
            case (.m_presentLoadingView__display_display(let lhsDisplay), .m_presentLoadingView__display_display(let rhsDisplay)):
                guard Parameter.compare(lhs: lhsDisplay, rhs: rhsDisplay, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_present__outGoingDataSource_outGoingDataSource(p0): return p0.intValue
            case let .m_presentLoadingView__display_display(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<OutGoingViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func present(outGoingDataSource: Parameter<[Appointment]>) -> Verify { return Verify(method: .m_present__outGoingDataSource_outGoingDataSource(`outGoingDataSource`))}
        public static func presentLoadingView(display: Parameter<Bool>) -> Verify { return Verify(method: .m_presentLoadingView__display_display(`display`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<OutGoingViewControllerProtocol?>, perform: @escaping (OutGoingViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func present(outGoingDataSource: Parameter<[Appointment]>, perform: @escaping ([Appointment]) -> Void) -> Perform {
            return Perform(method: .m_present__outGoingDataSource_outGoingDataSource(`outGoingDataSource`), performs: perform)
        }
        public static func presentLoadingView(display: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_presentLoadingView__display_display(`display`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - OutGoingRouterProtocol
open class OutGoingRouterProtocolMock: OutGoingRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: OutGoingViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<OutGoingViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<OutGoingViewControllerProtocol?>.value(`viewController`))) as? (OutGoingViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: OutGoingRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<OutGoingRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<OutGoingRouter.Scene>.value(`scene`))) as? (OutGoingRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<OutGoingViewControllerProtocol?>)
        case m_route__to_scene(Parameter<OutGoingRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<OutGoingViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<OutGoingRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<OutGoingViewControllerProtocol?>, perform: @escaping (OutGoingViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<OutGoingRouter.Scene>, perform: @escaping (OutGoingRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - OutGoingViewControllerProtocol
open class OutGoingViewControllerProtocolMock: OutGoingViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: OutGoingInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<OutGoingInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<OutGoingInteractorProtocol>.value(`interactor`))) as? (OutGoingInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: OutGoingRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<OutGoingRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<OutGoingRouterProtocol>.value(`router`))) as? (OutGoingRouterProtocol) -> Void
		perform?(`router`)
    }

    open func set(outGoingDataSource: [Appointment]) {
        addInvocation(.m_set__outGoingDataSource_outGoingDataSource(Parameter<[Appointment]>.value(`outGoingDataSource`)))
		let perform = methodPerformValue(.m_set__outGoingDataSource_outGoingDataSource(Parameter<[Appointment]>.value(`outGoingDataSource`))) as? ([Appointment]) -> Void
		perform?(`outGoingDataSource`)
    }

    open func displayLoadingView(display: Bool) {
        addInvocation(.m_displayLoadingView__display_display(Parameter<Bool>.value(`display`)))
		let perform = methodPerformValue(.m_displayLoadingView__display_display(Parameter<Bool>.value(`display`))) as? (Bool) -> Void
		perform?(`display`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<OutGoingInteractorProtocol>)
        case m_set__router_router(Parameter<OutGoingRouterProtocol>)
        case m_set__outGoingDataSource_outGoingDataSource(Parameter<[Appointment]>)
        case m_displayLoadingView__display_display(Parameter<Bool>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_set__outGoingDataSource_outGoingDataSource(let lhsOutgoingdatasource), .m_set__outGoingDataSource_outGoingDataSource(let rhsOutgoingdatasource)):
                guard Parameter.compare(lhs: lhsOutgoingdatasource, rhs: rhsOutgoingdatasource, with: matcher) else { return false } 
                return true 
            case (.m_displayLoadingView__display_display(let lhsDisplay), .m_displayLoadingView__display_display(let rhsDisplay)):
                guard Parameter.compare(lhs: lhsDisplay, rhs: rhsDisplay, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_set__outGoingDataSource_outGoingDataSource(p0): return p0.intValue
            case let .m_displayLoadingView__display_display(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<OutGoingInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<OutGoingRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func set(outGoingDataSource: Parameter<[Appointment]>) -> Verify { return Verify(method: .m_set__outGoingDataSource_outGoingDataSource(`outGoingDataSource`))}
        public static func displayLoadingView(display: Parameter<Bool>) -> Verify { return Verify(method: .m_displayLoadingView__display_display(`display`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<OutGoingInteractorProtocol>, perform: @escaping (OutGoingInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<OutGoingRouterProtocol>, perform: @escaping (OutGoingRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func set(outGoingDataSource: Parameter<[Appointment]>, perform: @escaping ([Appointment]) -> Void) -> Perform {
            return Perform(method: .m_set__outGoingDataSource_outGoingDataSource(`outGoingDataSource`), performs: perform)
        }
        public static func displayLoadingView(display: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_displayLoadingView__display_display(`display`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - RegisterInteractorProtocol
open class RegisterInteractorProtocolMock: RegisterInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func handleRegister(registerRequest: RegisterRequest, profileImage: UIImage?) {
        addInvocation(.m_handleRegister__registerRequest_registerRequestprofileImage_profileImage(Parameter<RegisterRequest>.value(`registerRequest`), Parameter<UIImage?>.value(`profileImage`)))
		let perform = methodPerformValue(.m_handleRegister__registerRequest_registerRequestprofileImage_profileImage(Parameter<RegisterRequest>.value(`registerRequest`), Parameter<UIImage?>.value(`profileImage`))) as? (RegisterRequest, UIImage?) -> Void
		perform?(`registerRequest`, `profileImage`)
    }

    open func imageSelected(image: UIImage) {
        addInvocation(.m_imageSelected__image_image(Parameter<UIImage>.value(`image`)))
		let perform = methodPerformValue(.m_imageSelected__image_image(Parameter<UIImage>.value(`image`))) as? (UIImage) -> Void
		perform?(`image`)
    }


    fileprivate enum MethodType {
        case m_handleRegister__registerRequest_registerRequestprofileImage_profileImage(Parameter<RegisterRequest>, Parameter<UIImage?>)
        case m_imageSelected__image_image(Parameter<UIImage>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_handleRegister__registerRequest_registerRequestprofileImage_profileImage(let lhsRegisterrequest, let lhsProfileimage), .m_handleRegister__registerRequest_registerRequestprofileImage_profileImage(let rhsRegisterrequest, let rhsProfileimage)):
                guard Parameter.compare(lhs: lhsRegisterrequest, rhs: rhsRegisterrequest, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsProfileimage, rhs: rhsProfileimage, with: matcher) else { return false } 
                return true 
            case (.m_imageSelected__image_image(let lhsImage), .m_imageSelected__image_image(let rhsImage)):
                guard Parameter.compare(lhs: lhsImage, rhs: rhsImage, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_handleRegister__registerRequest_registerRequestprofileImage_profileImage(p0, p1): return p0.intValue + p1.intValue
            case let .m_imageSelected__image_image(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func handleRegister(registerRequest: Parameter<RegisterRequest>, profileImage: Parameter<UIImage?>) -> Verify { return Verify(method: .m_handleRegister__registerRequest_registerRequestprofileImage_profileImage(`registerRequest`, `profileImage`))}
        public static func imageSelected(image: Parameter<UIImage>) -> Verify { return Verify(method: .m_imageSelected__image_image(`image`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func handleRegister(registerRequest: Parameter<RegisterRequest>, profileImage: Parameter<UIImage?>, perform: @escaping (RegisterRequest, UIImage?) -> Void) -> Perform {
            return Perform(method: .m_handleRegister__registerRequest_registerRequestprofileImage_profileImage(`registerRequest`, `profileImage`), performs: perform)
        }
        public static func imageSelected(image: Parameter<UIImage>, perform: @escaping (UIImage) -> Void) -> Perform {
            return Perform(method: .m_imageSelected__image_image(`image`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - RegisterPresenterProtocol
open class RegisterPresenterProtocolMock: RegisterPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: RegisterViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<RegisterViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<RegisterViewControllerProtocol?>.value(`viewController`))) as? (RegisterViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func presentInvalidData(_ error: DataValidationError) {
        addInvocation(.m_presentInvalidData__error(Parameter<DataValidationError>.value(`error`)))
		let perform = methodPerformValue(.m_presentInvalidData__error(Parameter<DataValidationError>.value(`error`))) as? (DataValidationError) -> Void
		perform?(`error`)
    }

    open func presentRegisterError(_ error: MoyaError) {
        addInvocation(.m_presentRegisterError__error(Parameter<MoyaError>.value(`error`)))
		let perform = methodPerformValue(.m_presentRegisterError__error(Parameter<MoyaError>.value(`error`))) as? (MoyaError) -> Void
		perform?(`error`)
    }

    open func presentLoginError(_ error: OAuth2Error) {
        addInvocation(.m_presentLoginError__error(Parameter<OAuth2Error>.value(`error`)))
		let perform = methodPerformValue(.m_presentLoginError__error(Parameter<OAuth2Error>.value(`error`))) as? (OAuth2Error) -> Void
		perform?(`error`)
    }

    open func presentLoginSuccess() {
        addInvocation(.m_presentLoginSuccess)
		let perform = methodPerformValue(.m_presentLoginSuccess) as? () -> Void
		perform?()
    }

    open func presentSelectedImage(image: UIImage) {
        addInvocation(.m_presentSelectedImage__image_image(Parameter<UIImage>.value(`image`)))
		let perform = methodPerformValue(.m_presentSelectedImage__image_image(Parameter<UIImage>.value(`image`))) as? (UIImage) -> Void
		perform?(`image`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<RegisterViewControllerProtocol?>)
        case m_presentInvalidData__error(Parameter<DataValidationError>)
        case m_presentRegisterError__error(Parameter<MoyaError>)
        case m_presentLoginError__error(Parameter<OAuth2Error>)
        case m_presentLoginSuccess
        case m_presentSelectedImage__image_image(Parameter<UIImage>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_presentInvalidData__error(let lhsError), .m_presentInvalidData__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_presentRegisterError__error(let lhsError), .m_presentRegisterError__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_presentLoginError__error(let lhsError), .m_presentLoginError__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_presentLoginSuccess, .m_presentLoginSuccess):
                return true 
            case (.m_presentSelectedImage__image_image(let lhsImage), .m_presentSelectedImage__image_image(let rhsImage)):
                guard Parameter.compare(lhs: lhsImage, rhs: rhsImage, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_presentInvalidData__error(p0): return p0.intValue
            case let .m_presentRegisterError__error(p0): return p0.intValue
            case let .m_presentLoginError__error(p0): return p0.intValue
            case .m_presentLoginSuccess: return 0
            case let .m_presentSelectedImage__image_image(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<RegisterViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func presentInvalidData(_ error: Parameter<DataValidationError>) -> Verify { return Verify(method: .m_presentInvalidData__error(`error`))}
        public static func presentRegisterError(_ error: Parameter<MoyaError>) -> Verify { return Verify(method: .m_presentRegisterError__error(`error`))}
        public static func presentLoginError(_ error: Parameter<OAuth2Error>) -> Verify { return Verify(method: .m_presentLoginError__error(`error`))}
        public static func presentLoginSuccess() -> Verify { return Verify(method: .m_presentLoginSuccess)}
        public static func presentSelectedImage(image: Parameter<UIImage>) -> Verify { return Verify(method: .m_presentSelectedImage__image_image(`image`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<RegisterViewControllerProtocol?>, perform: @escaping (RegisterViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func presentInvalidData(_ error: Parameter<DataValidationError>, perform: @escaping (DataValidationError) -> Void) -> Perform {
            return Perform(method: .m_presentInvalidData__error(`error`), performs: perform)
        }
        public static func presentRegisterError(_ error: Parameter<MoyaError>, perform: @escaping (MoyaError) -> Void) -> Perform {
            return Perform(method: .m_presentRegisterError__error(`error`), performs: perform)
        }
        public static func presentLoginError(_ error: Parameter<OAuth2Error>, perform: @escaping (OAuth2Error) -> Void) -> Perform {
            return Perform(method: .m_presentLoginError__error(`error`), performs: perform)
        }
        public static func presentLoginSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentLoginSuccess, performs: perform)
        }
        public static func presentSelectedImage(image: Parameter<UIImage>, perform: @escaping (UIImage) -> Void) -> Perform {
            return Perform(method: .m_presentSelectedImage__image_image(`image`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - RegisterRouterProtocol
open class RegisterRouterProtocolMock: RegisterRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: RegisterViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<RegisterViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<RegisterViewControllerProtocol?>.value(`viewController`))) as? (RegisterViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: RegisterRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<RegisterRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<RegisterRouter.Scene>.value(`scene`))) as? (RegisterRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<RegisterViewControllerProtocol?>)
        case m_route__to_scene(Parameter<RegisterRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<RegisterViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<RegisterRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<RegisterViewControllerProtocol?>, perform: @escaping (RegisterViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<RegisterRouter.Scene>, perform: @escaping (RegisterRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - RegisterServiceProtocol
open class RegisterServiceProtocolMock: RegisterServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func register(registerRequest: RegisterRequest, profileImage: UIImage?, _ completion: @escaping RequestCompletion<RegisterResponse>) {
        addInvocation(.m_register__registerRequest_registerRequestprofileImage_profileImage_completion(Parameter<RegisterRequest>.value(`registerRequest`), Parameter<UIImage?>.value(`profileImage`), Parameter<RequestCompletion<RegisterResponse>>.any))
		let perform = methodPerformValue(.m_register__registerRequest_registerRequestprofileImage_profileImage_completion(Parameter<RegisterRequest>.value(`registerRequest`), Parameter<UIImage?>.value(`profileImage`), Parameter<RequestCompletion<RegisterResponse>>.any)) as? (RegisterRequest, UIImage?, @escaping RequestCompletion<RegisterResponse>) -> Void
		perform?(`registerRequest`, `profileImage`, `completion`)
    }


    fileprivate enum MethodType {
        case m_register__registerRequest_registerRequestprofileImage_profileImage_completion(Parameter<RegisterRequest>, Parameter<UIImage?>, Parameter<RequestCompletion<RegisterResponse>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_register__registerRequest_registerRequestprofileImage_profileImage_completion(let lhsRegisterrequest, let lhsProfileimage, let lhsCompletion), .m_register__registerRequest_registerRequestprofileImage_profileImage_completion(let rhsRegisterrequest, let rhsProfileimage, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsRegisterrequest, rhs: rhsRegisterrequest, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsProfileimage, rhs: rhsProfileimage, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_register__registerRequest_registerRequestprofileImage_profileImage_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func register(registerRequest: Parameter<RegisterRequest>, profileImage: Parameter<UIImage?>, _ completion: Parameter<RequestCompletion<RegisterResponse>>) -> Verify { return Verify(method: .m_register__registerRequest_registerRequestprofileImage_profileImage_completion(`registerRequest`, `profileImage`, `completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func register(registerRequest: Parameter<RegisterRequest>, profileImage: Parameter<UIImage?>, _ completion: Parameter<RequestCompletion<RegisterResponse>>, perform: @escaping (RegisterRequest, UIImage?, @escaping RequestCompletion<RegisterResponse>) -> Void) -> Perform {
            return Perform(method: .m_register__registerRequest_registerRequestprofileImage_profileImage_completion(`registerRequest`, `profileImage`, `completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - RegisterViewControllerProtocol
open class RegisterViewControllerProtocolMock: RegisterViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: RegisterInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<RegisterInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<RegisterInteractorProtocol>.value(`interactor`))) as? (RegisterInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: RegisterRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<RegisterRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<RegisterRouterProtocol>.value(`router`))) as? (RegisterRouterProtocol) -> Void
		perform?(`router`)
    }

    open func set(alert: AlertPresenterProtocol) {
        addInvocation(.m_set__alert_alert(Parameter<AlertPresenterProtocol>.value(`alert`)))
		let perform = methodPerformValue(.m_set__alert_alert(Parameter<AlertPresenterProtocol>.value(`alert`))) as? (AlertPresenterProtocol) -> Void
		perform?(`alert`)
    }

    open func displaySelectedImage(image: UIImage) {
        addInvocation(.m_displaySelectedImage__image_image(Parameter<UIImage>.value(`image`)))
		let perform = methodPerformValue(.m_displaySelectedImage__image_image(Parameter<UIImage>.value(`image`))) as? (UIImage) -> Void
		perform?(`image`)
    }

    open func displayFieldError(_ error: DataValidationError) {
        addInvocation(.m_displayFieldError__error(Parameter<DataValidationError>.value(`error`)))
		let perform = methodPerformValue(.m_displayFieldError__error(Parameter<DataValidationError>.value(`error`))) as? (DataValidationError) -> Void
		perform?(`error`)
    }

    open func displayRegisterError(_ title: String?, _ error: String?) {
        addInvocation(.m_displayRegisterError__title_error(Parameter<String?>.value(`title`), Parameter<String?>.value(`error`)))
		let perform = methodPerformValue(.m_displayRegisterError__title_error(Parameter<String?>.value(`title`), Parameter<String?>.value(`error`))) as? (String?, String?) -> Void
		perform?(`title`, `error`)
    }

    open func displayLoginError(_ error: String) {
        addInvocation(.m_displayLoginError__error(Parameter<String>.value(`error`)))
		let perform = methodPerformValue(.m_displayLoginError__error(Parameter<String>.value(`error`))) as? (String) -> Void
		perform?(`error`)
    }

    open func displayLoginSuccess() {
        addInvocation(.m_displayLoginSuccess)
		let perform = methodPerformValue(.m_displayLoginSuccess) as? () -> Void
		perform?()
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<RegisterInteractorProtocol>)
        case m_set__router_router(Parameter<RegisterRouterProtocol>)
        case m_set__alert_alert(Parameter<AlertPresenterProtocol>)
        case m_displaySelectedImage__image_image(Parameter<UIImage>)
        case m_displayFieldError__error(Parameter<DataValidationError>)
        case m_displayRegisterError__title_error(Parameter<String?>, Parameter<String?>)
        case m_displayLoginError__error(Parameter<String>)
        case m_displayLoginSuccess
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_set__alert_alert(let lhsAlert), .m_set__alert_alert(let rhsAlert)):
                guard Parameter.compare(lhs: lhsAlert, rhs: rhsAlert, with: matcher) else { return false } 
                return true 
            case (.m_displaySelectedImage__image_image(let lhsImage), .m_displaySelectedImage__image_image(let rhsImage)):
                guard Parameter.compare(lhs: lhsImage, rhs: rhsImage, with: matcher) else { return false } 
                return true 
            case (.m_displayFieldError__error(let lhsError), .m_displayFieldError__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayRegisterError__title_error(let lhsTitle, let lhsError), .m_displayRegisterError__title_error(let rhsTitle, let rhsError)):
                guard Parameter.compare(lhs: lhsTitle, rhs: rhsTitle, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayLoginError__error(let lhsError), .m_displayLoginError__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayLoginSuccess, .m_displayLoginSuccess):
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_set__alert_alert(p0): return p0.intValue
            case let .m_displaySelectedImage__image_image(p0): return p0.intValue
            case let .m_displayFieldError__error(p0): return p0.intValue
            case let .m_displayRegisterError__title_error(p0, p1): return p0.intValue + p1.intValue
            case let .m_displayLoginError__error(p0): return p0.intValue
            case .m_displayLoginSuccess: return 0
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<RegisterInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<RegisterRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func set(alert: Parameter<AlertPresenterProtocol>) -> Verify { return Verify(method: .m_set__alert_alert(`alert`))}
        public static func displaySelectedImage(image: Parameter<UIImage>) -> Verify { return Verify(method: .m_displaySelectedImage__image_image(`image`))}
        public static func displayFieldError(_ error: Parameter<DataValidationError>) -> Verify { return Verify(method: .m_displayFieldError__error(`error`))}
        public static func displayRegisterError(_ title: Parameter<String?>, _ error: Parameter<String?>) -> Verify { return Verify(method: .m_displayRegisterError__title_error(`title`, `error`))}
        public static func displayLoginError(_ error: Parameter<String>) -> Verify { return Verify(method: .m_displayLoginError__error(`error`))}
        public static func displayLoginSuccess() -> Verify { return Verify(method: .m_displayLoginSuccess)}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<RegisterInteractorProtocol>, perform: @escaping (RegisterInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<RegisterRouterProtocol>, perform: @escaping (RegisterRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func set(alert: Parameter<AlertPresenterProtocol>, perform: @escaping (AlertPresenterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__alert_alert(`alert`), performs: perform)
        }
        public static func displaySelectedImage(image: Parameter<UIImage>, perform: @escaping (UIImage) -> Void) -> Perform {
            return Perform(method: .m_displaySelectedImage__image_image(`image`), performs: perform)
        }
        public static func displayFieldError(_ error: Parameter<DataValidationError>, perform: @escaping (DataValidationError) -> Void) -> Perform {
            return Perform(method: .m_displayFieldError__error(`error`), performs: perform)
        }
        public static func displayRegisterError(_ title: Parameter<String?>, _ error: Parameter<String?>, perform: @escaping (String?, String?) -> Void) -> Perform {
            return Perform(method: .m_displayRegisterError__title_error(`title`, `error`), performs: perform)
        }
        public static func displayLoginError(_ error: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayLoginError__error(`error`), performs: perform)
        }
        public static func displayLoginSuccess(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_displayLoginSuccess, performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - RootNavigatorProtocol
open class RootNavigatorProtocolMock: RootNavigatorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func setRootViewController() {
        addInvocation(.m_setRootViewController)
		let perform = methodPerformValue(.m_setRootViewController) as? () -> Void
		perform?()
    }

    open func setSideMenuRoot(contentViewController: UIViewController) {
        addInvocation(.m_setSideMenuRoot__contentViewController_contentViewController(Parameter<UIViewController>.value(`contentViewController`)))
		let perform = methodPerformValue(.m_setSideMenuRoot__contentViewController_contentViewController(Parameter<UIViewController>.value(`contentViewController`))) as? (UIViewController) -> Void
		perform?(`contentViewController`)
    }


    fileprivate enum MethodType {
        case m_setRootViewController
        case m_setSideMenuRoot__contentViewController_contentViewController(Parameter<UIViewController>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_setRootViewController, .m_setRootViewController):
                return true 
            case (.m_setSideMenuRoot__contentViewController_contentViewController(let lhsContentviewcontroller), .m_setSideMenuRoot__contentViewController_contentViewController(let rhsContentviewcontroller)):
                guard Parameter.compare(lhs: lhsContentviewcontroller, rhs: rhsContentviewcontroller, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_setRootViewController: return 0
            case let .m_setSideMenuRoot__contentViewController_contentViewController(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func setRootViewController() -> Verify { return Verify(method: .m_setRootViewController)}
        public static func setSideMenuRoot(contentViewController: Parameter<UIViewController>) -> Verify { return Verify(method: .m_setSideMenuRoot__contentViewController_contentViewController(`contentViewController`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func setRootViewController(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_setRootViewController, performs: perform)
        }
        public static func setSideMenuRoot(contentViewController: Parameter<UIViewController>, perform: @escaping (UIViewController) -> Void) -> Perform {
            return Perform(method: .m_setSideMenuRoot__contentViewController_contentViewController(`contentViewController`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingsDataServiceProtocol
open class SettingsDataServiceProtocolMock: SettingsDataServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func sync(settings: Settings, _ completion: @escaping RequestLocalCompletion<SettingsEntity>) {
        addInvocation(.m_sync__settings_settings_completion(Parameter<Settings>.value(`settings`), Parameter<RequestLocalCompletion<SettingsEntity>>.any))
		let perform = methodPerformValue(.m_sync__settings_settings_completion(Parameter<Settings>.value(`settings`), Parameter<RequestLocalCompletion<SettingsEntity>>.any)) as? (Settings, @escaping RequestLocalCompletion<SettingsEntity>) -> Void
		perform?(`settings`, `completion`)
    }

    open func fetch(_ completion: @escaping RequestLocalCompletion<SettingsEntity>) {
        addInvocation(.m_fetch__completion(Parameter<RequestLocalCompletion<SettingsEntity>>.any))
		let perform = methodPerformValue(.m_fetch__completion(Parameter<RequestLocalCompletion<SettingsEntity>>.any)) as? (@escaping RequestLocalCompletion<SettingsEntity>) -> Void
		perform?(`completion`)
    }

    open func reset() {
        addInvocation(.m_reset)
		let perform = methodPerformValue(.m_reset) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_sync__settings_settings_completion(Parameter<Settings>, Parameter<RequestLocalCompletion<SettingsEntity>>)
        case m_fetch__completion(Parameter<RequestLocalCompletion<SettingsEntity>>)
        case m_reset

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_sync__settings_settings_completion(let lhsSettings, let lhsCompletion), .m_sync__settings_settings_completion(let rhsSettings, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsSettings, rhs: rhsSettings, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_fetch__completion(let lhsCompletion), .m_fetch__completion(let rhsCompletion)):
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_reset, .m_reset):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_sync__settings_settings_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_fetch__completion(p0): return p0.intValue
            case .m_reset: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func sync(settings: Parameter<Settings>, _ completion: Parameter<RequestLocalCompletion<SettingsEntity>>) -> Verify { return Verify(method: .m_sync__settings_settings_completion(`settings`, `completion`))}
        public static func fetch(_ completion: Parameter<RequestLocalCompletion<SettingsEntity>>) -> Verify { return Verify(method: .m_fetch__completion(`completion`))}
        public static func reset() -> Verify { return Verify(method: .m_reset)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func sync(settings: Parameter<Settings>, _ completion: Parameter<RequestLocalCompletion<SettingsEntity>>, perform: @escaping (Settings, @escaping RequestLocalCompletion<SettingsEntity>) -> Void) -> Perform {
            return Perform(method: .m_sync__settings_settings_completion(`settings`, `completion`), performs: perform)
        }
        public static func fetch(_ completion: Parameter<RequestLocalCompletion<SettingsEntity>>, perform: @escaping (@escaping RequestLocalCompletion<SettingsEntity>) -> Void) -> Perform {
            return Perform(method: .m_fetch__completion(`completion`), performs: perform)
        }
        public static func reset(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_reset, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingsInteractorProtocol
open class SettingsInteractorProtocolMock: SettingsInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func handleViewDidLoad() {
        addInvocation(.m_handleViewDidLoad)
		let perform = methodPerformValue(.m_handleViewDidLoad) as? () -> Void
		perform?()
    }

    open func getUser() {
        addInvocation(.m_getUser)
		let perform = methodPerformValue(.m_getUser) as? () -> Void
		perform?()
    }

    open func update(settings: Settings) {
        addInvocation(.m_update__settings_settings(Parameter<Settings>.value(`settings`)))
		let perform = methodPerformValue(.m_update__settings_settings(Parameter<Settings>.value(`settings`))) as? (Settings) -> Void
		perform?(`settings`)
    }

    open func logoutUser() {
        addInvocation(.m_logoutUser)
		let perform = methodPerformValue(.m_logoutUser) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_handleViewDidLoad
        case m_getUser
        case m_update__settings_settings(Parameter<Settings>)
        case m_logoutUser

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_handleViewDidLoad, .m_handleViewDidLoad):
                return true 
            case (.m_getUser, .m_getUser):
                return true 
            case (.m_update__settings_settings(let lhsSettings), .m_update__settings_settings(let rhsSettings)):
                guard Parameter.compare(lhs: lhsSettings, rhs: rhsSettings, with: matcher) else { return false } 
                return true 
            case (.m_logoutUser, .m_logoutUser):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_handleViewDidLoad: return 0
            case .m_getUser: return 0
            case let .m_update__settings_settings(p0): return p0.intValue
            case .m_logoutUser: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func handleViewDidLoad() -> Verify { return Verify(method: .m_handleViewDidLoad)}
        public static func getUser() -> Verify { return Verify(method: .m_getUser)}
        public static func update(settings: Parameter<Settings>) -> Verify { return Verify(method: .m_update__settings_settings(`settings`))}
        public static func logoutUser() -> Verify { return Verify(method: .m_logoutUser)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func handleViewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_handleViewDidLoad, performs: perform)
        }
        public static func getUser(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_getUser, performs: perform)
        }
        public static func update(settings: Parameter<Settings>, perform: @escaping (Settings) -> Void) -> Perform {
            return Perform(method: .m_update__settings_settings(`settings`), performs: perform)
        }
        public static func logoutUser(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_logoutUser, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingsPresenterProtocol
open class SettingsPresenterProtocolMock: SettingsPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: SettingsViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<SettingsViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<SettingsViewControllerProtocol?>.value(`viewController`))) as? (SettingsViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func presentData(authenticatedUserStatus: Bool) {
        addInvocation(.m_presentData__authenticatedUserStatus_authenticatedUserStatus(Parameter<Bool>.value(`authenticatedUserStatus`)))
		let perform = methodPerformValue(.m_presentData__authenticatedUserStatus_authenticatedUserStatus(Parameter<Bool>.value(`authenticatedUserStatus`))) as? (Bool) -> Void
		perform?(`authenticatedUserStatus`)
    }

    open func present(settings: Settings) {
        addInvocation(.m_present__settings_settings(Parameter<Settings>.value(`settings`)))
		let perform = methodPerformValue(.m_present__settings_settings(Parameter<Settings>.value(`settings`))) as? (Settings) -> Void
		perform?(`settings`)
    }

    open func presentLogout() {
        addInvocation(.m_presentLogout)
		let perform = methodPerformValue(.m_presentLogout) as? () -> Void
		perform?()
    }

    open func presentUserToLogout(email: String) {
        addInvocation(.m_presentUserToLogout__email_email(Parameter<String>.value(`email`)))
		let perform = methodPerformValue(.m_presentUserToLogout__email_email(Parameter<String>.value(`email`))) as? (String) -> Void
		perform?(`email`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<SettingsViewControllerProtocol?>)
        case m_presentData__authenticatedUserStatus_authenticatedUserStatus(Parameter<Bool>)
        case m_present__settings_settings(Parameter<Settings>)
        case m_presentLogout
        case m_presentUserToLogout__email_email(Parameter<String>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_presentData__authenticatedUserStatus_authenticatedUserStatus(let lhsAuthenticateduserstatus), .m_presentData__authenticatedUserStatus_authenticatedUserStatus(let rhsAuthenticateduserstatus)):
                guard Parameter.compare(lhs: lhsAuthenticateduserstatus, rhs: rhsAuthenticateduserstatus, with: matcher) else { return false } 
                return true 
            case (.m_present__settings_settings(let lhsSettings), .m_present__settings_settings(let rhsSettings)):
                guard Parameter.compare(lhs: lhsSettings, rhs: rhsSettings, with: matcher) else { return false } 
                return true 
            case (.m_presentLogout, .m_presentLogout):
                return true 
            case (.m_presentUserToLogout__email_email(let lhsEmail), .m_presentUserToLogout__email_email(let rhsEmail)):
                guard Parameter.compare(lhs: lhsEmail, rhs: rhsEmail, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_presentData__authenticatedUserStatus_authenticatedUserStatus(p0): return p0.intValue
            case let .m_present__settings_settings(p0): return p0.intValue
            case .m_presentLogout: return 0
            case let .m_presentUserToLogout__email_email(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<SettingsViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func presentData(authenticatedUserStatus: Parameter<Bool>) -> Verify { return Verify(method: .m_presentData__authenticatedUserStatus_authenticatedUserStatus(`authenticatedUserStatus`))}
        public static func present(settings: Parameter<Settings>) -> Verify { return Verify(method: .m_present__settings_settings(`settings`))}
        public static func presentLogout() -> Verify { return Verify(method: .m_presentLogout)}
        public static func presentUserToLogout(email: Parameter<String>) -> Verify { return Verify(method: .m_presentUserToLogout__email_email(`email`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<SettingsViewControllerProtocol?>, perform: @escaping (SettingsViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func presentData(authenticatedUserStatus: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_presentData__authenticatedUserStatus_authenticatedUserStatus(`authenticatedUserStatus`), performs: perform)
        }
        public static func present(settings: Parameter<Settings>, perform: @escaping (Settings) -> Void) -> Perform {
            return Perform(method: .m_present__settings_settings(`settings`), performs: perform)
        }
        public static func presentLogout(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentLogout, performs: perform)
        }
        public static func presentUserToLogout(email: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_presentUserToLogout__email_email(`email`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingsRouterProtocol
open class SettingsRouterProtocolMock: SettingsRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: SettingsViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<SettingsViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<SettingsViewControllerProtocol?>.value(`viewController`))) as? (SettingsViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: SettingsRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<SettingsRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<SettingsRouter.Scene>.value(`scene`))) as? (SettingsRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<SettingsViewControllerProtocol?>)
        case m_route__to_scene(Parameter<SettingsRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<SettingsViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<SettingsRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<SettingsViewControllerProtocol?>, perform: @escaping (SettingsViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<SettingsRouter.Scene>, perform: @escaping (SettingsRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingsServiceProtocol
open class SettingsServiceProtocolMock: SettingsServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }

    public var isUserLoggedIn: Bool {
		get {	invocations.append(.p_isUserLoggedIn_get); return __p_isUserLoggedIn ?? givenGetterValue(.p_isUserLoggedIn_get, "SettingsServiceProtocolMock - stub value for isUserLoggedIn was not defined") }
		@available(*, deprecated, message: "Using setters on readonly variables is deprecated, and will be removed in 3.1. Use Given to define stubbed property return value.")
		set {	__p_isUserLoggedIn = newValue }
	}
	private var __p_isUserLoggedIn: (Bool)?





    open func getSettings(_ completion: @escaping RequestCompletion<Settings>) {
        addInvocation(.m_getSettings__completion(Parameter<RequestCompletion<Settings>>.any))
		let perform = methodPerformValue(.m_getSettings__completion(Parameter<RequestCompletion<Settings>>.any)) as? (@escaping RequestCompletion<Settings>) -> Void
		perform?(`completion`)
    }

    open func updateSettings(settings: Settings, _ completion: @escaping RequestCompletion<Settings>) {
        addInvocation(.m_updateSettings__settings_settings_completion(Parameter<Settings>.value(`settings`), Parameter<RequestCompletion<Settings>>.any))
		let perform = methodPerformValue(.m_updateSettings__settings_settings_completion(Parameter<Settings>.value(`settings`), Parameter<RequestCompletion<Settings>>.any)) as? (Settings, @escaping RequestCompletion<Settings>) -> Void
		perform?(`settings`, `completion`)
    }


    fileprivate enum MethodType {
        case m_getSettings__completion(Parameter<RequestCompletion<Settings>>)
        case m_updateSettings__settings_settings_completion(Parameter<Settings>, Parameter<RequestCompletion<Settings>>)
        case p_isUserLoggedIn_get

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_getSettings__completion(let lhsCompletion), .m_getSettings__completion(let rhsCompletion)):
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_updateSettings__settings_settings_completion(let lhsSettings, let lhsCompletion), .m_updateSettings__settings_settings_completion(let rhsSettings, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsSettings, rhs: rhsSettings, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.p_isUserLoggedIn_get,.p_isUserLoggedIn_get): return true
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_getSettings__completion(p0): return p0.intValue
            case let .m_updateSettings__settings_settings_completion(p0, p1): return p0.intValue + p1.intValue
            case .p_isUserLoggedIn_get: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }

        public static func isUserLoggedIn(getter defaultValue: Bool...) -> PropertyStub {
            return Given(method: .p_isUserLoggedIn_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }

    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func getSettings(_ completion: Parameter<RequestCompletion<Settings>>) -> Verify { return Verify(method: .m_getSettings__completion(`completion`))}
        public static func updateSettings(settings: Parameter<Settings>, _ completion: Parameter<RequestCompletion<Settings>>) -> Verify { return Verify(method: .m_updateSettings__settings_settings_completion(`settings`, `completion`))}
        public static var isUserLoggedIn: Verify { return Verify(method: .p_isUserLoggedIn_get) }
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func getSettings(_ completion: Parameter<RequestCompletion<Settings>>, perform: @escaping (@escaping RequestCompletion<Settings>) -> Void) -> Perform {
            return Perform(method: .m_getSettings__completion(`completion`), performs: perform)
        }
        public static func updateSettings(settings: Parameter<Settings>, _ completion: Parameter<RequestCompletion<Settings>>, perform: @escaping (Settings, @escaping RequestCompletion<Settings>) -> Void) -> Perform {
            return Perform(method: .m_updateSettings__settings_settings_completion(`settings`, `completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingsViewControllerProtocol
open class SettingsViewControllerProtocolMock: SettingsViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: SettingsInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<SettingsInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<SettingsInteractorProtocol>.value(`interactor`))) as? (SettingsInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: SettingsRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<SettingsRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<SettingsRouterProtocol>.value(`router`))) as? (SettingsRouterProtocol) -> Void
		perform?(`router`)
    }

    open func displayData(authenticatedUserStatus: Bool) {
        addInvocation(.m_displayData__authenticatedUserStatus_authenticatedUserStatus(Parameter<Bool>.value(`authenticatedUserStatus`)))
		let perform = methodPerformValue(.m_displayData__authenticatedUserStatus_authenticatedUserStatus(Parameter<Bool>.value(`authenticatedUserStatus`))) as? (Bool) -> Void
		perform?(`authenticatedUserStatus`)
    }

    open func display(settings: Settings) {
        addInvocation(.m_display__settings_settings(Parameter<Settings>.value(`settings`)))
		let perform = methodPerformValue(.m_display__settings_settings(Parameter<Settings>.value(`settings`))) as? (Settings) -> Void
		perform?(`settings`)
    }

    open func displayLogoutPopout(email: String) {
        addInvocation(.m_displayLogoutPopout__email_email(Parameter<String>.value(`email`)))
		let perform = methodPerformValue(.m_displayLogoutPopout__email_email(Parameter<String>.value(`email`))) as? (String) -> Void
		perform?(`email`)
    }

    open func displayLogout() {
        addInvocation(.m_displayLogout)
		let perform = methodPerformValue(.m_displayLogout) as? () -> Void
		perform?()
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<SettingsInteractorProtocol>)
        case m_set__router_router(Parameter<SettingsRouterProtocol>)
        case m_displayData__authenticatedUserStatus_authenticatedUserStatus(Parameter<Bool>)
        case m_display__settings_settings(Parameter<Settings>)
        case m_displayLogoutPopout__email_email(Parameter<String>)
        case m_displayLogout
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_displayData__authenticatedUserStatus_authenticatedUserStatus(let lhsAuthenticateduserstatus), .m_displayData__authenticatedUserStatus_authenticatedUserStatus(let rhsAuthenticateduserstatus)):
                guard Parameter.compare(lhs: lhsAuthenticateduserstatus, rhs: rhsAuthenticateduserstatus, with: matcher) else { return false } 
                return true 
            case (.m_display__settings_settings(let lhsSettings), .m_display__settings_settings(let rhsSettings)):
                guard Parameter.compare(lhs: lhsSettings, rhs: rhsSettings, with: matcher) else { return false } 
                return true 
            case (.m_displayLogoutPopout__email_email(let lhsEmail), .m_displayLogoutPopout__email_email(let rhsEmail)):
                guard Parameter.compare(lhs: lhsEmail, rhs: rhsEmail, with: matcher) else { return false } 
                return true 
            case (.m_displayLogout, .m_displayLogout):
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_displayData__authenticatedUserStatus_authenticatedUserStatus(p0): return p0.intValue
            case let .m_display__settings_settings(p0): return p0.intValue
            case let .m_displayLogoutPopout__email_email(p0): return p0.intValue
            case .m_displayLogout: return 0
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<SettingsInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<SettingsRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func displayData(authenticatedUserStatus: Parameter<Bool>) -> Verify { return Verify(method: .m_displayData__authenticatedUserStatus_authenticatedUserStatus(`authenticatedUserStatus`))}
        public static func display(settings: Parameter<Settings>) -> Verify { return Verify(method: .m_display__settings_settings(`settings`))}
        public static func displayLogoutPopout(email: Parameter<String>) -> Verify { return Verify(method: .m_displayLogoutPopout__email_email(`email`))}
        public static func displayLogout() -> Verify { return Verify(method: .m_displayLogout)}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<SettingsInteractorProtocol>, perform: @escaping (SettingsInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<SettingsRouterProtocol>, perform: @escaping (SettingsRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func displayData(authenticatedUserStatus: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_displayData__authenticatedUserStatus_authenticatedUserStatus(`authenticatedUserStatus`), performs: perform)
        }
        public static func display(settings: Parameter<Settings>, perform: @escaping (Settings) -> Void) -> Perform {
            return Perform(method: .m_display__settings_settings(`settings`), performs: perform)
        }
        public static func displayLogoutPopout(email: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_displayLogoutPopout__email_email(`email`), performs: perform)
        }
        public static func displayLogout(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_displayLogout, performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SideMenuInteractorProtocol
open class SideMenuInteractorProtocolMock: SideMenuInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func checkAuthRequired(for scene: SideMenuRouter.Scene) {
        addInvocation(.m_checkAuthRequired__for_scene(Parameter<SideMenuRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_checkAuthRequired__for_scene(Parameter<SideMenuRouter.Scene>.value(`scene`))) as? (SideMenuRouter.Scene) -> Void
		perform?(`scene`)
    }

    open func handleViewWillAppear() {
        addInvocation(.m_handleViewWillAppear)
		let perform = methodPerformValue(.m_handleViewWillAppear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_checkAuthRequired__for_scene(Parameter<SideMenuRouter.Scene>)
        case m_handleViewWillAppear

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_checkAuthRequired__for_scene(let lhsScene), .m_checkAuthRequired__for_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            case (.m_handleViewWillAppear, .m_handleViewWillAppear):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_checkAuthRequired__for_scene(p0): return p0.intValue
            case .m_handleViewWillAppear: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func checkAuthRequired(for scene: Parameter<SideMenuRouter.Scene>) -> Verify { return Verify(method: .m_checkAuthRequired__for_scene(`scene`))}
        public static func handleViewWillAppear() -> Verify { return Verify(method: .m_handleViewWillAppear)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func checkAuthRequired(for scene: Parameter<SideMenuRouter.Scene>, perform: @escaping (SideMenuRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_checkAuthRequired__for_scene(`scene`), performs: perform)
        }
        public static func handleViewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_handleViewWillAppear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SideMenuPresenterProtocol
open class SideMenuPresenterProtocolMock: SideMenuPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: SideMenuViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<SideMenuViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<SideMenuViewControllerProtocol?>.value(`viewController`))) as? (SideMenuViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func present(user: UserProfile) {
        addInvocation(.m_present__user_user(Parameter<UserProfile>.value(`user`)))
		let perform = methodPerformValue(.m_present__user_user(Parameter<UserProfile>.value(`user`))) as? (UserProfile) -> Void
		perform?(`user`)
    }

    open func present(events: [AppEvent]) {
        addInvocation(.m_present__events_events(Parameter<[AppEvent]>.value(`events`)))
		let perform = methodPerformValue(.m_present__events_events(Parameter<[AppEvent]>.value(`events`))) as? ([AppEvent]) -> Void
		perform?(`events`)
    }

    open func present(appointmentData: [Appointment]) {
        addInvocation(.m_present__appointmentData_appointmentData(Parameter<[Appointment]>.value(`appointmentData`)))
		let perform = methodPerformValue(.m_present__appointmentData_appointmentData(Parameter<[Appointment]>.value(`appointmentData`))) as? ([Appointment]) -> Void
		perform?(`appointmentData`)
    }

    open func resetSubItemData() {
        addInvocation(.m_resetSubItemData)
		let perform = methodPerformValue(.m_resetSubItemData) as? () -> Void
		perform?()
    }

    open func handleRoutingEnabled(for scene: SideMenuRouter.Scene) {
        addInvocation(.m_handleRoutingEnabled__for_scene(Parameter<SideMenuRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_handleRoutingEnabled__for_scene(Parameter<SideMenuRouter.Scene>.value(`scene`))) as? (SideMenuRouter.Scene) -> Void
		perform?(`scene`)
    }

    open func handleUserIsAnon(error: SideMenuError) {
        addInvocation(.m_handleUserIsAnon__error_error(Parameter<SideMenuError>.value(`error`)))
		let perform = methodPerformValue(.m_handleUserIsAnon__error_error(Parameter<SideMenuError>.value(`error`))) as? (SideMenuError) -> Void
		perform?(`error`)
    }

    open func handle(error: Error) {
        addInvocation(.m_handle__error_error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_handle__error_error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<SideMenuViewControllerProtocol?>)
        case m_present__user_user(Parameter<UserProfile>)
        case m_present__events_events(Parameter<[AppEvent]>)
        case m_present__appointmentData_appointmentData(Parameter<[Appointment]>)
        case m_resetSubItemData
        case m_handleRoutingEnabled__for_scene(Parameter<SideMenuRouter.Scene>)
        case m_handleUserIsAnon__error_error(Parameter<SideMenuError>)
        case m_handle__error_error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_present__user_user(let lhsUser), .m_present__user_user(let rhsUser)):
                guard Parameter.compare(lhs: lhsUser, rhs: rhsUser, with: matcher) else { return false } 
                return true 
            case (.m_present__events_events(let lhsEvents), .m_present__events_events(let rhsEvents)):
                guard Parameter.compare(lhs: lhsEvents, rhs: rhsEvents, with: matcher) else { return false } 
                return true 
            case (.m_present__appointmentData_appointmentData(let lhsAppointmentdata), .m_present__appointmentData_appointmentData(let rhsAppointmentdata)):
                guard Parameter.compare(lhs: lhsAppointmentdata, rhs: rhsAppointmentdata, with: matcher) else { return false } 
                return true 
            case (.m_resetSubItemData, .m_resetSubItemData):
                return true 
            case (.m_handleRoutingEnabled__for_scene(let lhsScene), .m_handleRoutingEnabled__for_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            case (.m_handleUserIsAnon__error_error(let lhsError), .m_handleUserIsAnon__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_handle__error_error(let lhsError), .m_handle__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_present__user_user(p0): return p0.intValue
            case let .m_present__events_events(p0): return p0.intValue
            case let .m_present__appointmentData_appointmentData(p0): return p0.intValue
            case .m_resetSubItemData: return 0
            case let .m_handleRoutingEnabled__for_scene(p0): return p0.intValue
            case let .m_handleUserIsAnon__error_error(p0): return p0.intValue
            case let .m_handle__error_error(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<SideMenuViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func present(user: Parameter<UserProfile>) -> Verify { return Verify(method: .m_present__user_user(`user`))}
        public static func present(events: Parameter<[AppEvent]>) -> Verify { return Verify(method: .m_present__events_events(`events`))}
        public static func present(appointmentData: Parameter<[Appointment]>) -> Verify { return Verify(method: .m_present__appointmentData_appointmentData(`appointmentData`))}
        public static func resetSubItemData() -> Verify { return Verify(method: .m_resetSubItemData)}
        public static func handleRoutingEnabled(for scene: Parameter<SideMenuRouter.Scene>) -> Verify { return Verify(method: .m_handleRoutingEnabled__for_scene(`scene`))}
        public static func handleUserIsAnon(error: Parameter<SideMenuError>) -> Verify { return Verify(method: .m_handleUserIsAnon__error_error(`error`))}
        public static func handle(error: Parameter<Error>) -> Verify { return Verify(method: .m_handle__error_error(`error`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<SideMenuViewControllerProtocol?>, perform: @escaping (SideMenuViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func present(user: Parameter<UserProfile>, perform: @escaping (UserProfile) -> Void) -> Perform {
            return Perform(method: .m_present__user_user(`user`), performs: perform)
        }
        public static func present(events: Parameter<[AppEvent]>, perform: @escaping ([AppEvent]) -> Void) -> Perform {
            return Perform(method: .m_present__events_events(`events`), performs: perform)
        }
        public static func present(appointmentData: Parameter<[Appointment]>, perform: @escaping ([Appointment]) -> Void) -> Perform {
            return Perform(method: .m_present__appointmentData_appointmentData(`appointmentData`), performs: perform)
        }
        public static func resetSubItemData(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_resetSubItemData, performs: perform)
        }
        public static func handleRoutingEnabled(for scene: Parameter<SideMenuRouter.Scene>, perform: @escaping (SideMenuRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_handleRoutingEnabled__for_scene(`scene`), performs: perform)
        }
        public static func handleUserIsAnon(error: Parameter<SideMenuError>, perform: @escaping (SideMenuError) -> Void) -> Perform {
            return Perform(method: .m_handleUserIsAnon__error_error(`error`), performs: perform)
        }
        public static func handle(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_handle__error_error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SideMenuRouterProtocol
open class SideMenuRouterProtocolMock: SideMenuRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: SideMenuViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<SideMenuViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<SideMenuViewControllerProtocol?>.value(`viewController`))) as? (SideMenuViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: SideMenuRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<SideMenuRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<SideMenuRouter.Scene>.value(`scene`))) as? (SideMenuRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<SideMenuViewControllerProtocol?>)
        case m_route__to_scene(Parameter<SideMenuRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<SideMenuViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<SideMenuRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<SideMenuViewControllerProtocol?>, perform: @escaping (SideMenuViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<SideMenuRouter.Scene>, perform: @escaping (SideMenuRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SideMenuViewControllerProtocol
open class SideMenuViewControllerProtocolMock: SideMenuViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: SideMenuInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<SideMenuInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<SideMenuInteractorProtocol>.value(`interactor`))) as? (SideMenuInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: SideMenuRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<SideMenuRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<SideMenuRouterProtocol>.value(`router`))) as? (SideMenuRouterProtocol) -> Void
		perform?(`router`)
    }

    open func display(user: UserProfile) {
        addInvocation(.m_display__user_user(Parameter<UserProfile>.value(`user`)))
		let perform = methodPerformValue(.m_display__user_user(Parameter<UserProfile>.value(`user`))) as? (UserProfile) -> Void
		perform?(`user`)
    }

    open func display(events: [AppEvent]) {
        addInvocation(.m_display__events_events(Parameter<[AppEvent]>.value(`events`)))
		let perform = methodPerformValue(.m_display__events_events(Parameter<[AppEvent]>.value(`events`))) as? ([AppEvent]) -> Void
		perform?(`events`)
    }

    open func display(appointmentData: [Appointment]) {
        addInvocation(.m_display__appointmentData_appointmentData(Parameter<[Appointment]>.value(`appointmentData`)))
		let perform = methodPerformValue(.m_display__appointmentData_appointmentData(Parameter<[Appointment]>.value(`appointmentData`))) as? ([Appointment]) -> Void
		perform?(`appointmentData`)
    }

    open func resetSubItemData() {
        addInvocation(.m_resetSubItemData)
		let perform = methodPerformValue(.m_resetSubItemData) as? () -> Void
		perform?()
    }

    open func handleRoutingEnabled(for scene: SideMenuRouter.Scene) {
        addInvocation(.m_handleRoutingEnabled__for_scene(Parameter<SideMenuRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_handleRoutingEnabled__for_scene(Parameter<SideMenuRouter.Scene>.value(`scene`))) as? (SideMenuRouter.Scene) -> Void
		perform?(`scene`)
    }

    open func handleUserIsAnon(_ error: SideMenuError) {
        addInvocation(.m_handleUserIsAnon__error(Parameter<SideMenuError>.value(`error`)))
		let perform = methodPerformValue(.m_handleUserIsAnon__error(Parameter<SideMenuError>.value(`error`))) as? (SideMenuError) -> Void
		perform?(`error`)
    }

    open func display(error: Error) {
        addInvocation(.m_display__error_error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_display__error_error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<SideMenuInteractorProtocol>)
        case m_set__router_router(Parameter<SideMenuRouterProtocol>)
        case m_display__user_user(Parameter<UserProfile>)
        case m_display__events_events(Parameter<[AppEvent]>)
        case m_display__appointmentData_appointmentData(Parameter<[Appointment]>)
        case m_resetSubItemData
        case m_handleRoutingEnabled__for_scene(Parameter<SideMenuRouter.Scene>)
        case m_handleUserIsAnon__error(Parameter<SideMenuError>)
        case m_display__error_error(Parameter<Error>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_display__user_user(let lhsUser), .m_display__user_user(let rhsUser)):
                guard Parameter.compare(lhs: lhsUser, rhs: rhsUser, with: matcher) else { return false } 
                return true 
            case (.m_display__events_events(let lhsEvents), .m_display__events_events(let rhsEvents)):
                guard Parameter.compare(lhs: lhsEvents, rhs: rhsEvents, with: matcher) else { return false } 
                return true 
            case (.m_display__appointmentData_appointmentData(let lhsAppointmentdata), .m_display__appointmentData_appointmentData(let rhsAppointmentdata)):
                guard Parameter.compare(lhs: lhsAppointmentdata, rhs: rhsAppointmentdata, with: matcher) else { return false } 
                return true 
            case (.m_resetSubItemData, .m_resetSubItemData):
                return true 
            case (.m_handleRoutingEnabled__for_scene(let lhsScene), .m_handleRoutingEnabled__for_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            case (.m_handleUserIsAnon__error(let lhsError), .m_handleUserIsAnon__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_display__error_error(let lhsError), .m_display__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_display__user_user(p0): return p0.intValue
            case let .m_display__events_events(p0): return p0.intValue
            case let .m_display__appointmentData_appointmentData(p0): return p0.intValue
            case .m_resetSubItemData: return 0
            case let .m_handleRoutingEnabled__for_scene(p0): return p0.intValue
            case let .m_handleUserIsAnon__error(p0): return p0.intValue
            case let .m_display__error_error(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<SideMenuInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<SideMenuRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func display(user: Parameter<UserProfile>) -> Verify { return Verify(method: .m_display__user_user(`user`))}
        public static func display(events: Parameter<[AppEvent]>) -> Verify { return Verify(method: .m_display__events_events(`events`))}
        public static func display(appointmentData: Parameter<[Appointment]>) -> Verify { return Verify(method: .m_display__appointmentData_appointmentData(`appointmentData`))}
        public static func resetSubItemData() -> Verify { return Verify(method: .m_resetSubItemData)}
        public static func handleRoutingEnabled(for scene: Parameter<SideMenuRouter.Scene>) -> Verify { return Verify(method: .m_handleRoutingEnabled__for_scene(`scene`))}
        public static func handleUserIsAnon(_ error: Parameter<SideMenuError>) -> Verify { return Verify(method: .m_handleUserIsAnon__error(`error`))}
        public static func display(error: Parameter<Error>) -> Verify { return Verify(method: .m_display__error_error(`error`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<SideMenuInteractorProtocol>, perform: @escaping (SideMenuInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<SideMenuRouterProtocol>, perform: @escaping (SideMenuRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func display(user: Parameter<UserProfile>, perform: @escaping (UserProfile) -> Void) -> Perform {
            return Perform(method: .m_display__user_user(`user`), performs: perform)
        }
        public static func display(events: Parameter<[AppEvent]>, perform: @escaping ([AppEvent]) -> Void) -> Perform {
            return Perform(method: .m_display__events_events(`events`), performs: perform)
        }
        public static func display(appointmentData: Parameter<[Appointment]>, perform: @escaping ([Appointment]) -> Void) -> Perform {
            return Perform(method: .m_display__appointmentData_appointmentData(`appointmentData`), performs: perform)
        }
        public static func resetSubItemData(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_resetSubItemData, performs: perform)
        }
        public static func handleRoutingEnabled(for scene: Parameter<SideMenuRouter.Scene>, perform: @escaping (SideMenuRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_handleRoutingEnabled__for_scene(`scene`), performs: perform)
        }
        public static func handleUserIsAnon(_ error: Parameter<SideMenuError>, perform: @escaping (SideMenuError) -> Void) -> Perform {
            return Perform(method: .m_handleUserIsAnon__error(`error`), performs: perform)
        }
        public static func display(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_display__error_error(`error`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SplashScreenRouterProtocol
open class SplashScreenRouterProtocolMock: SplashScreenRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: SplashScreenViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<SplashScreenViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<SplashScreenViewControllerProtocol?>.value(`viewController`))) as? (SplashScreenViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: SplashScreenRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<SplashScreenRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<SplashScreenRouter.Scene>.value(`scene`))) as? (SplashScreenRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<SplashScreenViewControllerProtocol?>)
        case m_route__to_scene(Parameter<SplashScreenRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<SplashScreenViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<SplashScreenRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<SplashScreenViewControllerProtocol?>, perform: @escaping (SplashScreenViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<SplashScreenRouter.Scene>, perform: @escaping (SplashScreenRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SplashScreenViewControllerProtocol
open class SplashScreenViewControllerProtocolMock: SplashScreenViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(router: SplashScreenRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<SplashScreenRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<SplashScreenRouterProtocol>.value(`router`))) as? (SplashScreenRouterProtocol) -> Void
		perform?(`router`)
    }

    open func set(interactor: SplashScreenInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<SplashScreenInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<SplashScreenInteractorProtocol>.value(`interactor`))) as? (SplashScreenInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func display(isUserLoggedIn: Bool) {
        addInvocation(.m_display__isUserLoggedIn_isUserLoggedIn(Parameter<Bool>.value(`isUserLoggedIn`)))
		let perform = methodPerformValue(.m_display__isUserLoggedIn_isUserLoggedIn(Parameter<Bool>.value(`isUserLoggedIn`))) as? (Bool) -> Void
		perform?(`isUserLoggedIn`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__router_router(Parameter<SplashScreenRouterProtocol>)
        case m_set__interactor_interactor(Parameter<SplashScreenInteractorProtocol>)
        case m_display__isUserLoggedIn_isUserLoggedIn(Parameter<Bool>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_display__isUserLoggedIn_isUserLoggedIn(let lhsIsuserloggedin), .m_display__isUserLoggedIn_isUserLoggedIn(let rhsIsuserloggedin)):
                guard Parameter.compare(lhs: lhsIsuserloggedin, rhs: rhsIsuserloggedin, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_display__isUserLoggedIn_isUserLoggedIn(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(router: Parameter<SplashScreenRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func set(interactor: Parameter<SplashScreenInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func display(isUserLoggedIn: Parameter<Bool>) -> Verify { return Verify(method: .m_display__isUserLoggedIn_isUserLoggedIn(`isUserLoggedIn`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(router: Parameter<SplashScreenRouterProtocol>, perform: @escaping (SplashScreenRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func set(interactor: Parameter<SplashScreenInteractorProtocol>, perform: @escaping (SplashScreenInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func display(isUserLoggedIn: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_display__isUserLoggedIn_isUserLoggedIn(`isUserLoggedIn`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - Storyboard
open class StoryboardMock: Storyboard, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func initial<T: UIViewController>() -> T? {
        addInvocation(.m_initial)
		let perform = methodPerformValue(.m_initial) as? () -> Void
		perform?()
		var __value: T? = nil
		do {
		    __value = try methodReturnValue(.m_initial).casted()
		} catch {
			// do nothing
		}
		return __value
    }

    open func viewController<T: UIViewController>(identifier: StoryboardId) -> T? {
        addInvocation(.m_viewController__identifier_identifier(Parameter<StoryboardId>.value(`identifier`)))
		let perform = methodPerformValue(.m_viewController__identifier_identifier(Parameter<StoryboardId>.value(`identifier`))) as? (StoryboardId) -> Void
		perform?(`identifier`)
		var __value: T? = nil
		do {
		    __value = try methodReturnValue(.m_viewController__identifier_identifier(Parameter<StoryboardId>.value(`identifier`))).casted()
		} catch {
			// do nothing
		}
		return __value
    }


    fileprivate enum MethodType {
        case m_initial
        case m_viewController__identifier_identifier(Parameter<StoryboardId>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_initial, .m_initial):
                return true 
            case (.m_viewController__identifier_identifier(let lhsIdentifier), .m_viewController__identifier_identifier(let rhsIdentifier)):
                guard Parameter.compare(lhs: lhsIdentifier, rhs: rhsIdentifier, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_initial: return 0
            case let .m_viewController__identifier_identifier(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


        public static func initial<T: UIViewController>(willReturn: T?...) -> MethodStub {
            return Given(method: .m_initial, products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func viewController<T: UIViewController>(identifier: Parameter<StoryboardId>, willReturn: T?...) -> MethodStub {
            return Given(method: .m_viewController__identifier_identifier(`identifier`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func initial<T: UIViewController>(willProduce: (Stubber<T?>) -> Void) -> MethodStub {
            let willReturn: [T?] = []
			let given: Given = { return Given(method: .m_initial, products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (T?).self)
			willProduce(stubber)
			return given
        }
        public static func viewController<T: UIViewController>(identifier: Parameter<StoryboardId>, willProduce: (Stubber<T?>) -> Void) -> MethodStub {
            let willReturn: [T?] = []
			let given: Given = { return Given(method: .m_viewController__identifier_identifier(`identifier`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (T?).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func initial() -> Verify { return Verify(method: .m_initial)}
        public static func viewController(identifier: Parameter<StoryboardId>) -> Verify { return Verify(method: .m_viewController__identifier_identifier(`identifier`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func initial(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_initial, performs: perform)
        }
        public static func viewController(identifier: Parameter<StoryboardId>, perform: @escaping (StoryboardId) -> Void) -> Perform {
            return Perform(method: .m_viewController__identifier_identifier(`identifier`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - StoryboardId
open class StoryboardIdMock: StoryboardId, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }

    public var identifier: String {
		get {	invocations.append(.p_identifier_get); return __p_identifier ?? givenGetterValue(.p_identifier_get, "StoryboardIdMock - stub value for identifier was not defined") }
		@available(*, deprecated, message: "Using setters on readonly variables is deprecated, and will be removed in 3.1. Use Given to define stubbed property return value.")
		set {	__p_identifier = newValue }
	}
	private var __p_identifier: (String)?






    fileprivate enum MethodType {
        case p_identifier_get

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_identifier_get,.p_identifier_get): return true
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_identifier_get: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }

        public static func identifier(getter defaultValue: String...) -> PropertyStub {
            return Given(method: .p_identifier_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }

    }

    public struct Verify {
        fileprivate var method: MethodType

        public static var identifier: Verify { return Verify(method: .p_identifier_get) }
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SyncInteractorProtocol
open class SyncInteractorProtocolMock: SyncInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func syncFacebook() {
        addInvocation(.m_syncFacebook)
		let perform = methodPerformValue(.m_syncFacebook) as? () -> Void
		perform?()
    }

    open func syncGoogle() {
        addInvocation(.m_syncGoogle)
		let perform = methodPerformValue(.m_syncGoogle) as? () -> Void
		perform?()
    }

    open func syncOutlook(from vc: UIViewController) {
        addInvocation(.m_syncOutlook__from_vc(Parameter<UIViewController>.value(`vc`)))
		let perform = methodPerformValue(.m_syncOutlook__from_vc(Parameter<UIViewController>.value(`vc`))) as? (UIViewController) -> Void
		perform?(`vc`)
    }

    open func syncDevice() {
        addInvocation(.m_syncDevice)
		let perform = methodPerformValue(.m_syncDevice) as? () -> Void
		perform?()
    }

    open func yahoo(from vc: UIViewController) {
        addInvocation(.m_yahoo__from_vc(Parameter<UIViewController>.value(`vc`)))
		let perform = methodPerformValue(.m_yahoo__from_vc(Parameter<UIViewController>.value(`vc`))) as? (UIViewController) -> Void
		perform?(`vc`)
    }


    fileprivate enum MethodType {
        case m_syncFacebook
        case m_syncGoogle
        case m_syncOutlook__from_vc(Parameter<UIViewController>)
        case m_syncDevice
        case m_yahoo__from_vc(Parameter<UIViewController>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_syncFacebook, .m_syncFacebook):
                return true 
            case (.m_syncGoogle, .m_syncGoogle):
                return true 
            case (.m_syncOutlook__from_vc(let lhsVc), .m_syncOutlook__from_vc(let rhsVc)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                return true 
            case (.m_syncDevice, .m_syncDevice):
                return true 
            case (.m_yahoo__from_vc(let lhsVc), .m_yahoo__from_vc(let rhsVc)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_syncFacebook: return 0
            case .m_syncGoogle: return 0
            case let .m_syncOutlook__from_vc(p0): return p0.intValue
            case .m_syncDevice: return 0
            case let .m_yahoo__from_vc(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func syncFacebook() -> Verify { return Verify(method: .m_syncFacebook)}
        public static func syncGoogle() -> Verify { return Verify(method: .m_syncGoogle)}
        public static func syncOutlook(from vc: Parameter<UIViewController>) -> Verify { return Verify(method: .m_syncOutlook__from_vc(`vc`))}
        public static func syncDevice() -> Verify { return Verify(method: .m_syncDevice)}
        public static func yahoo(from vc: Parameter<UIViewController>) -> Verify { return Verify(method: .m_yahoo__from_vc(`vc`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func syncFacebook(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_syncFacebook, performs: perform)
        }
        public static func syncGoogle(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_syncGoogle, performs: perform)
        }
        public static func syncOutlook(from vc: Parameter<UIViewController>, perform: @escaping (UIViewController) -> Void) -> Perform {
            return Perform(method: .m_syncOutlook__from_vc(`vc`), performs: perform)
        }
        public static func syncDevice(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_syncDevice, performs: perform)
        }
        public static func yahoo(from vc: Parameter<UIViewController>, perform: @escaping (UIViewController) -> Void) -> Perform {
            return Perform(method: .m_yahoo__from_vc(`vc`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SyncPresenterProtocol
open class SyncPresenterProtocolMock: SyncPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: SyncViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<SyncViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<SyncViewControllerProtocol?>.value(`viewController`))) as? (SyncViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func handle(error: SyncError) {
        addInvocation(.m_handle__error_error(Parameter<SyncError>.value(`error`)))
		let perform = methodPerformValue(.m_handle__error_error(Parameter<SyncError>.value(`error`))) as? (SyncError) -> Void
		perform?(`error`)
    }

    open func successSyncing(_ app: SyncApp) {
        addInvocation(.m_successSyncing__app(Parameter<SyncApp>.value(`app`)))
		let perform = methodPerformValue(.m_successSyncing__app(Parameter<SyncApp>.value(`app`))) as? (SyncApp) -> Void
		perform?(`app`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<SyncViewControllerProtocol?>)
        case m_handle__error_error(Parameter<SyncError>)
        case m_successSyncing__app(Parameter<SyncApp>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_handle__error_error(let lhsError), .m_handle__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_successSyncing__app(let lhsApp), .m_successSyncing__app(let rhsApp)):
                guard Parameter.compare(lhs: lhsApp, rhs: rhsApp, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_handle__error_error(p0): return p0.intValue
            case let .m_successSyncing__app(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<SyncViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func handle(error: Parameter<SyncError>) -> Verify { return Verify(method: .m_handle__error_error(`error`))}
        public static func successSyncing(_ app: Parameter<SyncApp>) -> Verify { return Verify(method: .m_successSyncing__app(`app`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<SyncViewControllerProtocol?>, perform: @escaping (SyncViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func handle(error: Parameter<SyncError>, perform: @escaping (SyncError) -> Void) -> Perform {
            return Perform(method: .m_handle__error_error(`error`), performs: perform)
        }
        public static func successSyncing(_ app: Parameter<SyncApp>, perform: @escaping (SyncApp) -> Void) -> Perform {
            return Perform(method: .m_successSyncing__app(`app`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SyncRouterProtocol
open class SyncRouterProtocolMock: SyncRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: SyncViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<SyncViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<SyncViewControllerProtocol?>.value(`viewController`))) as? (SyncViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: SyncRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<SyncRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<SyncRouter.Scene>.value(`scene`))) as? (SyncRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<SyncViewControllerProtocol?>)
        case m_route__to_scene(Parameter<SyncRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<SyncViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<SyncRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<SyncViewControllerProtocol?>, perform: @escaping (SyncViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<SyncRouter.Scene>, perform: @escaping (SyncRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SyncViewControllerProtocol
open class SyncViewControllerProtocolMock: SyncViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: SyncInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<SyncInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<SyncInteractorProtocol>.value(`interactor`))) as? (SyncInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: SyncRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<SyncRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<SyncRouterProtocol>.value(`router`))) as? (SyncRouterProtocol) -> Void
		perform?(`router`)
    }

    open func display(error: SyncError) {
        addInvocation(.m_display__error_error(Parameter<SyncError>.value(`error`)))
		let perform = methodPerformValue(.m_display__error_error(Parameter<SyncError>.value(`error`))) as? (SyncError) -> Void
		perform?(`error`)
    }

    open func successSyncing(_ app: SyncApp) {
        addInvocation(.m_successSyncing__app(Parameter<SyncApp>.value(`app`)))
		let perform = methodPerformValue(.m_successSyncing__app(Parameter<SyncApp>.value(`app`))) as? (SyncApp) -> Void
		perform?(`app`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<SyncInteractorProtocol>)
        case m_set__router_router(Parameter<SyncRouterProtocol>)
        case m_display__error_error(Parameter<SyncError>)
        case m_successSyncing__app(Parameter<SyncApp>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_display__error_error(let lhsError), .m_display__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_successSyncing__app(let lhsApp), .m_successSyncing__app(let rhsApp)):
                guard Parameter.compare(lhs: lhsApp, rhs: rhsApp, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_display__error_error(p0): return p0.intValue
            case let .m_successSyncing__app(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<SyncInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<SyncRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func display(error: Parameter<SyncError>) -> Verify { return Verify(method: .m_display__error_error(`error`))}
        public static func successSyncing(_ app: Parameter<SyncApp>) -> Verify { return Verify(method: .m_successSyncing__app(`app`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<SyncInteractorProtocol>, perform: @escaping (SyncInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<SyncRouterProtocol>, perform: @escaping (SyncRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func display(error: Parameter<SyncError>, perform: @escaping (SyncError) -> Void) -> Perform {
            return Perform(method: .m_display__error_error(`error`), performs: perform)
        }
        public static func successSyncing(_ app: Parameter<SyncApp>, perform: @escaping (SyncApp) -> Void) -> Perform {
            return Perform(method: .m_successSyncing__app(`app`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TimelineInteractorProtocol
open class TimelineInteractorProtocolMock: TimelineInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func handleViewWillAppear() {
        addInvocation(.m_handleViewWillAppear)
		let perform = methodPerformValue(.m_handleViewWillAppear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_handleViewWillAppear

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_handleViewWillAppear, .m_handleViewWillAppear):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_handleViewWillAppear: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func handleViewWillAppear() -> Verify { return Verify(method: .m_handleViewWillAppear)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func handleViewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_handleViewWillAppear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TopViewControllerProviderProtocol
open class TopViewControllerProviderProtocolMock: TopViewControllerProviderProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func topViewController() -> UIViewControllerRouting? {
        addInvocation(.m_topViewController)
		let perform = methodPerformValue(.m_topViewController) as? () -> Void
		perform?()
		var __value: UIViewControllerRouting? = nil
		do {
		    __value = try methodReturnValue(.m_topViewController).casted()
		} catch {
			// do nothing
		}
		return __value
    }


    fileprivate enum MethodType {
        case m_topViewController

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_topViewController, .m_topViewController):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_topViewController: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


        public static func topViewController(willReturn: UIViewControllerRouting?...) -> MethodStub {
            return Given(method: .m_topViewController, products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func topViewController(willProduce: (Stubber<UIViewControllerRouting?>) -> Void) -> MethodStub {
            let willReturn: [UIViewControllerRouting?] = []
			let given: Given = { return Given(method: .m_topViewController, products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (UIViewControllerRouting?).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func topViewController() -> Verify { return Verify(method: .m_topViewController)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func topViewController(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_topViewController, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TutorialInteractorProtocol
open class TutorialInteractorProtocolMock: TutorialInteractorProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func fetchTutorialPages() {
        addInvocation(.m_fetchTutorialPages)
		let perform = methodPerformValue(.m_fetchTutorialPages) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_fetchTutorialPages

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchTutorialPages, .m_fetchTutorialPages):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_fetchTutorialPages: return 0
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func fetchTutorialPages() -> Verify { return Verify(method: .m_fetchTutorialPages)}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func fetchTutorialPages(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_fetchTutorialPages, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TutorialPresenterProtocol
open class TutorialPresenterProtocolMock: TutorialPresenterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: TutorialViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<TutorialViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<TutorialViewControllerProtocol?>.value(`viewController`))) as? (TutorialViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func handle(error: Error) {
        addInvocation(.m_handle__error_error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_handle__error_error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }

    open func displayTutorialSlides(_ slides: [Tutorial]) {
        addInvocation(.m_displayTutorialSlides__slides(Parameter<[Tutorial]>.value(`slides`)))
		let perform = methodPerformValue(.m_displayTutorialSlides__slides(Parameter<[Tutorial]>.value(`slides`))) as? ([Tutorial]) -> Void
		perform?(`slides`)
    }

    open func displayActivityIndicator(_ display: Bool) {
        addInvocation(.m_displayActivityIndicator__display(Parameter<Bool>.value(`display`)))
		let perform = methodPerformValue(.m_displayActivityIndicator__display(Parameter<Bool>.value(`display`))) as? (Bool) -> Void
		perform?(`display`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<TutorialViewControllerProtocol?>)
        case m_handle__error_error(Parameter<Error>)
        case m_displayTutorialSlides__slides(Parameter<[Tutorial]>)
        case m_displayActivityIndicator__display(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_handle__error_error(let lhsError), .m_handle__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayTutorialSlides__slides(let lhsSlides), .m_displayTutorialSlides__slides(let rhsSlides)):
                guard Parameter.compare(lhs: lhsSlides, rhs: rhsSlides, with: matcher) else { return false } 
                return true 
            case (.m_displayActivityIndicator__display(let lhsDisplay), .m_displayActivityIndicator__display(let rhsDisplay)):
                guard Parameter.compare(lhs: lhsDisplay, rhs: rhsDisplay, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_handle__error_error(p0): return p0.intValue
            case let .m_displayTutorialSlides__slides(p0): return p0.intValue
            case let .m_displayActivityIndicator__display(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<TutorialViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func handle(error: Parameter<Error>) -> Verify { return Verify(method: .m_handle__error_error(`error`))}
        public static func displayTutorialSlides(_ slides: Parameter<[Tutorial]>) -> Verify { return Verify(method: .m_displayTutorialSlides__slides(`slides`))}
        public static func displayActivityIndicator(_ display: Parameter<Bool>) -> Verify { return Verify(method: .m_displayActivityIndicator__display(`display`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<TutorialViewControllerProtocol?>, perform: @escaping (TutorialViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func handle(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_handle__error_error(`error`), performs: perform)
        }
        public static func displayTutorialSlides(_ slides: Parameter<[Tutorial]>, perform: @escaping ([Tutorial]) -> Void) -> Perform {
            return Perform(method: .m_displayTutorialSlides__slides(`slides`), performs: perform)
        }
        public static func displayActivityIndicator(_ display: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_displayActivityIndicator__display(`display`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TutorialRouterProtocol
open class TutorialRouterProtocolMock: TutorialRouterProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(viewController: TutorialViewControllerProtocol?) {
        addInvocation(.m_set__viewController_viewController(Parameter<TutorialViewControllerProtocol?>.value(`viewController`)))
		let perform = methodPerformValue(.m_set__viewController_viewController(Parameter<TutorialViewControllerProtocol?>.value(`viewController`))) as? (TutorialViewControllerProtocol?) -> Void
		perform?(`viewController`)
    }

    open func route(to scene: TutorialRouter.Scene) {
        addInvocation(.m_route__to_scene(Parameter<TutorialRouter.Scene>.value(`scene`)))
		let perform = methodPerformValue(.m_route__to_scene(Parameter<TutorialRouter.Scene>.value(`scene`))) as? (TutorialRouter.Scene) -> Void
		perform?(`scene`)
    }


    fileprivate enum MethodType {
        case m_set__viewController_viewController(Parameter<TutorialViewControllerProtocol?>)
        case m_route__to_scene(Parameter<TutorialRouter.Scene>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__viewController_viewController(let lhsViewcontroller), .m_set__viewController_viewController(let rhsViewcontroller)):
                guard Parameter.compare(lhs: lhsViewcontroller, rhs: rhsViewcontroller, with: matcher) else { return false } 
                return true 
            case (.m_route__to_scene(let lhsScene), .m_route__to_scene(let rhsScene)):
                guard Parameter.compare(lhs: lhsScene, rhs: rhsScene, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__viewController_viewController(p0): return p0.intValue
            case let .m_route__to_scene(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(viewController: Parameter<TutorialViewControllerProtocol?>) -> Verify { return Verify(method: .m_set__viewController_viewController(`viewController`))}
        public static func route(to scene: Parameter<TutorialRouter.Scene>) -> Verify { return Verify(method: .m_route__to_scene(`scene`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(viewController: Parameter<TutorialViewControllerProtocol?>, perform: @escaping (TutorialViewControllerProtocol?) -> Void) -> Perform {
            return Perform(method: .m_set__viewController_viewController(`viewController`), performs: perform)
        }
        public static func route(to scene: Parameter<TutorialRouter.Scene>, perform: @escaping (TutorialRouter.Scene) -> Void) -> Perform {
            return Perform(method: .m_route__to_scene(`scene`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TutorialServiceProtocol
open class TutorialServiceProtocolMock: TutorialServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func fetchTutorialSlides(completion: @escaping RequestCompletion<TutorialResponse>) {
        addInvocation(.m_fetchTutorialSlides__completion_completion(Parameter<RequestCompletion<TutorialResponse>>.any))
		let perform = methodPerformValue(.m_fetchTutorialSlides__completion_completion(Parameter<RequestCompletion<TutorialResponse>>.any)) as? (@escaping RequestCompletion<TutorialResponse>) -> Void
		perform?(`completion`)
    }


    fileprivate enum MethodType {
        case m_fetchTutorialSlides__completion_completion(Parameter<RequestCompletion<TutorialResponse>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchTutorialSlides__completion_completion(let lhsCompletion), .m_fetchTutorialSlides__completion_completion(let rhsCompletion)):
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchTutorialSlides__completion_completion(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func fetchTutorialSlides(completion: Parameter<RequestCompletion<TutorialResponse>>) -> Verify { return Verify(method: .m_fetchTutorialSlides__completion_completion(`completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func fetchTutorialSlides(completion: Parameter<RequestCompletion<TutorialResponse>>, perform: @escaping (@escaping RequestCompletion<TutorialResponse>) -> Void) -> Perform {
            return Perform(method: .m_fetchTutorialSlides__completion_completion(`completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TutorialViewControllerProtocol
open class TutorialViewControllerProtocolMock: TutorialViewControllerProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func set(interactor: TutorialInteractorProtocol) {
        addInvocation(.m_set__interactor_interactor(Parameter<TutorialInteractorProtocol>.value(`interactor`)))
		let perform = methodPerformValue(.m_set__interactor_interactor(Parameter<TutorialInteractorProtocol>.value(`interactor`))) as? (TutorialInteractorProtocol) -> Void
		perform?(`interactor`)
    }

    open func set(router: TutorialRouterProtocol) {
        addInvocation(.m_set__router_router(Parameter<TutorialRouterProtocol>.value(`router`)))
		let perform = methodPerformValue(.m_set__router_router(Parameter<TutorialRouterProtocol>.value(`router`))) as? (TutorialRouterProtocol) -> Void
		perform?(`router`)
    }

    open func display(error: Error) {
        addInvocation(.m_display__error_error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_display__error_error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }

    open func displayTutorialSlides(with tutorials: [Tutorial]) {
        addInvocation(.m_displayTutorialSlides__with_tutorials(Parameter<[Tutorial]>.value(`tutorials`)))
		let perform = methodPerformValue(.m_displayTutorialSlides__with_tutorials(Parameter<[Tutorial]>.value(`tutorials`))) as? ([Tutorial]) -> Void
		perform?(`tutorials`)
    }

    open func displayActivityIndicator(_ display: Bool) {
        addInvocation(.m_displayActivityIndicator__display(Parameter<Bool>.value(`display`)))
		let perform = methodPerformValue(.m_displayActivityIndicator__display(Parameter<Bool>.value(`display`))) as? (Bool) -> Void
		perform?(`display`)
    }

    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_set__interactor_interactor(Parameter<TutorialInteractorProtocol>)
        case m_set__router_router(Parameter<TutorialRouterProtocol>)
        case m_display__error_error(Parameter<Error>)
        case m_displayTutorialSlides__with_tutorials(Parameter<[Tutorial]>)
        case m_displayActivityIndicator__display(Parameter<Bool>)
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_set__interactor_interactor(let lhsInteractor), .m_set__interactor_interactor(let rhsInteractor)):
                guard Parameter.compare(lhs: lhsInteractor, rhs: rhsInteractor, with: matcher) else { return false } 
                return true 
            case (.m_set__router_router(let lhsRouter), .m_set__router_router(let rhsRouter)):
                guard Parameter.compare(lhs: lhsRouter, rhs: rhsRouter, with: matcher) else { return false } 
                return true 
            case (.m_display__error_error(let lhsError), .m_display__error_error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_displayTutorialSlides__with_tutorials(let lhsTutorials), .m_displayTutorialSlides__with_tutorials(let rhsTutorials)):
                guard Parameter.compare(lhs: lhsTutorials, rhs: rhsTutorials, with: matcher) else { return false } 
                return true 
            case (.m_displayActivityIndicator__display(let lhsDisplay), .m_displayActivityIndicator__display(let rhsDisplay)):
                guard Parameter.compare(lhs: lhsDisplay, rhs: rhsDisplay, with: matcher) else { return false } 
                return true 
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_set__interactor_interactor(p0): return p0.intValue
            case let .m_set__router_router(p0): return p0.intValue
            case let .m_display__error_error(p0): return p0.intValue
            case let .m_displayTutorialSlides__with_tutorials(p0): return p0.intValue
            case let .m_displayActivityIndicator__display(p0): return p0.intValue
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func set(interactor: Parameter<TutorialInteractorProtocol>) -> Verify { return Verify(method: .m_set__interactor_interactor(`interactor`))}
        public static func set(router: Parameter<TutorialRouterProtocol>) -> Verify { return Verify(method: .m_set__router_router(`router`))}
        public static func display(error: Parameter<Error>) -> Verify { return Verify(method: .m_display__error_error(`error`))}
        public static func displayTutorialSlides(with tutorials: Parameter<[Tutorial]>) -> Verify { return Verify(method: .m_displayTutorialSlides__with_tutorials(`tutorials`))}
        public static func displayActivityIndicator(_ display: Parameter<Bool>) -> Verify { return Verify(method: .m_displayActivityIndicator__display(`display`))}
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func set(interactor: Parameter<TutorialInteractorProtocol>, perform: @escaping (TutorialInteractorProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__interactor_interactor(`interactor`), performs: perform)
        }
        public static func set(router: Parameter<TutorialRouterProtocol>, perform: @escaping (TutorialRouterProtocol) -> Void) -> Perform {
            return Perform(method: .m_set__router_router(`router`), performs: perform)
        }
        public static func display(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_display__error_error(`error`), performs: perform)
        }
        public static func displayTutorialSlides(with tutorials: Parameter<[Tutorial]>, perform: @escaping ([Tutorial]) -> Void) -> Perform {
            return Perform(method: .m_displayTutorialSlides__with_tutorials(`tutorials`), performs: perform)
        }
        public static func displayActivityIndicator(_ display: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_displayActivityIndicator__display(`display`), performs: perform)
        }
        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - UIApplicationProtocol
open class UIApplicationProtocolMock: UIApplicationProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }

    public var keyWindow: UIWindow? {
		get {	invocations.append(.p_keyWindow_get); return __p_keyWindow ?? optionalGivenGetterValue(.p_keyWindow_get, "UIApplicationProtocolMock - stub value for keyWindow was not defined") }
		@available(*, deprecated, message: "Using setters on readonly variables is deprecated, and will be removed in 3.1. Use Given to define stubbed property return value.")
		set {	__p_keyWindow = newValue }
	}
	private var __p_keyWindow: (UIWindow)?

    public var rootViewController: UIViewController? {
		get {	invocations.append(.p_rootViewController_get); return __p_rootViewController ?? optionalGivenGetterValue(.p_rootViewController_get, "UIApplicationProtocolMock - stub value for rootViewController was not defined") }
		set {	invocations.append(.p_rootViewController_set(.value(newValue))); __p_rootViewController = newValue }
	}
	private var __p_rootViewController: (UIViewController)?





    open func topViewController(controller: UIViewController?) -> UIViewController? {
        addInvocation(.m_topViewController__controller_controller(Parameter<UIViewController?>.value(`controller`)))
		let perform = methodPerformValue(.m_topViewController__controller_controller(Parameter<UIViewController?>.value(`controller`))) as? (UIViewController?) -> Void
		perform?(`controller`)
		var __value: UIViewController? = nil
		do {
		    __value = try methodReturnValue(.m_topViewController__controller_controller(Parameter<UIViewController?>.value(`controller`))).casted()
		} catch {
			// do nothing
		}
		return __value
    }


    fileprivate enum MethodType {
        case m_topViewController__controller_controller(Parameter<UIViewController?>)
        case p_keyWindow_get
        case p_rootViewController_get
		case p_rootViewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_topViewController__controller_controller(let lhsController), .m_topViewController__controller_controller(let rhsController)):
                guard Parameter.compare(lhs: lhsController, rhs: rhsController, with: matcher) else { return false } 
                return true 
            case (.p_keyWindow_get,.p_keyWindow_get): return true
            case (.p_rootViewController_get,.p_rootViewController_get): return true
			case (.p_rootViewController_set(let left),.p_rootViewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_topViewController__controller_controller(p0): return p0.intValue
            case .p_keyWindow_get: return 0
            case .p_rootViewController_get: return 0
			case .p_rootViewController_set(let newValue): return newValue.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }

        public static func keyWindow(getter defaultValue: UIWindow?...) -> PropertyStub {
            return Given(method: .p_keyWindow_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }
        public static func rootViewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_rootViewController_get, products: defaultValue.map({ StubProduct.return($0 as Any) }))
        }

        public static func topViewController(controller: Parameter<UIViewController?>, willReturn: UIViewController?...) -> MethodStub {
            return Given(method: .m_topViewController__controller_controller(`controller`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func topViewController(controller: Parameter<UIViewController?>, willProduce: (Stubber<UIViewController?>) -> Void) -> MethodStub {
            let willReturn: [UIViewController?] = []
			let given: Given = { return Given(method: .m_topViewController__controller_controller(`controller`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (UIViewController?).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func topViewController(controller: Parameter<UIViewController?>) -> Verify { return Verify(method: .m_topViewController__controller_controller(`controller`))}
        public static var keyWindow: Verify { return Verify(method: .p_keyWindow_get) }
        public static var rootViewController: Verify { return Verify(method: .p_rootViewController_get) }
		public static func rootViewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_rootViewController_set(newValue)) }
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func topViewController(controller: Parameter<UIViewController?>, perform: @escaping (UIViewController?) -> Void) -> Perform {
            return Perform(method: .m_topViewController__controller_controller(`controller`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - UINavigationControllerRouting
open class UINavigationControllerRoutingMock: UINavigationControllerRouting, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func popViewController(animated: Bool) -> UIViewController? {
        addInvocation(.m_popViewController__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popViewController__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
		var __value: UIViewController? = nil
		do {
		    __value = try methodReturnValue(.m_popViewController__animated_animated(Parameter<Bool>.value(`animated`))).casted()
		} catch {
			// do nothing
		}
		return __value
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }


    fileprivate enum MethodType {
        case m_popViewController__animated_animated(Parameter<Bool>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_popViewController__animated_animated(let lhsAnimated), .m_popViewController__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_popViewController__animated_animated(p0): return p0.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


        public static func popViewController(animated: Parameter<Bool>, willReturn: UIViewController?...) -> MethodStub {
            return Given(method: .m_popViewController__animated_animated(`animated`), products: willReturn.map({ StubProduct.return($0 as Any) }))
        }
        public static func popViewController(animated: Parameter<Bool>, willProduce: (Stubber<UIViewController?>) -> Void) -> MethodStub {
            let willReturn: [UIViewController?] = []
			let given: Given = { return Given(method: .m_popViewController__animated_animated(`animated`), products: willReturn.map({ StubProduct.return($0 as Any) })) }()
			let stubber = given.stub(for: (UIViewController?).self)
			willProduce(stubber)
			return given
        }
    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func popViewController(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popViewController__animated_animated(`animated`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func popViewController(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popViewController__animated_animated(`animated`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - UIViewControllerRouting
open class UIViewControllerRoutingMock: UIViewControllerRouting, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>.value(`viewControllerToPresent`), Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (UIViewController, Bool, (() -> Void)?) -> Void
		perform?(`viewControllerToPresent`, `flag`, `completion`)
    }

    open func show(_ vc: UIViewController, sender: Any?) {
        addInvocation(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`)))
		let perform = methodPerformValue(.m_show__vcsender_sender(Parameter<UIViewController>.value(`vc`), Parameter<Any?>.value(`sender`))) as? (UIViewController, Any?) -> Void
		perform?(`vc`, `sender`)
    }

    open func pop(animated: Bool) {
        addInvocation(.m_pop__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_pop__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    open func dismiss(animated flag: Bool, completion: (() -> Void)?) {
        addInvocation(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`)))
		let perform = methodPerformValue(.m_dismiss__animated_flagcompletion_completion(Parameter<Bool>.value(`flag`), Parameter<(() -> Void)?>.value(`completion`))) as? (Bool, (() -> Void)?) -> Void
		perform?(`flag`, `completion`)
    }

    open func popToRoot(animated: Bool) {
        addInvocation(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_popToRoot__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }


    fileprivate enum MethodType {
        case m_present__viewControllerToPresentanimated_flagcompletion_completion(Parameter<UIViewController>, Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_show__vcsender_sender(Parameter<UIViewController>, Parameter<Any?>)
        case m_pop__animated_animated(Parameter<Bool>)
        case m_dismiss__animated_flagcompletion_completion(Parameter<Bool>, Parameter<(() -> Void)?>)
        case m_popToRoot__animated_animated(Parameter<Bool>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_present__viewControllerToPresentanimated_flagcompletion_completion(let lhsViewcontrollertopresent, let lhsFlag, let lhsCompletion), .m_present__viewControllerToPresentanimated_flagcompletion_completion(let rhsViewcontrollertopresent, let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsViewcontrollertopresent, rhs: rhsViewcontrollertopresent, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_show__vcsender_sender(let lhsVc, let lhsSender), .m_show__vcsender_sender(let rhsVc, let rhsSender)):
                guard Parameter.compare(lhs: lhsVc, rhs: rhsVc, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSender, rhs: rhsSender, with: matcher) else { return false } 
                return true 
            case (.m_pop__animated_animated(let lhsAnimated), .m_pop__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_dismiss__animated_flagcompletion_completion(let lhsFlag, let lhsCompletion), .m_dismiss__animated_flagcompletion_completion(let rhsFlag, let rhsCompletion)):
                guard Parameter.compare(lhs: lhsFlag, rhs: rhsFlag, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            case (.m_popToRoot__animated_animated(let lhsAnimated), .m_popToRoot__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_present__viewControllerToPresentanimated_flagcompletion_completion(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case let .m_show__vcsender_sender(p0, p1): return p0.intValue + p1.intValue
            case let .m_pop__animated_animated(p0): return p0.intValue
            case let .m_dismiss__animated_flagcompletion_completion(p0, p1): return p0.intValue + p1.intValue
            case let .m_popToRoot__animated_animated(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`))}
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>) -> Verify { return Verify(method: .m_show__vcsender_sender(`vc`, `sender`))}
        public static func pop(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_pop__animated_animated(`animated`))}
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>) -> Verify { return Verify(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`))}
        public static func popToRoot(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_popToRoot__animated_animated(`animated`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func present(_ viewControllerToPresent: Parameter<UIViewController>, animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (UIViewController, Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_present__viewControllerToPresentanimated_flagcompletion_completion(`viewControllerToPresent`, `flag`, `completion`), performs: perform)
        }
        public static func show(_ vc: Parameter<UIViewController>, sender: Parameter<Any?>, perform: @escaping (UIViewController, Any?) -> Void) -> Perform {
            return Perform(method: .m_show__vcsender_sender(`vc`, `sender`), performs: perform)
        }
        public static func pop(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pop__animated_animated(`animated`), performs: perform)
        }
        public static func dismiss(animated flag: Parameter<Bool>, completion: Parameter<(() -> Void)?>, perform: @escaping (Bool, (() -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__animated_flagcompletion_completion(`flag`, `completion`), performs: perform)
        }
        public static func popToRoot(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_popToRoot__animated_animated(`animated`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - UserProfileServiceProtocol
open class UserProfileServiceProtocolMock: UserProfileServiceProtocol, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        SwiftyMockyTestObserver.setup()
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    public typealias PropertyStub = Given
    public typealias MethodStub = Given
    public typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    /// Clear mock internals. You can specify what to reset (invocations aka verify, givens or performs) or leave it empty to clear all mock internals
    public func resetMock(_ scopes: MockScope...) {
        let scopes: [MockScope] = scopes.isEmpty ? [.invocation, .given, .perform] : scopes
        if scopes.contains(.invocation) { invocations = [] }
        if scopes.contains(.given) { methodReturnValues = [] }
        if scopes.contains(.perform) { methodPerformValues = [] }
    }





    open func getProfile(_ completion: @escaping  RequestCompletion<UserProfile>) {
        addInvocation(.m_getProfile__completion(Parameter<RequestCompletion<UserProfile>>.any))
		let perform = methodPerformValue(.m_getProfile__completion(Parameter<RequestCompletion<UserProfile>>.any)) as? (@escaping  RequestCompletion<UserProfile>) -> Void
		perform?(`completion`)
    }


    fileprivate enum MethodType {
        case m_getProfile__completion(Parameter<RequestCompletion<UserProfile>>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_getProfile__completion(let lhsCompletion), .m_getProfile__completion(let rhsCompletion)):
                guard Parameter.compare(lhs: lhsCompletion, rhs: rhsCompletion, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_getProfile__completion(p0): return p0.intValue
            }
        }
    }

    open class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [StubProduct]) {
            self.method = method
            super.init(products)
        }


    }

    public struct Verify {
        fileprivate var method: MethodType

        public static func getProfile(_ completion: Parameter<RequestCompletion<UserProfile>>) -> Verify { return Verify(method: .m_getProfile__completion(`completion`))}
    }

    public struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        public static func getProfile(_ completion: Parameter<RequestCompletion<UserProfile>>, perform: @escaping (@escaping  RequestCompletion<UserProfile>) -> Void) -> Perform {
            return Perform(method: .m_getProfile__completion(`completion`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> StubProduct {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

