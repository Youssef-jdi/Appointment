//
//  TimelineWeeklyInteractor.swift
//  appointment
//
//  Created by Raluca Mesterca on 18/03/2020.
//  Copyright (c) 2020 DTT. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//
//  This template is meant to work with Swinject.

import RxSwift

// sourcery: AutoMockable
protocol TimelineInteractorProtocol {
    func handleViewWillAppear()
}

class TimelineInteractor: TimelineInteractorProtocol {

    // MARK: DI
    var presenter: TimelinePresenterProtocol
    private let databaseSyncManager: DatabaseSyncManagerProtocol
    private let appointmentDataService: AppointmentDataServiceProtocol
    private let settingsDataService: SettingsDataServiceProtocol
    private let errorHandler: ErrorHandlerProtocol

    private let disposeBag = DisposeBag()

    init(
        presenter: TimelinePresenterProtocol,
        databaseSyncManager: DatabaseSyncManagerProtocol,
        appointmentDataService: AppointmentDataServiceProtocol,
        settingsDataService: SettingsDataServiceProtocol,
        errorHandler: ErrorHandlerProtocol
    ) {
        self.presenter = presenter
        self.databaseSyncManager = databaseSyncManager
        self.appointmentDataService = appointmentDataService
        self.settingsDataService = settingsDataService
        self.errorHandler = errorHandler
    }

    func handleViewWillAppear() {
		Single.zip(databaseSyncManager.syncUserProfile(), databaseSyncManager.syncDatabase())
            .subscribe(onSuccess: { [weak self] _ in
                self?.fetchAppointments()
                self?.fetchSettings()
            }) { [weak self] error in
                self?.errorHandler.handle(error)
        }.disposed(by: disposeBag)
    }
}

// MARK: - Private Methods
private extension TimelineInteractor {

    func fetchAppointments() {
        appointmentDataService.fetchAppointments(appointmentId: nil) { [weak self] result in
            switch result {
            case .success(let appointments):
                Console.log(type: .success, "Appointments fetched successfully! Count: \(appointments.count)")
                let newAppointments = appointments
                    .compactMap { $0 as? AppointmentEntity }
                    .map { Appointment.map(from: $0) }
                self?.presenter.present(appointments: newAppointments)
            case .failure(let error):
               self?.errorHandler.handle(error)
            }
        }
    }

    func fetchSettings() {
        settingsDataService.fetch { [weak self] result in
            switch result {
            case .success(let data):
                guard let entity = data as? SettingsEntity else {
                    self?.presenter.present(settings: Settings.defaultSettings(language: Settings.appLanguage))
                    return
                }
                let settings = Settings.map(from: entity)
                self?.presenter.present(settings: settings)

            case .failure(let error):
                self?.errorHandler.handle(error)
            }
        }
    }
}
