//
//  OutGoingInteractor.swift
//  appointment
//
//  Created by Youssef Jdidi on 2/24/20.
//  Copyright (c) 2020 DTT. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//
//  This template is meant to work with Swinject.

import UIKit

//sourcery: AutoMockable
protocol OutGoingInteractorProtocol {
   func getInvitations()
}

class OutGoingInteractor: OutGoingInteractorProtocol {

    // MARK: DI
    private let presenter: OutGoingPresenterProtocol
    private let invitationService: InvitationServiceProtocol
    private let currentUserDataService: CurrentUserDataServiceProtocol
    private let errorHandler: ErrorHandlerProtocol

    init(
        presenter: OutGoingPresenterProtocol,
        invitationService: InvitationServiceProtocol,
        errorHandler: ErrorHandlerProtocol,
        currentUserDataService: CurrentUserDataServiceProtocol
    ) {
        self.presenter = presenter
        self.invitationService = invitationService
        self.currentUserDataService = currentUserDataService
        self.errorHandler = errorHandler
    }
    
    func getInvitations() {
        presenter.presentLoadingView(display: true)
        invitationService.getInvitations { [weak self] result in
            self?.presenter.presentLoadingView(display: false)
            switch result {
            case .success(let response):
                self?.filterOutGoingInvitations(appointments: response)
            case .failure(let error):
                self?.errorHandler.handle(error)
            }
        }
    }

    private func filterOutGoingInvitations(appointments: [Appointment]) {
        getCurrentUser {[weak self] userId in
            guard let self = self,
            let userId = userId else { return }
            let outGoingInvitations = appointments.filter {
                print("\($0.creatorId) \($0.appointmentType)")

                return $0.creatorId == userId && $0.appointmentType == .invite }
            self.presenter.present(outGoingDataSource: outGoingInvitations)
        }
    }

    private func getCurrentUser(_ completion: @escaping (Int?) -> Void) {
        currentUserDataService.fetchCurrentUser { result in
            switch result {
            case .success(let user):
                guard let currentUser = user as? CurrentUserEntity else { return }
                let profile = UserProfile.map(from: currentUser)
                completion(profile.userId)
            case .failure(let error): print("error fetching current user ", error)
            }
        }
    }
}
