//
//  NewInvitationDetailInteractor.swift
//  appointment
//
//  Created by Irina Filkovskaya on 29/06/2020.
//  Copyright (c) 2020 DTT. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol NewInvitationDetailInteractorProtocol {
    func handleSet(invitation: Appointment?, isOutgoing: Bool)
    func handleViewDidLoad()
    
    /// Fetches the appointment dates from the server to get
    /// the latest version (for the case when a final date was selected)
    /// and calls a corresponding presenter method for presenting the
    /// selected final date or a list of suggested dates.
    func handleViewWillAppear()
    func cancelAsCreator(invitation: Appointment)
    func cancelAsInvitee(invitation: Appointment)
    
    func handleAcceptProposedDate(invitation: Appointment)
    func handleRejectProposedDate(invitation: Appointment)
    func handleSetFinalDate(_ date: AppointmentDate)

    func handleDateIsSelected(incoming invitation: Appointment)

    func handleAddToTimeline(_ invitation: Appointment)
    func handleHideFromTimeline(_ invitation: Appointment)
}

class NewInvitationDetailInteractor: NewInvitationDetailInteractorProtocol {
    // MARK: - Properties
    private var invitation: Appointment?
    private var proposedDates: [AppointmentProposedDate] = []
    private var isOutgoing: Bool = true
    
    // MARK: - DI
    private let presenter: NewInvitationDetailPresenterProtocol
    private let invitationService: InvitationServiceProtocol
    private let appointmentDataService: AppointmentDataServiceProtocol
    private let appointmentApiService: AppointmentServiceProtocol
    private let dateApiService: AppointmentDateApiServiceProtocol
    private let errorHandler: ErrorHandlerProtocol
    
    init(
        presenter: NewInvitationDetailPresenterProtocol,
        invitationService: InvitationServiceProtocol,
        appointmentDataService: AppointmentDataServiceProtocol,
        appointmentApiService: AppointmentServiceProtocol,
        dateApiService: AppointmentDateApiServiceProtocol,
        errorHandler: ErrorHandlerProtocol
    ) {
        self.presenter = presenter
        self.invitationService = invitationService
        self.appointmentDataService = appointmentDataService
        self.appointmentApiService = appointmentApiService
        self.dateApiService = dateApiService
        self.errorHandler = errorHandler
    }
    
    // MARK: - Protocol Methods
    func handleSet(invitation: Appointment?, isOutgoing: Bool) {
        self.invitation = invitation
        self.isOutgoing = isOutgoing
    }
    
    func handleViewDidLoad() {
        guard let invitation = invitation else { return }
        
        presenter.presentAddons([
            .attachments(invitation.attachments),
            .todo(invitation.toDoList),
            .newChat
        ])
        handleChats(invitation.chatIDS)
        handleLocation(lat: invitation.latitude, long: invitation.longitude)
        handleDates(invitation.dates)
    }
    
    func handleViewWillAppear() {
        guard let invitation = invitation else { return }
        dateApiService.getDates(for: invitation.id) { [weak self, errorHandler] result in
            guard let self = self else { return }
            switch result {
            case .success:
                guard let dates = result.value else { return }
                self.handleDates(dates)
            case .failure(let error):
                errorHandler.handle(error)
            }
        }
    }

    func cancelAsCreator(invitation: Appointment) {
        invitationService
            .cancelAsCreator(invitationId: invitation.id) { [weak self, presenter, errorHandler] result in
                guard let self = self else { return }
                switch result {
                case .success:
                    self.updateDatabase(invitation.id, .cancelled)
                    presenter.presentCancelInvitationSuccess()
                case .failure(let error):
                    errorHandler.handle(error)
                }
            }
    }

    func cancelAsInvitee(invitation: Appointment) {
        invitationService
            .cancelAsInvitee(invitationId: invitation.id) {[weak self, presenter, errorHandler] result in
                guard let self = self else { return }
                switch result {
                case .success:
                    self.updateDatabase(invitation.id, .rejected)
                    presenter.presentCancelInvitationSuccess()
                case .failure(let error):
                    errorHandler.handle(error)
                }
            }
    }
    
    func handleAcceptProposedDate(invitation: Appointment) {
        // TODO: Add refreshing the suggeseted dates with the newly added proposed date
        let currentProposedDate = self.proposedDates.first
        dateApiService.respondToProposedDates(
            appointmentId: invitation.id,
            proposeDateId: currentProposedDate?.id ?? 0,
            status: 1
        ) { [weak self] result in
            print("ðŸ˜ˆ", result)
            switch result {
            case .success:
                guard !(self?.proposedDates.isEmpty ?? true) else {
                    self?.presenter.presentBasicInfo(from: invitation)
                    return
                }
                let updatedProposedDate = self?.proposedDates.filter { $0 != currentProposedDate }
                self?.proposedDates = updatedProposedDate! // TODO: make the Current proposed  date and proposedDates manipulation more clear
                guard let startDate = updatedProposedDate?.first?.startDate else { return }
                guard let endDate = updatedProposedDate?.first?.endDate else { return }
                self?.presenter.presentProposedDate(
                    startDate: startDate, endDate: endDate
                )
                
            case .failure(let error):
                self?.errorHandler.handle(error)
            }
        }
    }
    
    func handleRejectProposedDate(invitation: Appointment) {
        let currentProposedDate = self.proposedDates.first
        dateApiService.respondToProposedDates(
            appointmentId: invitation.id,
            proposeDateId: currentProposedDate?.id ?? 0,
            status: 0
        ) { [weak self] result in
            print("ðŸ˜ˆ", result)
            switch result {
            case .success:
                if (self?.proposedDates.isEmpty)! {
                    self?.presenter.presentBasicInfo(from: invitation)
                } else {
                    let updatedProposedDate = self?.proposedDates.filter { $0 != currentProposedDate }
                    self?.proposedDates = updatedProposedDate!
                }
            case .failure(let error):
                self?.errorHandler.handle(error)
            }
        }
    }
    
    func handleSetFinalDate(_ date: AppointmentDate) {
        presenter.presentAddFinalDateToAgenda(
            creator: isOutgoing,
            date: date
        )
        handleDates([date])
    }

    /// - Check the invitation has a final date
    //TODO: - Need to check if this appointment is already in the user's agenda
    //TODO: - Need to check the user has a date on that final date ( conflict )
    func handleDateIsSelected(incoming invitation: Appointment) {
        guard let finalDate = invitation.finalDate else { return }
        presenter.presentSetIncomingFinalDate(proposed: finalDate)
    }

    func handleAddToTimeline(_ invitation: Appointment) {
        let responseStatus: UserResponseType = {
            switch invitation.appointmentCategory {
            case .business: return .business
            case .group: return .group
            case .standard: return .standard
            default: return .standard
            }
        }()
        
        setCalendar(for: invitation.id, with: responseStatus)
    }
    
    func handleHideFromTimeline(_ invitation: Appointment) {
        setCalendar(for: invitation.id, with: .rejected)
    }
}

// MARK: - Privates
private extension NewInvitationDetailInteractor {
    func setCalendar(for id: Int, with responseStatus: UserResponseType) {
        appointmentApiService
            .setCalendar(
                for: id,
                with: responseStatus) { [presenter, errorHandler] result in
                    switch result {
                    case .success:
                        let isAdded = !(responseStatus == .rejected)
                        presenter.presentCalendarStatusSet(isAdded: isAdded)
                    case .failure(let error):
                        errorHandler.handle(error)
                    }
                }
    }
    
    func updateDatabase(_ appointmentId: Int, _ status: AppointmentStatus) {
        appointmentDataService.updateAppointment(appointmentId: appointmentId, appointmentStatus: status) { result in
            switch result {
            case .success: Console.log(type: .success, "Success updating database")
            case .failure(let error): Console.log(type: .error, "Failure updating database: \(error.localizedDescription)")
            }
        }
    }
    
    func handleChats(_ chats: [String]) {
        guard !chats.isEmpty else { return }// TODO: Complete when the chats implementation is more clear (implemented in API)
        presenter.presentChats(
                chats.map { InvitationAddon.chatPrivate($0) }
            )
    }
    
    func handleLocation(lat: Double, long: Double) {
        lat == 0.0 && long == 0.0
            ? presenter.presentEmptyLocation()
            : presenter.presentLocation(latitude: lat, longitude: long)
    }
    
    func handleDates(_ dates: [AppointmentDate]?) {
        guard let invitation = self.invitation, let dates = dates, !dates.isEmpty else {
            errorHandler.handle(AppointmentError.noDates) // TODO: maybe just display empty dates?
            return
        }
           
        guard let finalDate: AppointmentDate = { return dates.first(where: { $0.isFinal == 1 }) }() else {
            presenter.presentSuggestedDates(from: dates)
            handleProposedDates()
            return
        }
        presenter.presentSelectedDate(from: finalDate)
        presenter.presentBasicInfo(from: invitation)
    }
    
    func handleProposedDates() {
        guard let invitation = self.invitation else { return }

        guard isOutgoing, invitation.appointmentStatus == .created else {
            presenter.presentBasicInfo(from: invitation)
            return
        }
        
        dateApiService.getProposedDates(appointmentId: invitation.id) { [weak self] result in
            print("ðŸ˜ˆ", result)
            switch result {
            case .success(let proposedDateResponse):
                if proposedDateResponse.isEmpty {
                    self?.presenter.presentBasicInfo(from: invitation)
                } else {
                    self?.proposedDates = proposedDateResponse
                    guard let startDate = proposedDateResponse.first?.startDate else { return }
                    guard let endDate = proposedDateResponse.first?.endDate else { return }
                    self?.presenter.presentProposedDate(startDate: startDate,
                                                        endDate: endDate)
                }
            case .failure(let error):
                self?.errorHandler.handle(error)
            }
        }
    }
}
