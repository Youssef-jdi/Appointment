//
//  InvitationDetailInteractor.swift
//  appointment
//
//  Created by Youssef Jdidi on 3/5/20.
//  Copyright (c) 2020 DTT. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//
//  This template is meant to work with Swinject.

import UIKit

//sourcery: AutoMockable
protocol InvitationDetailInteractorProtocol {
    func cancelAsCreator(invitation: Appointment)
    func cancelAsInvitee(invitation: Appointment)

    func handleSetProposedDates(invitation: Appointment)
    func handleAcceptProposedDate(invitation: Appointment)
    func handleRejectProposedDate(invitation: Appointment)

}

class InvitationDetailInteractor: InvitationDetailInteractorProtocol {
    
    // MARK: - Properties
    private var proposedDates: [AppointmentProposedDate] = []
    
    // MARK: DI
    private let presenter: InvitationDetailPresenterProtocol
    private let invitationService: InvitationServiceProtocol
    private let appointmentDataService: AppointmentDataServiceProtocol
    private let appointmentDateApiService: AppointmentDateApiServiceProtocol
    private let userDataService: CurrentUserDataServiceProtocol
    private let errorHandler: ErrorHandlerProtocol
    
    init(
        presenter: InvitationDetailPresenterProtocol,
        invitationService: InvitationServiceProtocol,
        appointmentDataService: AppointmentDataServiceProtocol,
        errorHandler: ErrorHandlerProtocol,
        appointmentDateApiService: AppointmentDateApiServiceProtocol,
        userDataService: CurrentUserDataServiceProtocol
    ) {
        self.presenter = presenter
        self.invitationService = invitationService
        self.appointmentDataService = appointmentDataService
        self.appointmentDateApiService = appointmentDateApiService
        self.errorHandler = errorHandler
        self.userDataService = userDataService
    }
    
    func cancelAsCreator(invitation: Appointment) {
        invitationService.cancelAsCreator(invitationId: invitation.id) {[weak self] result in
            guard let self = self else { return }
            switch result {
            case .success:
                self.updateDataBase(invitation.id, .cancelled)
                self.presenter.presentCancelInvitationSuccess()
            case .failure(let error): self.presenter.presentCancelInvitationFailure(error: error)
            }
        }
    }
    
    func cancelAsInvitee(invitation: Appointment) {
        invitationService.cancelAsInvitee(invitationId: invitation.id) {[weak self] result in
            guard let self = self else { return }
            switch result {
            case .success:
                self.updateDataBase(invitation.id, .rejected)
                self.presenter.presentCancelInvitationSuccess()
            case .failure(let error):
                self.presenter.presentCancelInvitationFailure(error: error)
            }
        }
    }


    private func updateDataBase(_ appointmentId: Int, _ status: AppointmentStatus) {
        appointmentDataService.updateAppointment(appointmentId: appointmentId, appointmentStatus: status) { result in
            switch result {
            case .success: Console.log(type: .success, "Success updating database")
            case .failure(let error): Console.log(type: .error, "Failure updating database: \(error.localizedDescription)")
            }
        }
    }

    func handleSetProposedDates(invitation: Appointment) {
        userDataService.fetchCurrentUser {[weak self] result in
            switch result {
            case .success(let user):
                guard let user = user as? CurrentUserEntity else { return }
                //Check if the current user is the owner
                if invitation.creatorId == user.userId {
                    self?.appointmentDateApiService.getProposedDates(appointmentId: invitation.id) { [weak self] result in
                        print("ðŸ˜ˆ", result)
                        switch result {
                        case .success(let proposedDateResponse):
                            if proposedDateResponse.isEmpty {
                                self?.presenter.presentProposedDatesIsEmpty()
                            } else {
                                self?.proposedDates = proposedDateResponse
                                guard let startDate = proposedDateResponse.first?.startDate else { return }
                                guard let endDate = proposedDateResponse.first?.endDate else { return }
                                self?.presenter.presentProposedDate(startDate: startDate,
                                                                    endDate: endDate)
                            }
                        case .failure(let error):
                            self?.errorHandler.handle(error)
                        }
                    }
                }
            default: break
            }
        }
    }
    
    func handleAcceptProposedDate(invitation: Appointment) {
        let currentProposedDate = self.proposedDates.first
        appointmentDateApiService.respondToProposedDates(appointmentId: invitation.id,
                                                         proposeDateId: currentProposedDate?.id ?? 0,
                                                         status: 1) { [weak self] result in
                                                        print("ðŸ˜ˆ", result)
                                                        switch result {
                                                        case .success:
                                                            if (self?.proposedDates.isEmpty)! {
                                                                self?.presenter.presentProposedDatesIsEmpty()
                                                            } else {
                                                                let updatedProposedDate = self?.proposedDates.filter { $0 != currentProposedDate }
                                                                self?.proposedDates = updatedProposedDate!
                                                                guard let startDate = updatedProposedDate?.first?.startDate else { return }
                                                                guard let endDate = updatedProposedDate?.first?.endDate else { return }
                                                                self?.presenter.presentProposedDate(startDate: startDate,
                                                                                                    endDate: endDate)
                                                            }
                                                        case .failure(let error):
                                                            self?.errorHandler.handle(error)
                                                        }
        }
    }
    
    func handleRejectProposedDate(invitation: Appointment) {
        let currentProposedDate = self.proposedDates.first
        appointmentDateApiService.respondToProposedDates(
            appointmentId: invitation.id,

            proposeDateId: currentProposedDate?.id ?? 0,
            status: 0) {
                [weak self] result in
                print("ðŸ˜ˆ", result)
                switch result {
                case .success:
                    if (self?.proposedDates.isEmpty)! {
                        self?.presenter.presentProposedDatesIsEmpty()
                    } else {
                        let updatedProposedDate = self?.proposedDates.filter { $0 != currentProposedDate }
                        self?.proposedDates = updatedProposedDate!
                }
                case .failure(let error):
                    self?.errorHandler.handle(error)
                }
        }
    }
}
