//
//  DayCalendarPresenter.swift
//  appointment
//
//  Created by Irina Filkovskaya on 08.07.2020.
//  Copyright (c) 2020 DTT. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol DayCalendarPresenterProtocol {
    func set(viewController: DayCalendarViewControllerProtocol)
    
    func presentInitial(date: Date)
    func presentDate(_ date: Date)
    func presentSchedule(_ entries: [AppointmentDate?], isInitial: Bool)
}

class DayCalendarPresenter: DayCalendarPresenterProtocol {

    
    // MARK: - Properties
    /// Specifies the maximum number of events with overlapping times that
    /// can be displayed simultaneously.
    private let maxItemsDisplayablePerHour = 3
    
    // MARK: - DI
    private weak var viewController: DayCalendarViewControllerProtocol?
    private let dateProvider: DateProviderProtocol
    private let dateFormatter: DateFormatterProtocol
    private let calendarBlocksModelProvider: CalendarBlocksModelProviderProtocol
    
    init(
        dateFormatter: DateFormatterProtocol,
        dateProvider: DateProviderProtocol,
        calendarBlocksModelProvider: CalendarBlocksModelProviderProtocol
    ) {
        self.dateFormatter = dateFormatter
        self.dateProvider = dateProvider
        self.calendarBlocksModelProvider = calendarBlocksModelProvider
    }
    
    func set(viewController: DayCalendarViewControllerProtocol) {
        self.viewController = viewController
    }
    
    // MARK: - Presentation Logic
    func presentInitial(date: Date) {
        viewController?.setInitialDate(dateFormatter.formatDate(date: date, format: "dd.MM.yyyy"))
    }

    func presentDate(_ date: Date) {
        viewController?.displayDate(
            dateFormatter.formatDate(
                date: date,
                format: "dd.MM.yyyy")
        )
    }
    
    func presentSchedule(_ entries: [AppointmentDate?], isInitial: Bool) {
        
        let items: [CalendarItem] = entries
            .map {
                let start = dateProvider.date(from: $0?.startTime ?? 0).hour
                var end = dateProvider.date(from: (($0?.endTime ?? 0) + 1)).hour
                if end < start {
                    end = 24
                } // NOTE TO DEV: This is a workaround for appointments whose ending falls
                // behind midnight (00:00 of the following day and later)
                
                return CalendarItem(
                    title: $0?.appointmentTitle ?? "",
                    startTime: start,
                    endTime: end
                    // TODO: Re-visit the logic for displaying the ending time,
                    // especially if it is something like a few minutes after the hour started
                )
            }
        
        let viewModel = calendarBlocksModelProvider.model(
            from: items,
            maxDisplayableTogether: maxItemsDisplayablePerHour
        )
        viewController?.displayCalendar(from: viewModel, isInitial: isInitial)
    }
}
